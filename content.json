{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"SpringBoot_day02","slug":"黑马程序员/Spring_boot/SpringBoot_day02","date":"2021-08-01T13:55:34.000Z","updated":"2021-08-01T14:04:40.437Z","comments":true,"path":"2021/08/01/黑马程序员/Spring_boot/SpringBoot_day02/","link":"","permalink":"http://example.com/2021/08/01/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/Spring_boot/SpringBoot_day02/","excerpt":"","text":"SpringBoot 原理分析SpringBoot自动配置Condition是在 Spring 4.0 增加的条件判断功能，通过这个可以功能可以实现选择性的创建 Bean 操作。 SpringBoot是如何知道要创建哪个 Bean 的？比如 SpringBoot 是如何知道要创建 RedisTemplate 的？ 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 12345678910@SpringBootApplicationpublic class Test1Application &#123; public static void main(String[] args) &#123; //启动SpringBoot的应用，返回Spring的IOC容器 ConfigurableApplicationContext context = SpringApplication.run(Test1Application.class, args); //获取Bean，redisTemplate Object redisTemplate = context.getBean(&quot;redisTemplate&quot;); System.out.println(redisTemplate); &#125;&#125; Spring会根据Condition判断有没有redis对应的字节码文件，有就创建Bean。 案例：需求在Spring 的 IOC 容器中有一个 User 的 Bean ，现要求 导入 Jedis 坐标后，加载该 Bean ，没导入，则不加载。 将类的判断定义为动态的。判断哪个字节码文件存在可以动态指定。 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt; 123456789101112131415//注意实现的是spirngframework.context.annotation包下的条件接口public class ClassCondition implements Condition &#123; @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; //导入 Jedis 坐标后，加载该 Bean，否则不会创建该bean，并会抛出异常 //判断：redis.clients.jedis.Jedis文件是否存在 try &#123; Class&lt;?&gt; aClass = Class.forName(&quot;redis.clients.jedis.Jedis&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); return false; &#125; return true; &#125;&#125; 12345678@Configurationpublic class UserConfig &#123; @Bean @Conditional(ClassCondition.class) public User user()&#123; return new User(); &#125;&#125; 12345678910@SpringBootApplicationpublic class Test1Application &#123; public static void main(String[] args) &#123; //启动SpringBoot的应用，返回Spring的IOC容器 ConfigurableApplicationContext context = SpringApplication.run(Test1Application.class, args); Object user = context.getBean(&quot;user&quot;); System.out.println(user); &#125;&#125; 将类的判断设置为动态的 12345678910111213141516171819202122232425//注意实现的是spirngframework.context.annotation包下的条件接口public class ClassCondition implements Condition &#123; /** * * @param conditionContext 上下文对象。用于获取环境，IOC容器，ClassLoader对象 * @param annotatedTypeMetadata 注解元对象。可以用于获取注解定义的属性值。 * @return */ @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; //导入 Jedis 坐标后，加载该 Bean //判断：redis.clients.jedis.Jedis文件是否存在 Map&lt;String, Object&gt; map = annotatedTypeMetadata.getAnnotationAttributes(ConditionOnClass.class.getName()); String[] value = (String[])map.get(&quot;value&quot;); try &#123; for(String className : value)&#123; Class&lt;?&gt; aClass = Class.forName(className); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); return false; &#125; return true; &#125;&#125; 1234567@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional(ClassCondition.class)public @interface ConditionOnClass &#123; String[] value();&#125; 123456789101112131415@Configurationpublic class UserConfig &#123; @Bean// @Conditional(ClassCondition.class) @ConditionOnClass(&quot;redis.clients.jedis.Jedis&quot;) public User user()&#123; return new User(); &#125; @Bean @ConditionalOnProperty(name = &quot;itcast&quot;,havingValue = &quot;itheima&quot;) public User user2()&#123; return new User(); &#125;&#125; 12#application.propertiesitcast=itheima 123456789101112@SpringBootApplicationpublic class Test1Application &#123; public static void main(String[] args) &#123; //启动SpringBoot的应用，返回Spring的IOC容器 ConfigurableApplicationContext context = SpringApplication.run(Test1Application.class, args); Object user1 = context.getBean(&quot;user&quot;); Object user2 = context.getBean(&quot;user2&quot;); System.out.println(user1); System.out.println(user2); &#125;&#125; Condition小结 自定义条件： 定义条件类：自定义类实现 Condition 接口，重写 matches 方法，在 matches 方法中进行逻辑判断，返回boolean 值 。 matches 方法两个参数： context ：上下文对象，可以获取属性值，获取类加载器，获取 BeanFactory 等。 metadata ：元数据对象，用于获取注解属性。 判断条件： 在初始化 Bean 时，使用 @Conditional 条件类 class 注解 SpringBoot 提供的常用条件注解：• ConditionalOnProperty 判断配置文件中是否有对应属性和值才初始化 Bean• ConditionalOnClass 判断环境中是否有对应字节码文件才初始化 Bean• ConditionalOnMissingBean 判断环境中没有对应 Bean 才初始化 Bean 切换内置web 服务器SpringBoot的 web 环境中默认使用 tomcat 作为内置服务器，其实 SpringBoot 提供了 4 中内置服务器供我们选择，我们可以很方便的进行切换。Jetty，Netty，Tomcat，Undertow。 引入web环境依赖，会自动加入tomcat服务器。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 更改为使用Jetty服务器。 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--排除tomcat依赖--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入jetty的依赖--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; @Enable注解SpringBoot中提供了很多 Enable 开头的注解，这些注解都是用于动态启用某些功能的。而其底层原理是使用 @Import 注解导入一些配置类，实现 Bean 的动态加载。 SpringBoot工程是否可以直接获取 jar 包（第三方）中定义的 Bean? 不可以 other模块中： 1234package com.itheima.domain;public class User &#123;&#125; 1234567891011121314package com.itheima.config;import com.itheima.domain.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class UserConfig &#123; @Bean public User user() &#123; return new User(); &#125;&#125; Enable模块中内容： 获取另外一模块内容， 12345&lt;dependency&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;springboot-enable-other&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819202122232425262728293031323334package com.itheima.springbootenable;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.Bean;import redis.clients.jedis.Jedis;import java.util.Map;/** * @ComponentScan 扫描范围：当前引导类所在包及其子包 * * com.itheima.springbootenable * com.itheima.config * //1.使用@ComponentScan扫描com.itheima.config包 * //2.可以使用@Import注解，加载类。这些类都会被Spring创建，并放入IOC容器 * //3.可以对Import注解进行封装。 */@SpringBootApplication//@ComponentScan(&quot;com.itheima.config&quot;)//@Import(UserConfig.class)@EnableUserpublic class SpringbootEnableApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(SpringbootEnableApplication.class, args); //获取Bean Object user = context.getBean(&quot;user&quot;); System.out.println(user); &#125;&#125; 12345678910111213//使用注解需要在other模块下建立此注解。package com.itheima.config;import org.springframework.context.annotation.Import;import java.lang.annotation.*;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(UserConfig.class)public @interface EnableUser &#123;&#125; @Import注解@Enable 底层依赖于 @Import 注解导入一些类，使用 @Import 导入的类会被 Spring 加载到 IOC 容器中。而 @Import 提供 4 种用法: 导入 Bean 导入配置类 导入 ImportSelector 实现类。一般用于加载配置文件中的类 导入 ImportBeanDefinitionRegistrar 实现类。 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.springbootenable;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.Bean;import redis.clients.jedis.Jedis;import java.util.Map;/** * Import4中用法： * 1. 导入Bean * 2. 导入配置类 * 3. 导入ImportSelector的实现类。 * 4. 导入ImportBeanDefinitionRegistrar实现类 *///@Import(User.class)//@Import(UserConfig.class)//@Import(MyImportSelector.class)//@Import(&#123;MyImportBeanDefinitionRegistrar.class&#125;)@SpringBootApplicationpublic class SpringbootEnableApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(SpringbootEnableApplication.class, args); User user = context.getBean(User.class); System.out.println(user); Role role = context.getBean(Role.class); System.out.println(role); /* Map&lt;String, User&gt; map = context.getBeansOfType(User.class); System.out.println(map);*/ /* Object user = context.getBean(&quot;user&quot;); System.out.println(user); //第四种方法，起的名称叫做user */ &#125;&#125; 12345678910111213141516171819package com.itheima.config;import com.itheima.domain.Role;import com.itheima.domain.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;//@Configuration//使用import导入类，可以省略该注解public class UserConfig &#123; @Bean public User user() &#123; return new User(); &#125; @Bean public Role role() &#123; return new Role(); &#125;//role和user一样，就是个domain包下的类&#125; 第三种方式：other模块中 123456789101112package com.itheima.config;import org.springframework.context.annotation.ImportSelector;import org.springframework.core.type.AnnotationMetadata;public class MyImportSelector implements ImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[]&#123;&quot;com.itheima.domain.User&quot;, &quot;com.itheima.domain.Role&quot;&#125;; //字符串可以从配置文件中获取。 &#125;&#125; 第四种方式：other模块中 12345678910111213141516package com.itheima.config;import com.itheima.domain.User;import org.springframework.beans.factory.support.AbstractBeanDefinition;import org.springframework.beans.factory.support.BeanDefinitionBuilder;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;import org.springframework.core.type.AnnotationMetadata;public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(User.class).getBeanDefinition(); registry.registerBeanDefinition(&quot;user&quot;, beanDefinition); &#125;&#125; @EnableAutoConfiguration注解 @EnableAutoConfiguration 注解内部使用 @Import(AutoConfigurationImportSelector.class) 来加载配置类。 配置文件位置： META INF/spring.factories ，该配置文件中定义了大量的配置类，当 SpringBoot 应用启动时，会自动加载这些配置类，初始化 Bean 并不是所有的 Bean 都会被初始化，在配置类中使用 Condition 来加载满足条件的 Bean 依赖可以在mvnrepository.com网站搜索如使用mybatis 可以搜索 mybatis spring-boot。 123456&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--第三方提供的依赖会把名字放前面--&gt; 案例：需求 自定义redis starter 。要求当导入 redis 坐标时， SpringBoot 自动创建 Jedis 的 Bean 案例：实现步骤 创建 redis spring boot autoconfigure 模块 创建 redis spring boot starter 模块 依赖 redis springboot autoconfigure 的模块 在 redis spring boot autoconfigure 模块中初始化 Jedis 的Bean 。并定义 META INF/ spring.factories 文件 在测试模块中引入自定义的 redis starter 依赖，测试获取Jedis 的 Bean ，操作 redis 。 创建redis-spring-boot-autoconfigure模块（包名为configure） 引入jedis依赖 1234&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt; 新建核心配置类 123456789101112131415161718192021222324package com.itheima.redis.config;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import redis.clients.jedis.Jedis;@Configuration@EnableConfigurationProperties(RedisProperties.class)//使RedisProperties类被spring识别@ConditionalOnClass(Jedis.class)//Jedis在的时候才会加载Beanpublic class RedisAutoConfiguration &#123; /** * 提供Jedis的bean */ @Bean @ConditionalOnMissingBean(name = &quot;jedis&quot;)//如果没有叫做jedis的Bean才会加载 public Jedis jedis(RedisProperties redisProperties) &#123; System.out.println(&quot;RedisAutoConfiguration....&quot;); return new Jedis(redisProperties.getHost(), redisProperties.getPort()); &#125;&#125; 新建实体类 将实体类于配置文件相绑定 12345678910package com.itheima.redis.config;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = &quot;redis&quot;)public class RedisProperties &#123; private String host = &quot;localhost&quot;; private int port = 6379; //getter setter方法&#125; 在resources目录下新建META-INF/spring.factories文件 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.itheima.redis.config.RedisAutoConfiguration 创建redis-spring-boot-starter模块（包名为redis） 引入依赖 123456&lt;!--引入configure--&gt;&lt;dependency&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;redis-spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 使用enable模块 引入自定义的模块依赖 123456&lt;!--自定义的redis的starter--&gt;&lt;dependency&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;redis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627package com.itheima.springbootenable;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.Bean;import redis.clients.jedis.Jedis;import java.util.Map;@SpringBootApplicationpublic class SpringbootEnableApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(SpringbootEnableApplication.class, args); Jedis jedis = context.getBean(Jedis.class); System.out.println(jedis); jedis.set(&quot;name&quot;,&quot;itcast&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); &#125;//会打印RedisAutoConfiguration.... @Bean public Jedis jedis()&#123; return new Jedis(&quot;localhost&quot;,6379); &#125;//不会打印RedisAutoConfiguration.... ，证明ConditionalOnMissingBean生效&#125; 新建application.properties 12redis.port=6666#链接会失败，证明生效 SpringBoot监听机制Java的监听机制SpringBoot监听机制，其实是对 Java 提供的事件监听机制的封装。Java中的事件监听机制定义了以下几个角色： 事件： Event ，继承 java.util.EventObject 类的对象 事件源： Source ，任意对象 Object 监听器： Listener ，实现 java.util.EventListener 接口 的对象 SpringBoot监听机制SpringBoot在项目启动时，会对几个监听器进行回调，我们可以实现这些监听器接口，在项目启动时完成一些操作。ApplicationContextInitializer、 SpringApplicationRunListener 、 CommandLineRunner 、ApplicationRunner 前两个类想要生效需要先配置META-INF/spring.factories文件 123org.springframework.context.ApplicationContextInitializer=com.itheima.springbootlistener.listener.MyApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=com.itheima.springbootlistener.listener.MySpringApplicationRunListener 新建MyApplicationContextInitializer类 1234567891011121314package com.itheima.springbootlistener.listener;import org.springframework.context.ApplicationContextInitializer;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.stereotype.Component;@Componentpublic class MyApplicationContextInitializer implements ApplicationContextInitializer &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println(&quot;ApplicationContextInitializer....initialize&quot;); //可以用于项目还没有准备IOC容器之前检测一些资源是否存在。 &#125;&#125; 新建MySpringApplicationRunListener类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.springbootlistener.listener;import org.springframework.boot.SpringApplication;import org.springframework.boot.SpringApplicationRunListener;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.core.env.ConfigurableEnvironment;import org.springframework.stereotype.Component;public class MySpringApplicationRunListener implements SpringApplicationRunListener &#123; //SpringApplication 为项目启动时 事件源，可以产生很多生命周期事件 该构造不能省略 public MySpringApplicationRunListener(SpringApplication application, String[] args) &#123; &#125; @Override public void starting() &#123; System.out.println(&quot;starting...项目启动中&quot;); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; System.out.println(&quot;environmentPrepared...环境对象开始准备&quot;); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println(&quot;contextPrepared...上下文对象开始准备&quot;); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println(&quot;contextLoaded...上下文对象开始加载&quot;); &#125; @Override public void started(ConfigurableApplicationContext context) &#123; System.out.println(&quot;started...上下文对象加载完成&quot;); &#125; @Override public void running(ConfigurableApplicationContext context) &#123; System.out.println(&quot;running...项目启动完成，开始运行&quot;); &#125; @Override public void failed(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println(&quot;failed...项目启动失败&quot;); &#125;&#125; 新建MyCommandLineRunner类 12345678910111213141516package com.itheima.springbootlistener.listener;import org.springframework.boot.CommandLineRunner;import org.springframework.stereotype.Component;import java.util.Arrays;@Componentpublic class MyCommandLineRunner implements CommandLineRunner &#123; //与下面那种用法基本相同 @Override public void run(String... args) throws Exception &#123; System.out.println(&quot;CommandLineRunner...run&quot;); System.out.println(Arrays.asList(args)); &#125;&#125; 新建MyApplicationRunner类 1234567891011121314151617181920package com.itheima.springbootlistener.listener;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.stereotype.Component;import java.util.Arrays;/** * 当项目启动后执行run方法。可以执行缓存预热，如让redis在项目启动时把数据库信息提前加载到缓存， * 防止第一个人查询时缓存里没有数据 */@Componentpublic class MyApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(&quot;ApplicationRunner...run&quot;); System.out.println(Arrays.asList(args.getSourceArgs())); &#125;&#125; SpringBoot 启动流程分析启动流程 Spring Boot 监控SpringBoot监控概述SpringBoot自带监控功能 Actuator ，可以帮助实现对程序内部运行情况监控，比如监控状况、 Bean 加载情况、配置属性、日志信息等。 SpringBoot监控使用使用步骤 导入依赖坐标 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--在Ops中可以直接勾选--&gt; 访问 http://localhost:8080/acruator 路径 描述 /beans 描述应用程序上下文里全部的Bean，以及它们的关系 /env 获取全部环境属性 /env/{name} 根据名称获取特定的环境属性值 /health 报告应用程序的健康指标，这些值由HealthIndicator的实现类提供 /info 获取应用程序的定制信息，这些信息由info打头的属性提供（配置文件中） /mappings 描述全部的URI路径，以及它们和控制器(包含Actuator端点)的映射关系 /metrics 报告各种应用程序度量信息，比如内存用量和HTTP请求计数 /metrics/{name} 报告指定名称的应用程序度量值 /trace 提供基本的HTTP请求跟踪信息(时间戳、HTTP头等) application.properties 12345678info.name=zhangsaninfo.age=22#开启健康检查的完整信息，为了安全默认为关闭，有up和 down两种状态management.endpoint.health.show-details=always#将web的所有的监控endpoint暴露出来management.endpoints.web.exposure.include=* SpringBoot监控 Spring Boot Admin Spring Boot Admin 是一个开源社区项目，用于管理和监控 SpringBoot 应用程序。 Spring Boot Admin 有两个角色，客户端 ( 和服务端 ）。 应用程序作为 Spring Boot Admin Client 向为 Spring Boot Admin Server 注册 Spring Boot Admin Server 的 UI 界面将 Spring Boot Admin Client 的 Actuator Endpoint 上的一些监控信息。 使用步骤 admin-server（可以监控多个client模块） 创建 admin server 模块 导入依赖坐标spring-boot-admin-starter-server 和web模块 在引导类上启用监控功能 EnableAdminServer 12345678@EnableAdminServer@SpringBootApplicationpublic class SpringbootAdminServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootAdminServerApplication.class, args); &#125;&#125; 两个项目在一个地址，端口都是8080会重复，为方便，更改下端口 新建application.properties文件 1server.port=9000 admin-client 创建 admin client 模块 导入依赖坐标spring-boot-admin-starter-client 和web模块 配置相关信息： server 地址等 application.properties文件 1234# 执行admin.server地址spring.boot.admin.client.url=http://localhost:9000management.endpoint.health.show-details=alwaysmanagement.endpoints.web.exposure.include=* 启动 server 和 client 服务，访问 server（localhost:9000） SpringBoot 项目部署SpringBoot项目部署SpringBoot项目开发完毕后，支持两种方式部署到服务器： jar 包 官方推荐 创建deploy模块，导入web依赖，新建一个Controller类 12345678@RequestMapping(&quot;/user&quot;)@RestControllerpublic class UserController &#123; @RequestMapping(&quot;/findAll&quot;) public String findAll()&#123; return &quot;succcess&quot;; &#125;&#125; 使用在Maven Project中点击package打为jar包（默认极为打为jar包） 将jar包放在服务器 执行java -jar .\\*.jar即可 war 包 更改项目中的pom文件&lt;packaging&gt;war&lt;/packaging&gt; 更改引导类继承SpringBootServletInitializer类，重写configure方法。 12345678910@SpringBootApplicationpublic class SpringbootDeployApplication extends SpringBootServletInitializer &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootDeployApplication.class, args); &#125; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; return builder.sources(SpringbootDeployApplication.class); &#125;&#125; 将war包放在tomcat的webapps目录下，启动Tomcat即可。 访问地址为localhost:8080/springboot/user/findAll,spirngboot为war包名称，也是在tomcat中的虚拟目录。 内置更改的端口号也不会生效，这时更改端口号需要在Tomcat的外置配置文件中更改。","categories":[],"tags":[{"name":"黑马程序员 springboot","slug":"黑马程序员-springboot","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot/"}]},{"title":"01_redis入门","slug":"黑马程序员/redis/01_redis入门","date":"2021-07-31T08:47:55.000Z","updated":"2021-07-31T08:53:01.602Z","comments":true,"path":"2021/07/31/黑马程序员/redis/01_redis入门/","link":"","permalink":"http://example.com/2021/07/31/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/01_redis%E5%85%A5%E9%97%A8/","excerpt":"","text":"Redis入门Redis 简介12306 问题现象 海量用户 高并发 罪魁祸首——关系型数据库 性能瓶颈：磁盘IO性能低下 扩展瓶颈：数据关系复杂，扩展性差，不便于大规模集群 解决思路Nosql： 降低磁盘IO次数，越低越好 —— 内存存储 去除数据间关系，越简单越好 —— 不存储关系，仅存储数据 NosqlNoSQL：即 Not-Only SQL（ 泛指非关系型的数据库），作为关系型数据库的补充。 作用：应对基于海量用户和海量数据前提下的数据处理问题。 特征： 可扩容，可伸缩 大数据量下高性能 灵活的数据模型 高可用 常见 Nosql 数据库： Redis memcache HBase MongoDB 解决方案（电商场景） Redis概念：Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。 特征： 数据间没有必然的关联关系 内部采用单线程机制进行工作 高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。 多数据类型支持 字符串类型 string 列表类型 list 散列类型 hash 集合类型 set 有序集合类型 sorted_set 持久化支持。可以进行数据灾难恢复 Redis 的应用 为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息等 任务队列，如秒杀、抢购、购票排队等 即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等 时效性信息控制，如验证码控制、投票控制等 分布式数据共享，如分布式集群架构中的 session 分离 消息队列 分布式锁 Redis 的下载与安装Redis 的下载Linux 版（适用于企业级开发） Redis 高级开始使用 以4.0 版本作为主版本 Windows 版本（适合零基础学习） Redis 入门使用 以 3.2 版本作为主版本 下载地址：https://github.com/MSOpenTech/redis/tags 安装 Redis 启动 Redis服务器启动 端口：6379 PID：随机生成 客户端连接 Redis 的基本操作命令行模式工具使用思考 功能性命令 清除屏幕信息 帮助信息查阅 退出指令 信息添加 功能：设置 key，value 数据 命令 1set key value 范例 1set name itheima 信息查询 功能：根据 key 查询对应的 value，如果不存在，返回空（nil） 命令 1get key 范例 1get name 清除屏幕信息 功能：清除屏幕中的信息 命令 1clear 退出客户端命令行模式 功能：退出客户端 命令 123quit exit &lt;ESC&gt; 帮助 功能：获取命令帮助文档，获取组中所有命令信息名称 命令 12help 命令名称 help @组名 总结Redis 入门 Redis 简介 Redis 的下载与安装 Redis 的基本操作 set/get clear help","categories":[],"tags":[{"name":"黑马程序员 redis","slug":"黑马程序员-redis","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-redis/"}]},{"title":"SpringBoot_day01","slug":"黑马程序员/Spring_boot/SpringBoot_day01","date":"2021-07-30T08:04:16.000Z","updated":"2021-07-30T08:05:50.662Z","comments":true,"path":"2021/07/30/黑马程序员/Spring_boot/SpringBoot_day01/","link":"","permalink":"http://example.com/2021/07/30/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/Spring_boot/SpringBoot_day01/","excerpt":"","text":"SpringBoot 概述SpringBoot 概念SpringBoot提供了一种快速使用Spring的方式，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。2014 年4 月，Spring Boot 1.0.0 发布。Spring的顶级项目之一(https://spring.io)。 Spring 缺点1）配置繁琐 虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。 所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但它要求的回报也不少。 2）依赖繁琐 项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。 SpringBoot 功能1）自动配置 Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是SpringBoot自动完成的。 2）起步依赖 起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。 3）辅助功能 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等。 Spring Boot 并不是对Spring 功能上的增强，而是提供了一种快速使用Spring 的方式。 小结SpringBoot提供了一种快速开发Spring项目的方式，而不是对Spring功能上的增强。 Spring的缺点： 配置繁琐 依赖繁琐 SpringBoot功能： 自动配置 起步依赖：依赖传递 辅助功能 SpringBoot 快速入门案例：需求 搭建SpringBoot工程，定义HelloController.hello()方法，返回”Hello SpringBoot!”。 案例：实现步骤 ①创建Maven项目②导入SpringBoot起步依赖③定义Controller④编写引导类⑤启动测试 步骤 新建maven项目（不适用模板） pom.xml文件中引入依赖，在官方文档中寻找Getting Started，将parent和denpendencies内容复制到pom.xml文件中12345678910111213141516171819&lt;!--springboot工程需要继承的父工程--&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt; &lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--功能：写配置文件的时候会给提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编写controller 12345678@RestController//@RestController注解相当于@ResponseBody ＋ @Controllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello Spring Boot&quot;; &#125;&#125; 编写引导类12345678/*** 引导类 一般以Application结尾, SpringBoot项目的入口*/public class HelloApplication&#123; public static void main(String[] args)&#123; SpringApplication.run(HelloApplication.class, args); &#125;&#125; 运行 访问 localhost:8080/hello即可 小结 SpringBoot在创建项目时，使用jar的打包方式。 SpringBoot的引导类，是项目入口，运行main方法就可以启动项目。 使用SpringBoot和Spring构建的项目，业务代码编写方式完全一样。 案例：需求 使用idea搭建SpringBoot工程，定义HelloController.hello()方法，返回”Hello SpringBoot!”。 案例：步骤 新建Spring Initializr项目（需要联网） 选择依赖 点击web，勾选Spring Web 编写Controller类1234567@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello Spring Boot&quot;; &#125;&#125; 启动 SpringBoot 起步依赖原理分析起步依赖原理分析 1）spring-boot-starter-parent 2）spring-boot-starter-web 小结 在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。 在各种starter中，定义了完成该功能需要的坐标合集，其中大部分版本信息来自于父工程。 我们的工程继承parent，引入starter后，通过依赖传递，就可以简单方便获得需要的jar包，并且不会存在版本冲突等问题。 SpringBoot 配置配置文件分类SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml（application.yaml）进行配置。 properties： 1server.port=8080 yml: 12server: port: 8080 注意：冒号和8080之间必须有空格。 SpringBoot提供了2种配置文件类型：properteis和yml/yaml 默认配置文件名称：application 在同一级目录下优先级为：properties &gt; yml &gt; yaml YAMLYAML全称是YAML Ain’t Markup Language 。YAML是一种直观的能够被电脑识别的数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，比如：C/C++, Ruby, Python, Java, Perl, C#, PHP等。YML文件是以数据为核心的，比传统的xml方式更加简洁。YAML文件的扩展名可以使用.yml或者.yaml。 properties:12server.port=8080server.address=127.0.0.1 1234&lt;server&gt; &lt;port&gt;8080&lt;/port&gt; &lt;address&gt;127.0.0.1&lt;/address&gt;&lt;/server&gt; 123server: port: 8080 address: 127.0.0.1 简洁，以数据为核心 YAML：基本语法 大小写敏感 数据值前边必须有空格，作为分隔符 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格（各个系统Tab对应的空格数目可能不同，导致层次混乱，idea会自动转换空格）。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 # 表示注释，从这个字符一直到行尾，都会被解析器忽略。 12345server: port: 8080 address: 127.0.0.1name: abc YAML：数据格式 对象(map)：键值对的集合 1234person: name: zhangsan# 行内写法person: &#123;name: zhangsan&#125; 数组：一组按次序排列的值 12345address: -beijing -shanghai# 行内写法address: [beijing,shanghai] 纯量：单个的、不可再分的值 12msg1: &#x27;hello \\n world&#x27; # 单引忽略转义字符，原样输出msg2: &quot;hello \\n world&quot; # 双引识别转义字符 YAML：参数引用1234name: lisiperson: name: $&#123;name&#125; # 引用上边定义的name值 YAML：小结1）配置文件类型 properties：和以前一样 yml/yaml：注意空格 2）yaml：简洁，以数据为核心 基本语法 大小写敏感 数据值前边必须有空格，作为分隔符 使用空格缩进表示层级关系，相同缩进表示同一级 数据格式 对象 数组: 使用“-”表示数组每个元素 纯量 参数引用 ${key} 读取配置内容1）@Value 2）Environment 3）@ConfigurationProperties 123456789101112131415161718@RestControllerpublic class HelloController &#123; @Value(&quot;$&#123;name&#125;&quot;)//要和yml中名字相同 private String name; @Value(&quot;$&#123;person.name&#125;&quot;) private String name2; @Value(&quot;$&#123;person.age&#125;&quot;) private int age; @Value(&quot;$&#123;address[0]&#125;&quot;)//数组 private String address1; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; System.out.println(name); return &quot;hello Spring Boot&quot;; &#125;&#125; 123456789101112@RestControllerpublic class HelloController &#123; @Autowired private Environment env; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; System.out.println(env.getProperty(&quot;person.name&quot;)); System.out.println(env.getProperty(&quot;address[0]&quot;)); return &quot;hello Spring Boot&quot;; &#125;&#125; 12345678910111213141516171819@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String name; private int age; ..getter setter toString方法&#125;@RestControllerpublic class HelloController &#123; @Autowired private Person person; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; System.out.println(person); return &quot;hello Spring Boot&quot;; &#125;&#125; profile我们在开发Spring Boot应用时，通常同一套程序会被安装到不同环境，比如：开发、测试、生产等。其中数据库地址、服务器端口等等配置都不同，如果每次打包时，都要修改配置文件，那么非常麻烦。profile功能就是来进行动态配置切换的。 1）profile配置方式 多profile文件方式（需要在application.properties激活） application-dev.properties 1server.port: 8081 application-test.properties 1server.port: 8082 application-pro.properties 1server.port: 8083 yml多文档方式 application.yml文件内容 1234567891011121314151617181920---server: port: 8081spring: profiles: dev ---server: port: 8082spring: profiles: test---server: port: 8083spring: profiles: pro---#激活spring: profiles: active: dev 2）profile激活方式 配置文件application.properties1spring.profiles.active=dev 虚拟机参数 点击EditConfigutation，配置vm options为 -Dspring.profiles.active=test 命令行参数 点击EditConfigutation，配置Program arguments为 --spring.profiles.active=pro Profile-小结1）profile是用来完成不同环境下，配置动态切换功能的。 2）profile配置方式 多profile文件方式：提供多个配置文件，每个代表一种环境。 application-dev.properties/yml 开发环境 application-test.properties/yml 测试环境 application-pro.properties/yml 生产环境 yml多文档方式： 在yml中使用 --- 分隔不同配置 3）profile激活方式 配置文件：再配置文件中配置：spring.profiles.active=dev 虚拟机参数：在VM options 指定：-Dspring.profiles.active=dev 命令行参数：使用package命令打包，成为jar包后，直接使用命令java –jar xxx.jar --spring.profiles.active=dev 内部配置加载顺序Springboot程序启动时，会从以下位置加载配置文件： file:./config/：当前项目下的/config目录下 file:./ ：当前项目的根目录 classpath:/config/：classpath的/config目录 classpath:/ ：classpath的根目录 加载顺序为上文的排列顺序，高优先级配置的属性会生效 注意：file那两个不符合maven结构不会被打进jar包中，命令行运行不会加载。 外部配置加载顺序通过官网查看外部属性加载顺序： https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html 可以通过命令行更改配置java -jar .\\***.jar --server.port=8082 --server.servlet.context-path=/hehe 也可以通过指定外部文件java -jar .\\***.jar --spring.config.location=e://application.properties jar包也会自动加载同级目录下的application.properties 或config/application.properties文件。 外部配置可以用来在部署时更改内容（已经打成了jar包）。 SpringBoot 整合其他框架案例：需求SpringBoot整合Junit。 案例：实现步骤 搭建SpringBoot工程 引入starter-test起步依赖 编写测试类 添加测试相关注解 @RunWith(SpringRunner.class) @SpringBootTest(classes = 启动类.class) 编写测试方法 123456789101112131415161718192021222324@Servicepublic class UserService&#123; public void add()&#123; System.out.println(&quot;add...&quot;); &#125;&#125;/*** UserService的测试类* 如果测试类是引导类包或者包下的子包，可以省略classes * 如UserServiceTest 在test/java 的 com.itheima.springboottest包下* SpringbootTestApplication在main/java的com.itheima.springboottest包下*/@Runwith(SpringRunner.class)@SpringBootTest(classes = SpringbootTestApplication.class)public class UserServiceTest &#123; @Autowired private UserService userService; @Test public void add()&#123; userService.add(); &#125;&#125; 案例：需求SpringBoot整合Redis。 案例：实现步骤 搭建SpringBoot工程(Nosql) 引入redis起步依赖 spring-boot-starter-data-redis 编写redis相关属性 注入RedisTemplate模板 编写测试方法，测试 1234567891011121314151617181920@Runwith(SpringRunner.class)@SpringBootTestpublic class SpringbootRedisApplicationTests &#123; //redis链接信息默认为本机的ip 6379端口号 @Autowired private RedisTemplate redisTemplate; @Test public void testSet()&#123; //存入数据 redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;zhangsan&quot;); &#125; @Test public void testGet()&#123; //获取数据 Object name = redisTemplate.boundValueOps(&quot;name&quot;).get(); System.out.println(name); &#125;&#125; 12345#application.yml 更改redis ip地址端口号 输入redis会有提示，可以选择spring: redis: host: 127.0.0.1 port: 6379 案例：需求SpringBoot整合MyBatis。 案例：实现步骤 搭建SpringBoot工程(勾选SQL中的MySQL Driver 依赖和 MyBatis Framework依赖) 引入mybatis起步依赖(mybatis-spring-boot-starter,spring-boot 开头的都是spring官方提供的)，添加mysql驱动 mysql-connector-java 编写DataSource和MyBatis相关配置 定义表和实体类 编写dao和mapper文件/纯注解开发 测试 1234567//user实体类public class User &#123; private int id; private String username; private String password; //getter setter toString方法&#125; 123456789#application.xml 需要配置时区，不然会出错spring: datasource: url: jdbc:mysql:///springboot？serverTimezone=UTC driver: com.mysql.jdbc.Driver #会建议使用 com.mysql.cj.jdbc.Driver驱动，上面那个版本太老了。 username: root password: root 123456@Mapper@Repositorypublic interface UserMapper &#123; @Select(&quot;select * from t_user&quot;) public List&lt;User&gt; findAll();&#125; 123456789101112@RunWith(SpringRunner.class)@SpringBootTestpublic class springbootMybatisApplication &#123; @Autowired private UserMapper userMapper; @Test public void testFindAll() &#123; List&lt;User&gt; list = userMapper.findAll(); System.out.println(list); &#125;&#125; 使用xml 新建UserXmlMapper类和UserMapper类基本相同即可 123456&lt;!--还需要一个约束头--&gt;&lt;mapper namespace=&quot;com.itheima.springbootmybatis.mapper.UserXmlMapper&quot;&gt; &lt;select id =&quot;findAll&quot; resultType = &quot;user&quot;&gt; select * from t_user &lt;/select&gt;&lt;/mapper&gt; 12345#application.yml 添加mybatis: mapper-locations: classpath:mapper/*Mapper.xml #mapper映射文件路径 type-aliases-package: com.itheima.springbootmybatis.domain #config-location: #指定mybatis的核心配置文件 稍微更改下测试类运行即可。","categories":[],"tags":[{"name":"黑马程序员 springboot","slug":"黑马程序员-springboot","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot/"}]},{"title":"16_MyBatis注解开发","slug":"黑马程序员/SSM框架/16_MyBatis注解开发","date":"2021-07-28T02:38:21.000Z","updated":"2021-07-28T02:48:32.028Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/16_MyBatis注解开发/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/16_MyBatis%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","excerpt":"","text":"1.Mybatis的注解开发1.1 MyBatis的常用注解这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper 映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。 @Insert：实现新增@Update：实现更新@Delete：实现删除@Select：实现查询@Result：实现结果集封装@Results：可以与@Result 一起使用，封装多个结果集@One：实现一对一结果集封装@Many：实现一对多结果集封装 1.2 MyBatis的增删改查我们完成简单的user表的增删改查的操作 123456789101112131415161718192021222324252627282930313233343536373839404142private UserMapper userMapper;@Beforepublic void before() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); userMapper = sqlSession.getMapper(UserMapper.class);&#125;@Testpublic void testAdd() &#123; User user = new User(); user.setUsername(&quot;测试数据&quot;); user.setPassword(&quot;123&quot;); user.setBirthday(new Date()); userMapper.add(user);&#125;@Testpublic void testUpdate() throws IOException &#123; User user = new User(); user.setId(16); user.setUsername(&quot;测试数据修改&quot;); user.setPassword(&quot;abc&quot;); user.setBirthday(new Date()); userMapper.update(user);&#125;@Testpublic void testDelete() throws IOException &#123; userMapper.delete(16);&#125;@Testpublic void testFindById() throws IOException &#123; User user = userMapper.findById(1); System.out.println(user);&#125;@Testpublic void testFindAll() throws IOException &#123; List&lt;User&gt; all = userMapper.findAll(); for(User user : all)&#123; System.out.println(user); &#125;&#125; 修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可 1234&lt;mappers&gt; &lt;!--扫描使用注解的类--&gt; &lt;mapper class=&quot;com.itheima.mapper.UserMapper&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt; 或者指定扫描包含映射关系的接口所在的包也可以 1234&lt;mappers&gt; &lt;!--扫描使用注解的类所在的包--&gt; &lt;package name=&quot;com.itheima.mapper&quot;&gt;&lt;/package&gt;&lt;/mappers&gt; 接口中方法上添加注解即可 1234567891011121314151617public interface UserMapper &#123; @Insert(&quot;insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;birthday&#125;)&quot;) public void save(User user); @Update(&quot;update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;&quot;) public void update(User user); @Delete(&quot;delete from user where id=#&#123;id&#125;&quot;) public void delete(int id); @Select(&quot;select * from user where id=#&#123;id&#125;&quot;) public User findById(int id); @Select(&quot;select * from user&quot;) public List&lt;User&gt; findAll();&#125; 1.3 MyBatis的注解实现复杂映射开发实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置 注解 说明 @Results 代替的是标签该注解中可以使用单个@Result注解，也可以使用@Result集合。使用格式：@Results（{@Result（），@Result（）}）或@Results（@Result（）） @Resut 代替了标签和标签 @Result中属性介绍： column：数据库的列名 property：需要装配的属性名 one：需要使用的@One 注解（@Result（one=@One）（））） many：需要使用的@Many 注解（@Result（many=@many）（））） @One （一对一） 代替了 标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。 @One注解属性介绍： select: 指定用来多表查询的 sqlmapper 使用格式：@Result(column=” “,property=””,one=@One(select=””)) @Many （多对一） 代替了标签, 是是多表查询的关键，在注解中用来指定子查询返回对象集合。 使用格式：@Result(property=””,column=””,many=@Many(select=””)) 1.4 一对一查询 一对一查询的模型 用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户 一对一查询的语句 对应的sql语句： select * from orders; select * from user where id=查询出订单的uid; 查询的结果如下： 3. 创建Order和User实体 123456789public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125; 1234567public class User &#123; private int id; private String username; private String password; private Date birthday;&#125; 4. 创建OrderMapper接口 123public interface OrderMapper &#123; List&lt;Order&gt; findAll();&#125; 5. 使用注解配置Mapper 6. 测试结果 1234567@Testpublic void testSelectOrderAndUser() &#123; List&lt;Order&gt; all = orderMapper.findAll(); for(Order order : all)&#123; System.out.println(order); &#125;&#125; 1.5 一对多查询 一对多查询的模型 用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单 ![2129_2 (2)](16_MyBatis注解开发/2129_2 (2).png) 一对多查询的语句 对应的sql语句： select * from user; select * from orders where uid=查询出用户的id; 查询的结果如下： 3. 修改User实体 123456789public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125; 123456789public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList;&#125; 4. 创建UserMapper接口 1List&lt;User&gt; findAllUserAndOrder(); 5. 使用注解配置Mapper 6. 测试结果 123456789List&lt;User&gt; all = userMapper.findAllUserAndOrder();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Order&gt; orderList = user.getOrderList(); for(Order order : orderList)&#123; System.out.println(order); &#125; System.out.println(&quot;-----------------------------&quot;);&#125; 1.6 多对多查询 多对多查询的模型 用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 多对多查询的语句 对应的sql语句： select * from user;select * from role r,user_roleurwhere r.id=ur.role_idand ur.user_id=用户的id 查询的结果如下： 3. 创建Role实体，修改User实体 1234567891011public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList; //代表当前用户具备哪些角色 private List&lt;Role&gt; roleList;&#125; 123456public class Role &#123; private int id; private String rolename;&#125; 4. 添加UserMapper接口方法 1List&lt;User&gt; findAllUserAndRole(); 5. 使用注解配置Mapper 6. 测试结果 12345678910UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAllUserAndRole();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Role&gt; roleList = user.getRoleList(); for(Role role : roleList)&#123; System.out.println(role); &#125; System.out.println(&quot;----------------------------------&quot;);&#125;","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"15_MyBatis多表操作","slug":"黑马程序员/SSM框架/15_MyBatis多表操作","date":"2021-07-28T02:38:03.000Z","updated":"2021-07-28T02:48:04.246Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/15_MyBatis多表操作/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/15_MyBatis%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"1.Mybatis多表查询1.1 一对一查询 一对一查询的模型 用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户 一对一查询的语句 对应的sql语句：select * from orders o,user u where o.uid=u.id; 查询的结果如下： 3. 创建Order和User实体 12345678public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125; 1234567public class User &#123; private int id; private String username; private String password; private Date birthday;&#125; 4. 创建OrderMapper接口 123public interface OrderMapper &#123; List&lt;Order&gt; findAll();&#125; 5. 配置OrderMapper.xml 1234567891011121314&lt;mapper namespace=&quot;com.itheima.mapper.OrderMapper&quot;&gt; &lt;resultMap id=&quot;orderMap&quot; type=&quot;com.itheima.domain.Order&quot;&gt; &lt;id column=&quot;oid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;&gt;&lt;/result&gt; &lt;result column=&quot;total&quot; property=&quot;total&quot;&gt;&lt;/result&gt; &lt;result column=&quot;uid&quot; property=&quot;user.id&quot;&gt;&lt;/result&gt; &lt;result column=&quot;username&quot; property=&quot;user.username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;password&quot; property=&quot;user.password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;user.birthday&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;orderMap&quot;&gt; select *,o.id oid from orders o,user u where o.uid=u.id &lt;/select&gt;&lt;/mapper&gt; 其中还可以配置如下： 1234567891011&lt;resultMap id=&quot;orderMap&quot; type=&quot;com.itheima.domain.Order&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;&gt;&lt;/result&gt; &lt;result column=&quot;total&quot; property=&quot;total&quot;&gt;&lt;/result&gt; &lt;association property=&quot;user&quot; javaType=&quot;com.itheima.domain.User&quot;&gt; &lt;id column=&quot;uid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt; 6. 测试结果 12345OrderMapper mapper = sqlSession.getMapper(OrderMapper.class);List&lt;Order&gt; all = mapper.findAll();for(Order order : all)&#123; System.out.println(order);&#125; 1.2 一对多查询 一对多查询的模型 用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单 ![2109_2 (1)](15_MyBatis多表操作/2109_2 (1).png) 一对多查询的语句 对应的sql语句：select *,o.id oidfrom user u left join orders o on u.id=o.uid; 查询的结果如下： 3. 修改User实体 123456789public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125; 123456789public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList;&#125; 4. 创建UserMapper接口 123public interface UserMapper &#123; List&lt;User&gt; findAll();&#125; 5. 配置UserMapper.xml 12345678910111213141516&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;com.itheima.domain.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;orderList&quot; ofType=&quot;com.itheima.domain.Order&quot;&gt; &lt;result column=&quot;oid&quot; property=&quot;id&quot;&gt;&lt;/result&gt; &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;&gt;&lt;/result&gt; &lt;result column=&quot;total&quot; property=&quot;total&quot;&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt; select *,o.id oid from user u left join orders o on u.id=o.uid &lt;/select&gt;&lt;/mapper&gt; 6. 测试结果 12345678910UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAll();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Order&gt; orderList = user.getOrderList(); for(Order order : orderList)&#123; System.out.println(order); &#125; System.out.println(&quot;----------------------------------&quot;);&#125; 1.3 多对多查询 多对多查询的模型 用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 多对多查询的语句 对应的sql语句：select u.*,r.*,r.id rid from user u left join user_roleuron u.id=ur.user_id inner join role r on ur.role_id=r.id; 查询的结果如下： 3. 创建Role实体，修改User实体 12345678910public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList; //代表当前用户具备哪些角色 private List&lt;Role&gt; roleList;&#125; 12345public class Role &#123; private int id; private String rolename;&#125; 4. 添加UserMapper接口方法 1List&lt;User&gt; findAllUserAndRole(); 5. 配置UserMapper.xml 1234567891011121314&lt;resultMap id=&quot;userRoleMap&quot; type=&quot;com.itheima.domain.User&quot;&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/result&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;roleList&quot; ofType=&quot;com.itheima.domain.Role&quot;&gt; &lt;result column=&quot;rid&quot; property=&quot;id&quot;&gt;&lt;/result&gt; &lt;result column=&quot;rolename&quot; property=&quot;rolename&quot;&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;findAllUserAndRole&quot; resultMap=&quot;userRoleMap&quot;&gt; select u.*,r.*,r.id rid from user u left join user_role ur on u.id=ur.user_id inner join role r on ur.role_id=r.id&lt;/select&gt; 6. 测试结果 1234567891011UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAllUserAndRole();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Role&gt; roleList = user.getRoleList(); for(Role role : roleList)&#123; System.out.println(role); &#125; System.out.println(&quot;----------------------------------&quot;);&#125; 1.4 知识小结MyBatis多表配置方式： 一对一配置：使用&lt;resultMap&gt;做配置一对多配置：使用&lt;resultMap&gt;+&lt;collection&gt;做配置多对多配置：使用&lt;resultMap&gt;+&lt;collection&gt;做配置","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"14_MyBatis核心配置文件深入","slug":"黑马程序员/SSM框架/14_MyBatis核心配置文件深入","date":"2021-07-28T02:37:21.000Z","updated":"2021-07-28T02:47:28.102Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/14_MyBatis核心配置文件深入/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/14_MyBatis%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%B7%B1%E5%85%A5/","excerpt":"","text":"1. MyBatis核心配置文件深入1.1 typeHandlers标签无论是MyBatis在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时，都会用类型处理器将获取的值以合适的方式转换成Java 类型。下表描述了一些默认的类型处理器（截取部分）。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现org.apache.ibatis.type.TypeHandler接口，或继承一个很便利的类org.apache.ibatis.type.BaseTypeHandler，然后可以选择性地将它映射到一个JDBC类型。例如需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。 开发步骤： ①定义转换类继承类BaseTypeHandler②覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult为查询时mysql的字符串类型转换成java的Type类型的方法③在MyBatis核心配置文件中进行注册④测试转换是否正确 1234567891011121314public class MyDateTypeHandler extends BaseTypeHandler&lt;Date&gt; &#123; public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType type) &#123; preparedStatement.setString(i,date.getTime()+&quot;&quot;); &#125; public Date getNullableResult(ResultSet resultSet, String s) throws SQLException &#123; return new Date(resultSet.getLong(s)); &#125; public Date getNullableResult(ResultSet resultSet, int i) throws SQLException &#123; return new Date(resultSet.getLong(i)); &#125; public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException &#123; return callableStatement.getDate(i); &#125;&#125; 1234&lt;!--注册类型自定义转换器--&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=&quot;com.itheima.typeHandlers.MyDateTypeHandler&quot;&gt;&lt;/typeHandler&gt;&lt;/typeHandlers&gt; 测试添加操作： 12user.setBirthday(new Date());userMapper.add2(user); 测试查询操作： 1.2 plugins标签MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据 开发步骤： ①导入通用PageHelper的坐标②在mybatis核心配置文件中配置PageHelper插件③测试分页数据获取 ①导入通用 PageHelper 坐标 1234567891011&lt;!-- 分页助手 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;3.7.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt; ②在mybatis核心配置文件中配置PageHelper插件 12345&lt;!-- 注意：分页助手的插件 配置在通用馆mapper之前 --&gt;&lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt; &lt;!-- 指定方言 --&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;&lt;/plugin&gt; ③测试分页代码实现 12345678910@Testpublic void testPageHelper()&#123; //设置分页参数 PageHelper.startPage(1,2); List&lt;User&gt; select = userMapper2.select(null); for(User user : select)&#123; System.out.println(user); &#125;&#125; 获得分页相关的其他参数 12345678//其他分页的数据PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(select);System.out.println(&quot;总条数：&quot;+pageInfo.getTotal());System.out.println(&quot;总页数：&quot;+pageInfo.getPages());System.out.println(&quot;当前页：&quot;+pageInfo.getPageNum());System.out.println(&quot;每页显示长度：&quot;+pageInfo.getPageSize());System.out.println(&quot;是否第一页：&quot;+pageInfo.isIsFirstPage());System.out.println(&quot;是否最后一页：&quot;+pageInfo.isIsLastPage()); 1.3 知识小结MyBatis核心配置文件常用标签： 1、properties标签：该标签可以加载外部的properties文件2、typeAliases标签：设置类型别名3、environments标签：数据源环境配置标签4、typeHandlers标签：配置自定义类型处理器5、plugins标签：配置MyBatis的插件","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"13_MyBatis映射文件深入（动态SQL）","slug":"黑马程序员/SSM框架/13_MyBatis映射文件深入（动态SQL）","date":"2021-07-28T02:36:56.000Z","updated":"2021-07-28T02:46:52.793Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/13_MyBatis映射文件深入（动态SQL）/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/13_MyBatis%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E6%B7%B1%E5%85%A5%EF%BC%88%E5%8A%A8%E6%80%81SQL%EF%BC%89/","excerpt":"","text":"1.MyBatis映射文件深入1.1 动态sql语句 动态sql语句概述 Mybatis的映射文件中，前面我们的SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的SQL是动态变化的，此时在前面的学习中我们的SQL 就不能满足要求了。 参考的官方文档，描述如下： ![2091_1 (1)](13_MyBatis映射文件深入（动态SQL）/2091_1 (1).png) 动态SQL 之 我们根据实体类的不同取值，使用不同的SQL语句来进行查询。比如在id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。 1234567891011&lt;select id=&quot;findByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from User &lt;where&gt; &lt;if test=&quot;id!=0&quot;&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;username!=null&quot;&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 当查询条件id和username都存在时，控制台打印的sql语句如下： 12345678 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User condition = new User(); condition.setId(1); condition.setUsername(&quot;lucy&quot;); User user = userMapper.findByCondition(condition); … … … 当查询条件只有id存在时，控制台打印的sql语句如下： 1234567 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User condition = new User(); condition.setId(1); User user = userMapper.findByCondition(condition); … … … 动态SQL 之 循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。 12345678&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; select * from User &lt;where&gt; &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 测试代码片段如下： 1234567 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int[] ids = new int[]&#123;2,5&#125;; List&lt;User&gt; userList = userMapper.findByIds(ids); System.out.println(userList); … … … foreach标签的属性含义如下： &lt;foreach&gt;标签用于遍历集合，它的属性： collection：代表要遍历的集合元素，注意编写时不要写#{} open：代表语句的开始部分 close：代表结束部分 item：代表遍历集合的每个元素，生成的变量名 sperator：代表分隔符 1.2 SQL片段抽取Sql中可将重复的sql提取出来，使用时用include 引用即可，最终达到sql重用的目的 12345678910111213&lt;!--抽取sql片段简化编写--&gt;&lt;sql id=&quot;selectUser&quot; select * from User&lt;/sql&gt;&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; where id=#&#123;id&#125;&lt;/select&gt;&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 1.3 知识小结MyBatis映射文件配置：&lt;select&gt;：查询&lt;insert&gt;：插入&lt;update&gt;：修改&lt;delete&gt;：删除&lt;where&gt;：where条件&lt;if&gt;：if判断&lt;foreach&gt;：循环&lt;sql&gt;：sql片段抽取","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"12_MyBatis的Dao层实现方式","slug":"黑马程序员/SSM框架/12_MyBatis的Dao层实现方式","date":"2021-07-28T02:36:30.000Z","updated":"2021-07-28T02:46:29.972Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/12_MyBatis的Dao层实现方式/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/12_MyBatis%E7%9A%84Dao%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/","excerpt":"","text":"1.Mybatis的Dao层实现1.1 传统开发方式 编写UserDao接口 123public interface UserDao &#123; List&lt;User&gt; findAll() throws IOException;&#125; 编写UserDaoImpl实现 12345678910public class UserDaoImpl implements UserDao &#123; public List&lt;User&gt; findAll() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;); sqlSession.close(); return userList; &#125;&#125; 3. 测试传统方式123456@Testpublic void testTraditionDao() throws IOException &#123; UserDao userDao = new UserDaoImpl(); List&lt;User&gt; all = userDao.findAll(); System.out.println(all);&#125; 1.2 代理开发方式 代理开发方式介绍 采用Mybatis的代理开发方式实现DAO 层的开发，这种方式是我们后面进入企业的主流。 Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper 接口开发需要遵循以下规范： 1、Mapper.xml文件中的namespace与mapper接口的全限定名相同 2、Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 3、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 4、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 1.2 代理开发方式 编写UserMapper接口 测试代理方式 1234567891011@Testpublic void testProxyDao() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); //获得MyBatis框架生成的UserMapper接口的实现类 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.findById(1); System.out.println(user); sqlSession.close();&#125; 1.3 知识小结MyBatis的Dao层实现的两种方式： 手动对Dao进行实现：传统开发方式 代理方式对Dao进行实现： UserMapperuserMapper = sqlSession.getMapper(UserMapper.class);","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"11_MyBatis入门操作","slug":"黑马程序员/SSM框架/11_MyBatis入门操作","date":"2021-07-28T02:36:02.000Z","updated":"2021-07-28T02:58:55.863Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/11_MyBatis入门操作/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/11_MyBatis%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"1.Mybatis简介1.1 原始jdbc操作（查询数据） 1.1 原始jdbc操作（插入数据）1.2 原始jdbc操作的分析原始jdbc开发存在的问题如下： ①数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能②sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。③查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置 应对上述问题给出的解决方案： ①使用数据库连接池初始化连接资源②将sql语句抽取到xml配置文件中③使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射 1.3 什么是Mybatis mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。 最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbcapi底层访问细节，使我们不用与jdbcapi打交道，就可以完成对数据库的持久化操作。 2. Mybatis的快速入门2.1 MyBatis开发步骤MyBatis官网地址：http://www.mybatis.org/mybatis-3/ MyBatis开发步骤： ①添加MyBatis的坐标②创建user数据表③编写User实体类④编写映射文件UserMapper.xml⑤编写核心文件SqlMapConfig.xml⑥编写测试类 2.2 环境搭建 导入MyBatis的坐标和其他相关坐标 1234567891011121314151617181920212223242526&lt;!--mybatis坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql驱动坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--单元测试坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--日志坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt; 创建user数据表 编写User实体 123456public class User &#123; private int id; private String username; private String password; //省略get和set方法&#125; 编写UserMapper.xml映射文件 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 编写MyBatis核心文件(SqlMapConfig.xml) 1234567891011121314151617181920&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN“ &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--数据源环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///test&quot;/&gt;&lt;!-- 等同于 &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;--&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.3 编写测试代码1234567891011121314151617public class MyBatisTest&#123; @Test public void test1() throws IOException &#123; //加载核心配置文件 InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //获得sqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); //获得sqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //执行sql语句 List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;); //打印结果 System.out.println(userList); //释放资源 sqlSession.close(); &#125;&#125; 2.4 知识小结MyBatis开发步骤： ①添加MyBatis的坐标②创建user数据表③编写User实体类④编写映射文件UserMapper.xml⑤编写核心文件SqlMapConfig.xml⑥编写测试类 3. MyBatis的映射文件概述 4. MyBatis的增删改查操作4.1 MyBatis的插入数据操作 编写UserMapper映射文件 12345&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;insert id=&quot;add&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; 编写插入实体User的代码 12345678InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int insert = sqlSession.insert(&quot;userMapper.add&quot;, user);System.out.println(insert);//提交事务sqlSession.commit();sqlSession.close(); 插入操作注意问题 插入语句使用insert标签 在映射文件中使用parameterType属性指定要插入的数据类型 Sql语句中使用#{实体属性名}方式引用实体中的属性值 插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象); 插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即sqlSession.commit() 4.2 MyBatis的修改数据操作 编写UserMapper映射文件 12345&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 编写修改实体User的代码 1234567InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int update = sqlSession.update(&quot;userMapper.update&quot;, user);System.out.println(update);sqlSession.commit();sqlSession.close(); 修改操作注意问题 修改语句使用update标签 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象); 4.3 MyBatis的删除数据操作 编写UserMapper映射文件 12345&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 编写删除数据的代码 1234567InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int delete = sqlSession.delete(&quot;userMapper.delete&quot;,3);System.out.println(delete);sqlSession.commit();sqlSession.close(); 删除操作注意问题 删除语句使用delete标签 Sql语句中使用#{任意字符串}方式引用传递的单个参数 删除操作使用的API是sqlSession.delete(“命名空间.id”,Object); 4.4 知识小结增删改查映射配置与API： 1234567891011121314151617增删改查映射配置与API：查询数据： List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;); &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from User &lt;/select&gt;添加数据： sqlSession.insert(&quot;userMapper.add&quot;, user); &lt;insert id=&quot;add&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt;修改数据： sqlSession.update(&quot;userMapper.update&quot;, user); &lt;update id=&quot;update&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125; &lt;/update&gt;删除数据：sqlSession.delete(&quot;userMapper.delete&quot;,3); &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; 5. MyBatis核心配置文件概述5.1 MyBatis核心配置文件层级关系 5.2 MyBatis常用配置解析 environments标签 数据库环境的配置，支持多环境配置 其中，事务管理器（transactionManager）类型有两种： JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如JEE 应用服务器的上下文）。默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将closeConnection属性设置为false 来阻止它默认的关闭行为。 其中，数据源（dataSource）类型有三种： UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED：这种数据源的实现利用“池”的概念将JDBC 连接对象组织起来。 JNDI：这个数据源的实现是为了能在如EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个JNDI 上下文的引用。 mapper标签 该标签的作用是加载映射的，加载方式有如下几种： 使用相对于类路径的资源引用，例如： &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt; 使用完全限定资源定位符（URL），例如： &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt; 使用映射器接口实现类的完全限定类名，例如： &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt; 将包内的映射器接口实现全部注册为映射器，例如： &lt;package name=&quot;org.mybatis.builder&quot;/&gt; Properties标签 实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件 typeAliases标签 类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下 配置typeAliases（该标签要放在properties标签后面，约束有一定的顺序），为com.itheima.domain.User定义别名为user 上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名 别名 数据类型 string String long Long int Integer double Double boolean Boolean … … … … 5.3 知识小结核心配置文件常用配置： 1、properties标签：该标签可以加载外部的properties文件 &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt; 2、typeAliases标签：设置类型别名 &lt;typeAlias type=&quot;com.itheima.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt; 3、mappers标签：加载映射配置 &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;&gt;&lt;/mapper&gt; 4、environments标签：数据源环境配置标签 MyBatis相应API6.1 SqlSession工厂构建器SqlSessionFactoryBuilder常用API：SqlSessionFactorybuild(InputStreaminputStream) 通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象 1234String resource = &quot;org/mybatis/builder/mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream); 其中，Resources 工具类，这个类在org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个web URL 中加载资源文件。 6.2 SqlSession工厂对象SqlSessionFactorySqlSessionFactory有多个个方法创建SqlSession实例。常用的有如下两个： 方法 解释 openSession() 会默认开启一个事务，但事务不会自动提交，也就意味着需要手动提交该事务，更新操作数据才会持久化到数据库中 openSession(boolean autoCommit) 参数为是否自动提交，如果设置为true，那么不需要手动提交事务 6.3 SqlSession会话对象SqlSession实例在MyBatis中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。 执行语句的方法主要有： 12345&lt;T&gt; T selectOne(String statement, Object parameter) &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) int insert(String statement, Object parameter) int update(String statement, Object parameter) int delete(String statement, Object parameter) 操作事务的方法主要有： 12void commit()void rollback()","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"10_声明式事务控制","slug":"黑马程序员/SSM框架/10_声明式事务控制","date":"2021-07-28T02:35:39.000Z","updated":"2021-07-28T02:45:58.048Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/10_声明式事务控制/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/10_%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/","excerpt":"","text":"1. 编程式事务控制相关对象1.1 PlatformTransactionManagerPlatformTransactionManager 接口是spring 的事务管理器，它里面提供了我们常用的操作事务的方法。 方法 说明 TransactionStatus getTransaction(TransactionDefination defination) 获取事务的状态信息 void commit(TransactionStatus status) 提交事务 void rollback(TransactionStatus status) 回滚事务 注意： PlatformTransactionManager 是接口类型，不同的Dao 层技术则有不同的实现类，例如：Dao 层技术是jdbc 或mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager Dao 层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager 1.2 TransactionDefinitionTransactionDefinition 是事务的定义信息对象，里面有如下方法： 方法 说明 int getIsolationLevel() 获得事务的隔离级别 int getPropogationBehavior() 获得事务的传播行为 int getTimeout() 获得超时时间 boolean isReadOnly() 是否只读 事务隔离级别 设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。 ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED 读未提交 ISOLATION_READ_COMMITTED 不可重复读 ISOLATION_REPEATABLE_READ 可重复读 ISOLATION_SERIALIZABLE 串行化 隔离级别 脏读 不可重复读 幻读 读未提交 Yes Yes Yes 不可重复读 No Yes Yes 可重复读 No No Yes 串行化 No No No 事务传播行为 REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER：以非事务方式运行，如果当前存在事务，抛出异常 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED 类似的操作 超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置 是否只读：建议查询时设置为只读 1.3 TransactionStatusTransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。 方法 说明 boolean hasSavepoint() 是否存储回滚点 boolean isCompleted() 事务是否完成 boolean isNewTransaction() 是否是新事务 boolean isRollbackOnly() 事务是否回滚 1.4 知识要点编程式事务控制三大对象 PlatformTransactionManager TransactionDefinition TransactionStatus 2. 基于XML 的声明式事务控制2.1 什么是声明式事务控制Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在Spring 配置文件中声明式的处理事务来代替代码式的处理事务。 声明式事务处理的作用 事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便 注意：Spring 声明式事务控制底层就是AOP。 2.2 声明式事务控制的实现声明式事务控制明确事项： 谁是切点？ 谁是通知？ 配置切面？ ①引入tx命名空间 1234567891011121314&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; ②配置事务增强 1234567891011&lt;!--平台事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--事务增强配置--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; ③配置事务AOP 织入 12345&lt;!--事务的aop增强--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; ④测试事务控制转账业务代码 123456@Overridepublic void transfer(String outMan, String inMan, double money) &#123; accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money);&#125; 2.3 切点方法的事务参数的配置123456&lt;!--事务增强配置--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 其中，tx:method 代表切点方法的事务参数的配置，例如： &lt;tx:method name=&quot;transfer&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; timeout=&quot;-1&quot; read-only=&quot;false&quot;/&gt; name：切点方法名称 isolation:事务的隔离级别 propogation：事务的传播行为 timeout：超时时间 read-only：是否只读 2.4 知识要点声明式事务控制的配置要点 平台事务管理器配置 事务通知的配置 事务aop织入的配置 3. 基于注解的声明式事务控制3.1 使用注解配置声明式事务控制 编写AccoutDao 1234567891011@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements AccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public void out(String outMan, double money) &#123; jdbcTemplate.update(&quot;update account set money=money-? where name=?&quot;,money,outMan); &#125; public void in(String inMan, double money) &#123; jdbcTemplate.update(&quot;update account set money=money+? where name=?&quot;,money,inMan); &#125;&#125; 编写AccoutService 123456789101112@Service(&quot;accountService&quot;)@Transactional(isolation = Isolation.READ_COMMITTED)public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED) public void transfer(String outMan, String inMan, double money) &#123; accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money); &#125;&#125; 编写applicationContext.xml 配置文件 12345&lt;!—之前省略datsSource、jdbcTemplate、平台事务管理器的配置--&gt;&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;&lt;!--事务的注解驱动--&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 3.2 注解配置声明式事务控制解析①使用@Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同xml 配置方式，例如隔离级别、传播行为等。②注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。③使用在方法上，不同的方法可以采用不同的事务参数配置。④Xml配置文件中要开启事务的注解驱动&lt;tx:annotation-driven /&gt; 3.3 知识要点注解声明式事务控制的配置要点 平台事务管理器配置（xml方式） 事务通知的配置（@Transactional注解配置） 事务注解驱动的配置&lt;tx:annotation-driven/&gt;","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"09_AOP","slug":"黑马程序员/SSM框架/09_AOP","date":"2021-07-28T02:35:24.000Z","updated":"2021-07-28T02:45:40.909Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/09_AOP/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/09_AOP/","excerpt":"","text":"1. Spring 的AOP 简介1.1 什么是AOPAOP 为Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP 是OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 1.2 AOP 的作用及其优势 作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复代码，提高开发效率，并且便于维护 1.3 AOP 的底层实现实际上，AOP 的底层是通过Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 1.4 AOP 的动态代理技术常用的动态代理技术 JDK 代理: 基于接口的动态代理技术 cglib 代理：基于父类的动态代理技术 1.5 JDK 的动态代理①目标类接口 123public interface TargetInterface &#123; public void method();&#125; ②目标类 123456public class Target implements TargetInterface &#123; @Override public void method()&#123; System.out.println(&quot;Target running....&quot;); &#125;&#125; ③动态代理代码 12345678910111213Target target = new Target();//创建目标对象//创建代理对象TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;前置增强代码...&quot;); Object invoke = method.invoke(target, args); System.out.println(&quot;后置增强代码...&quot;); return invoke; &#125;&#125;); ④调用代理对象的方法测试 12// 测试,当调用接口的任何方法时，代理对象的代码都无序修改proxy.method(); 1.6 cglib 的动态代理①目标类 12345public class Target &#123; public void method() &#123; System.out.println(&quot;Target running....&quot;); &#125;&#125; ②动态代理代码 12345678910111213Target target = new Target();//创建目标对象Enhancer enhancer = new Enhancer();//创建增强器enhancer.setSuperclass(Target.class);//设置父类enhancer.setCallback(new MethodInterceptor() &#123; //设置回调 @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;前置代码增强....&quot;); Object invoke = method.invoke(target, objects); System.out.println(&quot;后置代码增强....&quot;); return invoke; &#125;&#125;);Target proxy = (Target) enhancer.create();//创建代理对象 ③调用代理对象的方法测试 12//测试,当调用接口的任何方法时，代理对象的代码都无序修改proxy.method(); ![2021_2 (1)](09_AOP/2021_2 (1).png) 1.7 AOP 相关概念Spring 的AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。 在正式讲解AOP 的操作之前，我们必须理解AOP 的相关术语，常用的术语如下： Target（目标对象）：代理的目标对象 Proxy （代理）：一个类被AOP 织入增强后，就产生一个结果代理类 Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点 Pointcut（切入点）：所谓切入点是指我们要对哪些Joinpoint进行拦截的定义 Advice（通知/ 增强）：所谓通知是指拦截到Joinpoint之后所要做的事情就是通知 Aspect（切面）：是切入点和通知（引介）的结合 Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入 1.8 AOP 开发明确的事项 需要编写的内容 编写核心业务代码（目标类的目标方法） 编写切面类，切面类中有通知(增强功能方法) 在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合 AOP 技术实现的内容 Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 AOP 底层使用哪种代理方式 在spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 1.9 知识要点 aop：面向切面编程 aop底层实现：基于JDK的动态代理和基于Cglib的动态代理 aop的重点概念： Pointcut（切入点）：被增强的方法 Advice（通知/ 增强）：封装增强业务逻辑的方法 Aspect（切面）：切点+通知 Weaving（织入）：将切点与通知结合的过程 开发明确事项： 谁是切点（切点表达式配置） 谁是通知（切面类中的增强方法） 将切点和通知进行织入配置 2. 基于XML 的AOP 开发2.1 快速入门①导入AOP 相关坐标②创建目标接口和目标类（内部有切点）③创建切面类（内部有增强方法）④将目标类和切面类的对象创建权交给spring⑤在applicationContext.xml 中配置织入关系⑥测试代码 ①导入AOP 相关坐标 123456789101112&lt;!--导入spring的context坐标，context依赖aop--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj的织入--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt;&lt;/dependency&gt; ②创建目标接口和目标类（内部有切点） 123public interface TargetInterface &#123; public void method();&#125; 123456public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println(&quot;Target running....&quot;); &#125;&#125; ③创建切面类（内部有增强方法） 12345678910111213public class MyAspect &#123; //前置增强方法 public void before()&#123; System.out.println(&quot;前置代码增强.....&quot;); &#125; public Object around(ProceedingJoinPoint pjb) throws Throwable &#123; System.out.println(&quot;环绕前增强&quot;); Object proceed = pjb.proceed();//切点方法 System.out.println(&quot;环绕前增强&quot;); return proceed; &#125;&#125; ④将目标类和切面类的对象创建权交给spring 1234&lt;!--配置目标类--&gt;&lt;bean id=&quot;target&quot; class=&quot;com.itheima.aop.Target&quot;&gt;&lt;/bean&gt;&lt;!--配置切面类--&gt;&lt;bean id=&quot;myAspect&quot; class=&quot;com.itheima.aop.MyAspect&quot;&gt;&lt;/bean&gt; ⑤在applicationContext.xml 中配置织入关系 导入aop命名空间 1234567891011121314&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 配置切点表达式和前置增强的织入关系 12345678&lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!--配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt; &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(public void com.itheima.aop.Target.method())&quot;&gt;&lt;/aop:before&gt; &lt;aop:around method=&quot;around&quot; pointcut=&quot;execution(* com.itheima.aop.*.*(..))&quot;&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; ⑥测试代码 12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class AopTest&#123; @Autowired private TargetInterface target; @Test public void test1()&#123; target.method(); &#125;&#125; ⑦测试结果 2.2 XML 配置AOP 详解 切点表达式的写法 execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号*代表任意 包名与类名之间一个点. 代表当前包下的类，两个点.. 表示当前包及其子包下的类 参数列表可以使用两个点.. 表示任意个数，任意类型的参数列表 例如： 12345execution(public void com.itheima.aop.Target.method())execution(void com.itheima.aop.Target.*(..))execution(* com.itheima.aop.*.*(..))execution(* com.itheima.aop..*.*(..))execution(* *..*.*(..)) 通知的类型 通知的配置语法： &lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式&quot;&gt;&lt;/aop:通知类型&gt; 名称 标签 说明 前置通知 &lt;aop:before&gt; 用于配置前置通知。指定增强的方法在切入点方法之前执行 后置通知 &lt;aop:after returning&gt; 用于配置后置通知。指定增强的方法在切入点方法之后执行 环绕通知 &lt;aop:around&gt; 用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行 异常抛出通知 &lt;aop:throwing&gt; 用于配置异常抛出通知。指定增强的方法在出现异常时执行 最终通知 &lt;aop:after&gt; 用于配置最终通知。无论增强方式执行是否有异常都会执行 3. 切点表达式的抽取当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用pointcut-ref 属性代替pointcut 属性来引用抽取后的切点表达式。 1234567&lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.itheima.aop.*.*(..))&quot;/&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 2.3 知识要点 aop织入的配置12345&lt;aop:config&gt; &lt;aop:aspec tref=“切面类”&gt; &lt;aop:before method=“通知方法名称” pointcut=“切点表达式&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 通知的类型：前置通知、后置通知、环绕通知、异常抛出通知、最终通知 切点表达式的写法：execution([修饰符] 返回值类型包名.类名.方法名(参数)) 3. 基于注解的AOP 开发3.1 快速入门基于注解的aop开发步骤： ①创建目标接口和目标类（内部有切点）②创建切面类（内部有增强方法）③将目标类和切面类的对象创建权交给spring④在切面类中使用注解配置织入关系⑤在配置文件中开启组件扫描和AOP 的自动代理⑥测试 ①创建目标接口和目标类（内部有切点） 123public interface TargetInterface &#123; public void method();&#125; 123456public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println(&quot;Target running....&quot;); &#125;&#125; ②创建切面类（内部有增强方法） 123456public class MyAspect &#123; //前置增强方法 public void before()&#123; System.out.println(&quot;前置代码增强.....&quot;); &#125;&#125; ③将目标类和切面类的对象创建权交给spring 1234567891011121314@Component(&quot;target&quot;)public class Target implements TargetInterface&#123; @Override public void method() &#123; System.out.println(&quot;Target running....&quot;); &#125;&#125;@Component(&quot;myAspect&quot;)public class MyAspect&#123; public void before()&#123; System.out.println(&quot;前置代码增强.....&quot;); &#125;&#125; ④在切面类中使用注解配置织入关系 12345678@Component(&quot;myAspect&quot;)@Aspectpublic class MyAspect &#123; @Before(&quot;execution(* com.itheima.aop.*.*(..))&quot;) public void before()&#123; System.out.println(&quot;前置代码增强.....&quot;); &#125;&#125; ⑤在配置文件中开启组件扫描和AOP 的自动代理 12345&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.itheima.aop&quot;/&gt;&lt;!--aop的自动代理--&gt;&lt;aop:aspectj-autoproxy/&gt; ⑥测试代码 12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class AopTest&#123; @Autowired private TargetInterface target; @Test public void test1()&#123; target.method(); &#125;&#125; ⑦测试结果 3.2 注解配置AOP 详解 注解通知的类型 通知的配置语法：@通知注解(“切点表达式”) 名称 标签 说明 前置通知 @Before 用于配置前置通知。指定增强的方法在切入点方法之前执行 后置通知 @AfterReturning 用于配置后置通知。指定增强的方法在切入点方法之后执行 环绕通知 @Around 用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行 异常抛出通知 @AfterThrowing 用于配置异常抛出通知。指定增强的方法在出现异常时执行 最终通知 @After 用于配置最终通知。无论增强方式执行是否有异常都会执行 切点表达式的抽取 同xml 配置aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下： 1234567891011@Component(&quot;myAspect&quot;)@Aspect//标注当前MyAspect是一个切面类public class MyAspect&#123; @Before(&quot;MyAspect.myPoint()&quot;) public void before()&#123; System.out.println(&quot;前置代码增强.....&quot;); &#125; @Pointcut(&quot;execution(* com.itheima.aop.*.*(..))&quot;) public void myPoint()&#123; &#125;&#125; 注解 aop 开发步骤①使用 @Aspect 标注切面类②使用 通知注解标注通知方法③在配置文件中配置 aop 自动代理 aop :aspectj autoproxy 通知注解类型 名称 标签 说明 前置通知 @Before 用于配置前置通知。指定增强的方法在切入点方法之前执行 后置通知 @AfterReturning 用于配置后置通知。指定增强的方法在切入点方法之后执行 环绕通知 @Around 用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行 异常抛出通知 @AfterThrowing 用于配置异常抛出通知。指定增强的方法在出现异常时执行 最终通知 @After 用于配置最终通知。无论增强方式执行是否有异常都会执行","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"08_异常处理机制","slug":"黑马程序员/SSM框架/08_异常处理机制","date":"2021-07-28T02:35:02.000Z","updated":"2021-07-28T02:45:14.045Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/08_异常处理机制/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/08_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/","excerpt":"","text":"1. SpringMVC异常处理1.1 异常处理的思路系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。 系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理，如下图： 1.2 异常处理两种方式 使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver 实现Spring的异常处理接口HandlerExceptionResolver自定义自己的异常处理器 1.3 简单异常处理器SimpleMappingExceptionResolverSpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置 12345678910&lt;!--配置简单映射异常处理器--&gt;&lt;bean class=“org.springframework.web.servlet.handler.SimpleMappingExceptionResolver”&gt; &lt;property name=“defaultErrorView” value=“error”/&gt; 默认错误视图 &lt;property name=“exceptionMappings”&gt; &lt;map&gt; 异常类型 错误视图 &lt;entry key=&quot;com.itheima.exception.MyException&quot; value=&quot;error1&quot;/&gt; &lt;entry key=&quot;java.lang.ClassCastException&quot; value=&quot;error2&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 1.4 自定义异常处理步骤①创建异常处理器类实现HandlerExceptionResolver②配置异常处理器③编写异常页面④测试异常跳转 ①创建异常处理器类实现HandlerExceptionResolver 123456789101112131415public class MyExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; //处理异常的代码实现 //创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); if(e instanceof MyException)&#123; modelAndView.addObject(&quot;info&quot;,&quot;自定义异常&quot;); &#125; else if(e instanceof ClassCastException)&#123; modelAndView.addObject(&quot;info&quot;,&quot;类型转换异常&quot;); &#125; modelAndView.setViewName(&quot;error&quot;); return modelAndView; &#125;&#125; ②配置异常处理器 1&lt;bean id=&quot;exceptionResolver&quot; class=&quot;com.itheima.exception.MyExceptionResolver&quot;/&gt; ③编写异常页面 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;$&#123;info&#125;&lt;/h1&gt; 这是一个最终异常的显示页面&lt;/body&gt;&lt;/html&gt; ④测试异常跳转 123456@RequestMapping(&quot;/quick22&quot;)@ResponseBodypublic void quickMethod22() throws IOException, ParseException &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); simpleDateFormat.parse(&quot;abcde&quot;);&#125; 1.5 知识要点异常处理方式 配置简单异常处理器SimpleMappingExceptionResolver 自定义异常处理器 自定义异常处理步骤 ①创建异常处理器类实现HandlerExceptionResolver②配置异常处理器③编写异常页面④测试异常跳转","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"07_SpringMVC拦截器","slug":"黑马程序员/SSM框架/07_SpringMVC拦截器","date":"2021-07-28T02:34:36.000Z","updated":"2021-07-28T02:44:44.803Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/07_SpringMVC拦截器/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/07_SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"","text":"1.SpringMVC 拦截器1.1 拦截器（interceptor）的作用Spring MVC 的拦截器类似于Servlet 开发中的过滤器Filter，用于对处理器进行预处理和后处理。 将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（Interceptor Chain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。 1.2 拦截器和过滤器区别 区别 过滤器 拦截器 使用范围 是servlet 规范中的一部分，任何Java Web 工程都可以使用 是SpringMVC 框架自己的，只有使用了SpringMVC 框架的工程才能用 拦截范围 在url pattern 中配置了/*之后，可以对所有要访问的资源拦截 只会拦截访问的控制器方法，如果访问的是jsp,html,css,image 或者 js 是不会进行拦截的 1.3 拦截器是快速入门自定义拦截器很简单，只有如下三步： ①创建拦截器类实现HandlerInterceptor接口②配置拦截器③测试拦截器的拦截效果 ①创建拦截器类实现HandlerInterceptor接口 12345678910111213141516171819public class MyHandlerInterceptor1 implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; System.out.println(&quot;preHandle running...&quot;); String param = request.getParameter(&quot;param&quot;); if(&quot;yes&quot;.equals(param))&#123; return true; &#125; esle &#123; request.getRequestDispatcher(&quot;/error.jsp&quot;).forward(request,response); reurn false; &#125; &#125; public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; modelAndView.addObject(&quot;name&quot;,&quot;itheima&quot;); System.out.println(&quot;postHandle running...&quot;); &#125; public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; System.out.println(&quot;afterCompletion running...&quot;); &#125;&#125; ②配置拦截器 1234567891011&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyHandlerInterceptor1&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyHandlerInterceptor2&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 12345678&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/user/login&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyHandlerInterceptor1&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ③测试拦截器的拦截效果（编写目标方法） 123456789@RequestMapping(&quot;/quick23&quot;)@ResponseBodypublic ModelAndViewquickMethod23() throws IOException, ParseException&#123; System.out.println(&quot;目标方法执行....&quot;); ModelAndView modelAndView= new ModelAndView(); modelAndView.addObject(&quot;name&quot;,&quot;itcast&quot;); modelAndView.setViewName(&quot;index&quot;); return modelAndView;&#125; http://localhost:8080/itheima_springmvc1/quick23 控制台打印结果 1.4 多拦截器操作同上，在编写一个MyHandlerInterceptor2操作，测试执行顺序 1.5 拦截器方法说明 方法名 说明 preHandle() 方法将在请求处理之前进行调用，该方法的返回值是布尔值Boolean 类型的，当它返回为 false 时，表示请求结束，后续的 Interceptor 和 Controller 都不会再执行；当返回值为 true 时就会继续调用下一个 Interceptor 的 preHandle 方法 postHandle() 该方法是在当前请求进行处理之后被调用，前提是preHandle 方法的返回值为true 时才能被调用，且它会在 DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对 Controller 处理之后的 ModelAndView 对象进行操作 afterCompletion() 该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行，前提是 preHandle 方法的返回值为 true 时才能被调用 1.6 知识要点自定义拦截器步骤 ①创建拦截器类实现HandlerInterceptor接口②配置拦截器③测试拦截器的拦截效果 1.7 案例-用户登录权限控制需求：用户没有登录的情况下，不能对后台菜单进行访问操作，点击菜单跳转到登录页面，只有用户登录成功后才能进行后台功能的操作","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"06_练习","slug":"黑马程序员/SSM框架/06_练习","date":"2021-07-28T02:34:21.000Z","updated":"2021-07-28T02:44:24.244Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/06_练习/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/06_%E7%BB%83%E4%B9%A0/","excerpt":"","text":"1. Spring练习环境搭建1.1 Spring环境搭建步骤①创建工程（Project&amp;Module）②导入静态页面（见资料jsp页面）③导入需要坐标（见资料中的pom.xml）④创建包结构（controller、service、dao、domain、utils）⑤导入数据库脚本（见资料test.sql）⑥创建POJO类（见资料User.java和Role.java）⑦创建配置文件（applicationContext.xml、spring-mvc.xml、jdbc.properties、log4j.properties） 1.2 用户和角色的关系 2.角色列表的展示和添加操作2.1 角色列表的展示效果 2.2 角色列表的展示步骤分析①点击角色管理菜单发送请求到服务器端（修改角色管理菜单的url地址）②创建RoleController和showList()方法③创建RoleService和showList()方法④创建RoleDao和findAll()方法⑤使用JdbcTemplate完成查询操作⑥将查询数据存储到Model中⑦转发到role-list.jsp页面进行展示 2.3 角色添加的效果 2.4 角色添加的步骤分析①点击列表页面新建按钮跳转到角色添加页面②输入角色信息，点击保存按钮，表单数据提交服务器③编写RoleController的save()方法④编写RoleService的save()方法⑤编写RoleDao的save()方法⑥使用JdbcTemplate保存Role数据到sys_role⑦跳转回角色列表页面 3.用户列表的展示和添加操作3.1 用户列表的展示效果 3.2 用户列表的展示步骤分析①点击用户管理菜单发送请求到服务器端（修改用户管理菜单的url地址）②创建RoleController和showList()方法③创建RoleService和showList()方法④创建RoleDao和findAll()方法⑤使用JdbcTemplate完成查询操作⑥将查询数据存储到Model中⑦转发到user-list.jsp页面进行展示 3.3 用户添加的效果 3.4 用户添加的步骤分析①点击列表页面新建按钮跳转到角色添加页面②输入角色信息，点击保存按钮，表单数据提交服务器③编写RoleController的save()方法④编写RoleService的save()方法⑤编写RoleDao的save()方法⑥使用JdbcTemplate保存Role数据到sys_role⑦跳转回角色列表页面 4. 删除用户操作4.1 删除用户的效果 4.2 删除用户的步骤分析①点击用户列表的删除按钮，发送请求到服务器端②编写UserController的deleteById()方法③编写UserService的deleteById()方法④编写UserDao的deleteById()方法⑤编写UserDao的deleteRelByUid()方法⑥跳回当前用户列表页面","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"05_JDBC模板","slug":"黑马程序员/SSM框架/05_JDBC模板","date":"2021-07-28T02:34:00.000Z","updated":"2021-07-28T02:43:54.800Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/05_JDBC模板/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/05_JDBC%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"1. Spring JdbcTemplate基本使用1.1 JdbcTemplate概述它是spring框架中提供的一个对象，是对原始繁琐的JdbcAPI对象的简单封装。spring框架为我们提供了很多的操作模板类。例如：操作关系型数据的JdbcTemplate和HibernateTemplate，操作nosql数据库的RedisTemplate，操作消息队列的JmsTemplate等等。 1.2 JdbcTemplate开发步骤①导入spring-jdbc和spring-tx坐标②创建数据库表和实体③创建JdbcTemplate对象④执行数据库操作 1.3 JdbcTemplate快速入门①导入坐标 12345678910111213&lt;!--springcontext依赖 c3p0 commosio mysql-connector-java等也需要自己导入，具体参考案例--&gt;&lt;!--导入spring的jdbc坐标--&gt;&lt;dependency &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--导入spring的tx坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; ②创建accout表和Accout实体 12345public class Account &#123; private String name; private double money; //省略get和set方法&#125; ③创建JdbcTemplate对象④执行数据库操作 123456789101112//1、创建数据源对象ComboPooledDataSource dataSource= new ComboPooledDataSource();dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);dataSource.setUser(&quot;root&quot;);dataSource.setPassword(&quot;root&quot;);//2、创建JdbcTemplate对象JJdbcTemplate jdbcTemplate= new JdbcTemplate();//3、设置数据源给JdbcTemplatejdbcTemplate.setDataSource(dataSource);//4、执行操作jdbcTemplate.update(&quot;insert into account values(?,?)&quot;,&quot;tom&quot;,5000); 1.4 Spring产生JdbcTemplate对象我们可以将JdbcTemplate的创建权交给Spring，将数据源DataSource的创建权也交给Spring，在Spring容器内部将数据源DataSource注入到JdbcTemplate模版对象中，配置如下： 1234567891011&lt;!--数据源DataSource--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///test&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--JdbcTemplate--&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 从容器中获得JdbcTemplate进行添加操作 123456@Testpublic void testSpringJdbcTemplate() throws PropertyVetoException&#123; ApplicationContext applicationContext= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); JdbcTemplate jdbcTemplate= applicationContext.getBean(JdbcTemplate.class); jdbcTemplate.update(&quot;insert into account values(?,?)&quot;,&quot;lucy&quot;,5000);&#125; 数据库配置一般与spirng的xml文件分开，使用jdbc.properties文件存储 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=root 修改xml文件（熟记） 1234567891011121314151617&lt;!--添加命名空间--&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd &lt;!--加载jdbc.properties--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--数据源对象--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!--JdbcTemplate--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 1.5 JdbcTemplate的常用操作修改操作 123456789101112//需要导入相关依赖@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class JdbcTemplateCRUDTest&#123; @Autowired private JdbcTemplate jdbcTemplate; @Test //测试修改操作 public void testUpdate()&#123; jdbcTemplate.update(&quot;update account set money=? where name=?&quot;,1000,&quot;tom&quot;); &#125;&#125; 删除和查询全部操作 1234567891011@Testpublic void testDelete()&#123; jdbcTemplate.update(&quot;delete from account where name=?&quot;,&quot;tom&quot;);&#125;@Testpublic void testQueryAll()&#123; List&lt;Account&gt; accounts = jdbcTemplate.query(&quot;select *from account&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); for (Account account: accounts) &#123; System.out.println(account.getName()); &#125;&#125; 查询单个数据操作操作 1234567891011121314@Test//测试查询单个对象操作public void testQueryOne()&#123; Account account= jdbcTemplate.queryForObject(&quot;select *from account where name=?&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class), &quot;tom&quot;); System.out.println(account.getName());&#125;@Test//测试查询单个简单数据操作(聚合查询)public void testQueryCount()&#123; Long aLong= jdbcTemplate.queryForObject(&quot;select count(*) from account&quot;, Long.class); System.out.println(aLong);&#125; 1.6 知识要点①导入spring-jdbc和spring-tx坐标②创建数据库表和实体③创建JdbcTemplate对象 12JdbcTemplatejdbcTemplate= new JdbcTemplate();jdbcTemplate.setDataSource(dataSource); ④执行数据库操作 更新操作：jdbcTemplate.update(sql,params) 查询操作： 12jdbcTemplate.query(sql,Mapper,params)jdbcTemplate.queryForObject(sql,Mapper,params)","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"04_SpringMVC的请求和响应","slug":"黑马程序员/SSM框架/04_SpringMVC的请求和响应","date":"2021-07-28T02:07:21.000Z","updated":"2021-07-28T02:43:27.212Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/04_SpringMVC的请求和响应/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/04_SpringMVC%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/","excerpt":"","text":"1. SpringMVC的数据响应1.1 SpringMVC的数据 响应方式1）页面跳转 直接返回字符串 通过ModelAndView对象返回 2）回写数据 直接返回字符串 返回对象或集合 1.2 页面跳转1. 返回字符串形式直接返回字符串：此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转。 返回带有前缀的字符串： 转发：forward:/WEB-INF/views/index.jsp 重定向：redirect:/index.jsp 2. 返回ModelAndView对象123456789101112@RequestMapping(&quot;/quick2&quot;)public ModelAndView quickMethod2()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(&quot;redirect:index.jsp&quot;); return modelAndView;&#125;@RequestMapping(&quot;/quick3&quot;)public ModelAndView quickMethod3()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(&quot;forward:/WEB-INF/views/index.jsp&quot;); return modelAndView;&#125; 3. 向request域存储数据在进行转发时，往往要向request域中存储数据，在jsp页面中显示，那么Controller中怎样向request域中存储数据呢？ ①通过SpringMVC框架注入的request对象setAttribute()方法设置 12345@RequestMapping(&quot;/quick&quot;)public String quickMethod(HttpServletRequest request)&#123; request.setAttribute(&quot;name&quot;,&quot;zhangsan&quot;); return &quot;index&quot;;&#125; ②通过ModelAndView的addObject()方法设置 1234567@RequestMapping(&quot;/quick3&quot;)public ModelAndView quickMethod3()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(&quot;forward:/WEB-INF/views/index.jsp&quot;); modelAndView.addObject(&quot;name&quot;,&quot;lisi&quot;); return modelAndView;&#125; 1.3 回写数据1. 直接返回字符串Web基础阶段，客户端访问服务器端，如果想直接回写字符串作为响应体返回的话，只需要使用response.getWriter().print(&quot;hello world&quot;) 即可，那么在Controller中想直接回写字符串该怎样呢？ ①通过SpringMVC框架注入的response对象，使用response.getWriter().print(&quot;hello world&quot;) 回写数据，此时不需要视图跳转，业务方法返回值为void。 1234@RequestMapping(&quot;/quick4&quot;)public void quickMethod4(HttpServletResponse response) throws IOException &#123; response.getWriter().print(&quot;hello world&quot;);&#125; ②将需要回写的字符串直接返回，但此时需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回。 12345@RequestMapping(&quot;/quick5&quot;)@ResponseBodypublic String quickMethod5() throws IOException &#123; return &quot;hello springMVC!!!&quot;;&#125; 在异步项目中，客户端与服务器端往往要进行json格式字符串交互，此时我们可以手动拼接json字符串返回。 12345@RequestMapping(&quot;/quick6&quot;)@ResponseBodypublic String quickMethod6() throws IOException &#123; return &quot;&#123;\\&quot;name\\&quot;:\\&quot;zhangsan\\&quot;,\\&quot;age\\&quot;:18&#125;&quot;;&#125; 上述方式手动拼接json格式字符串的方式很麻烦，开发中往往要将复杂的java对象转换成json格式的字符串，我们可以使用web阶段学习过的json转换工具jackson进行转换，导入jackson坐标。 12345678910111213141516&lt;!--jackson--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 通过jackson转换json格式字符串，回写字符串。 12345678910@RequestMapping(&quot;/quick7&quot;)@ResponseBodypublic String quickMethod7() throws IOException&#123; User user= new User(); user.setUsername(&quot;zhangsan&quot;); user.setAge(18); ObjectMapper objectMapper= new ObjectMapper(); String s = objectMapper.writeValueAsString(user); return s;&#125; 2. 返回对象或集合通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc.xml中进行如下配置： 12345678910&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation .RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.http.converter.json .MappingJackson2HttpMessageConverter&quot;&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 12345678@RequestMapping(&quot;/quick8&quot;)@ResponseBodypublic User quickMethod8() throws IOException &#123; User user = new User(); user.setUsername(&quot;zhangsan&quot;); user.setAge(18); return user;&#125; 在方法上添加@ResponseBody就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置。 12&lt;!--mvc的注解驱动--&gt;&lt;mvc:annotation-driven/&gt; 在SpringMVC的各个组件中，处理器映射器、处理器适配器、视图解析器称为SpringMVC的三大组件。使用&lt;mvc:annotation-driven&gt;自动加载RequestMappingHandlerMapping（处理映射器）和RequestMappingHandlerAdapter（处理适配器），可用在Spring-xml.xml配置文件中使用&lt;mvc:annotation-driven&gt;替代注解处理器和适配器的配置。同时使用&lt;mvc:annotation-driven&gt;默认底层就会集成jackson进行对象或集合的json格式字符串的转换。 2. SpringMVC获得请求数据2.1 获得请求参数客户端请求参数的格式是：name=value&amp;name=value… … 服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数： 基本类型参数 POJO类型参数 数组类型参数 集合类型参数 2.2 获得基本类型参数Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。 http://localhost:8080/itheima_springmvc1/quick9?username=zhangsan&amp;age=12 123456@RequestMapping(&quot;/quick9&quot;)@ResponseBodypublic void quickMethod9(String username,int age) throws IOException &#123; System.out.println(username); System.out.println(age);&#125; 2.3 获得POJO类型参数Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。 http://localhost:8080/itheima_springmvc1/quick9?username=zhangsan&amp;age=12 1234567891011public class User &#123; private String username; private int age; getter/setter…&#125;@RequestMapping(&quot;/quick10&quot;)@ResponseBodypublic void quickMethod10(User user) throws IOException &#123; System.out.println(user);&#125; 2.4 获得数组类型参数Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。 http://localhost:8080/itheima_springmvc1/quick11?strs=111&amp;strs=222&amp;strs=333 12345@RequestMapping(&quot;/quick11&quot;)@ResponseBodypublic void quickMethod11(String[] strs) throws IOException &#123; System.out.println(Arrays.asList(strs));&#125; 2.5 获得集合类型参数获得集合参数时，要将集合参数包装到一个POJO中才可以。 1234567&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/quick12&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;userList[0].username&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;userList[0].age&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;userList[1].username&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;userList[1].age&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt;&lt;/form&gt; 12345@RequestMapping(&quot;/quick12&quot;)@ResponseBodypublic void quickMethod12(Vo vo) throws IOException &#123; System.out.println(vo.getUserList());&#125; 12345678910111213141516public class VO &#123; private List&lt;User&gt; userList; public List&lt;User&gt; getUserList() &#123; return userList; &#125; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125; @Override public String toString() &#123; return &quot;VO&#123;&quot; + &quot;userList=&quot; + userList + &#x27;&#125;&#x27;; &#125;&#125; 当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装。 123456789101112&lt;script&gt; //模拟数据 var userList = new Array(); userList.push(&#123;username: &quot;zhangsan&quot;,age: &quot;20&quot;&#125;); userList.push(&#123;username: &quot;lisi&quot;,age: &quot;20&quot;&#125;); $.ajax(&#123; type: &quot;POST&quot;, url: &quot;/itheima_springmvc1/quick13&quot;, data: JSON.stringify(userList), contentType : &#x27;application/json;charset=utf-8&#x27; &#125;);&lt;/script&gt; 当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装。 12345@RequestMapping(&quot;/quick13&quot;)@ResponseBodypublic void quickMethod13(@RequestBody List&lt;User&gt; userList) throws IOException &#123; System.out.println(userList);&#125; 注意：通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是/,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源： 在spring-mvc.xml配置文件中指定放行的资源&lt;mvc:resources mapping=”/js/**” location=”/js/“/&gt; 使用&lt;mvc:default-servlet-handler/&gt; 标签 2.6 请求数据乱码问题当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。 123456789101112&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2.7 参数绑定注解@requestParam当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定。 1234&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/quick14&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 12345@RequestMapping(&quot;/quick14&quot;)@ResponseBodypublic void quickMethod14(@RequestParam(&quot;name&quot;) String username) throws IOException &#123; System.out.println(username);&#125; 注解@RequestParam还有如下参数可以使用： value：与请求参数名称 required：此在指定的请求参数是否必须包括，默认是true，提交时如果没有此参数则报错 defaultValue：当没有指定请求参数时，则使用指定的默认值赋值 12345@RequestMapping(&quot;/quick14&quot;)@ResponseBodypublic void quickMethod14(@RequestParam(value=&quot;name&quot;,required = false,defaultValue = &quot;itcast&quot;) String username) throws IOException &#123; System.out.println(username);&#125; 2.8 获得Restful风格的参数Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。 Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下： GET：用于获取资源 POST：用于新建资源 PUT：用于更新资源 DELETE：用于删除资源 例如： /user/1 GET ：得到id = 1 的user /user/1 DELETE：删除id = 1 的user /user/1 PUT：更新id = 1 的user /user POST：新增user 2.8 获得Restful风格的参数上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符&#123;id&#125; 对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。 http://localhost:8080/itheima_springmvc1/quick19/zhangsan 12345@RequestMapping(&quot;/quick19/&#123;name&#125;&quot;)@ResponseBodypublic void quickMethod19(@PathVariable(value = &quot;name&quot;,required = true) String name)&#123; System.out.println(name);&#125; 2.9 自定义类型转换器 SpringMVC默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。 但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。 自定义类型转换器的开发步骤：①定义转换器类实现Converter接口②在配置文件中声明转换器③在中引用转换器 ①定义转换器类实现Converter接口 12345678910111213public class DateConverter implements Converter&lt;String,Date&gt;&#123; @Override public Date convert(String source) &#123; SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); try &#123; Date date = format.parse(source); return date; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; ②在配置文件中声明转换器 1234567&lt;bean id=&quot;converterService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;com.itheima.converter.DateConverter&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; ③在中引用转换器 &lt;mvc:annotation-driven conversion-service=&quot;converterService&quot;/&gt; 2.10 获得Servlet相关APISpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下： HttpServletRequest HttpServletResponse HttpSession 1234567@RequestMapping(&quot;/quick16&quot;)@ResponseBodypublic void quickMethod16(HttpServletRequest request,HttpServletResponse response,HttpSession session)&#123; System.out.println(request); System.out.println(response); System.out.println(session);&#125; 2.11 获得请求头1. @RequestHeader使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name) @RequestHeader注解的属性如下： value：请求头的名称 required：是否必须携带此请求头 12345@RequestMapping(&quot;/quick17&quot;)@ResponseBodypublic void quickMethod17(@RequestHeader(value = &quot;User-Agent&quot;,required = false) String headerValue)&#123; System.out.println(headerValue);&#125; 2. @CookieValue使用@CookieValue可以获得指定Cookie的值 @CookieValue注解的属性如下： value：指定cookie的名称 required：是否必须携带此cookie 12345@RequestMapping(&quot;/quick18&quot;)@ResponseBodypublic void quickMethod18(@CookieValue(value = &quot;JSESSIONID&quot;,required = false) String jsessionid)&#123; System.out.println(jsessionid);&#125; 2.12 文件上传1. 文件上传客户端三要素 表单项type=“file” 表单的提交方式是post 表单的enctype属性是多部分表单形式，及enctype=“multipart/form-data” 12345&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/quick20&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 名称：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 文件：&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt;&lt;/form&gt; 2. 文件上传原理 当form表单修改为多部分表单时，request.getParameter()将失效。 enctype=“application/x-www-form-urlencoded”时，form表单的正文内容格式是：key=value&amp;key=value&amp;key=value 当form表单的enctype取值为Mutilpart/form-data时，请求正文内容就变成多部分形式： 2.13 单文件上传步骤①导入fileupload和io坐标②配置文件上传解析器③编写文件上传代码 2.14 单文件上传实现①导入 fileupload 和 io 坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; ②配置文件上传解析器 123456789&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!--上传文件总大小--&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242800&quot;/&gt; &lt;!--上传单个文件的大小--&gt; &lt;property name=&quot;maxUploadSizePerFile&quot; value=&quot;5242800&quot;/&gt; &lt;!--上传文件的编码类型--&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;&lt;/bean&gt; ③编写文件上传代码 12345678@RequestMapping(&quot;/quick20&quot;)@ResponseBodypublic void quickMethod20(String name,MultipartFile uploadFile) throws IOException &#123; //获得文件名称 String originalFilename = uploadFile.getOriginalFilename(); //保存文件 uploadFile.transferTo(new File(&quot;C:\\\\upload\\\\&quot;+originalFilename));&#125; 2.15 多文件上传实现多文件上传，只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型修改为MultipartFile[]即可 123456789&lt;h1&gt;多文件上传测试&lt;/h1&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/quick21&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 名称：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 文件1：&lt;input type=&quot;file&quot; name=&quot;uploadFiles&quot;&gt;&lt;br&gt; 文件2：&lt;input type=&quot;file&quot; name=&quot;uploadFiles&quot;&gt;&lt;br&gt; 文件3：&lt;input type=&quot;file&quot; name=&quot;uploadFiles&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt;&lt;/form&gt; 12345678@RequestMapping(&quot;/quick21&quot;)@ResponseBodypublic void quickMethod21(String name,MultipartFile[] uploadFiles) throws IOException &#123; for (MultipartFile uploadFile : uploadFiles)&#123; String originalFilename = uploadFile.getOriginalFilename(); uploadFile.transferTo(new File(&quot;C:\\\\upload\\\\&quot;+originalFilename)); &#125;&#125;","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"03_MVC入门","slug":"黑马程序员/SSM框架/03_MVC入门","date":"2021-07-28T02:07:00.000Z","updated":"2021-07-28T02:43:09.791Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/03_MVC入门/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/03_MVC%E5%85%A5%E9%97%A8/","excerpt":"","text":"1. Spring集成web环境1.1 ApplicationContext应用上下文获取方式应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件) 方式获取的，但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件)，这样的弊端是配置文件加载多次，应用上下文对象创建多次。 在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。 1.2 Spring提供获取应用上下文的工具上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。 所以我们需要做的只有两件事： ①在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标）②使用WebApplicationContextUtils获得应用上下文对象ApplicationContext 1.3 导入Spring集成web的坐标12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 1.4 配置ContextLoaderListener监听器123456789101112&lt;!--web.xml中--&gt;&lt;!--全局参数--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--Spring的监听器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt; 1.5 通过工具获得应用上下文对象123ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(servletContext);Object obj = applicationContext.getBean(&quot;id&quot;); Spring集成web环境步骤 ①配置ContextLoaderListener监听器②使用WebApplicationContextUtils获得应用上下文 2. SpringMVC简介2.1 SpringMVC概述SpringMVC是一种基于Java 的实现MVC 设计模型的请求驱动类型的轻量级Web 框架，属于SpringFrameWork的后续产品，已经融合在Spring Web Flow 中。 SpringMVC已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越Struts2，成为最优秀的MVC 框架。它通过一套注解，让一个简单的Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful编程风格的请求。 2.2 SpringMVC快速入门需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。 开发步骤： ①导入SpringMVC相关坐标②配置SpringMVC核心控制器DispathcerServlet③创建Controller类和视图页面④使用注解配置Controller类中业务方法的映射地址⑤配置SpringMVC核心文件spring-mvc.xml⑥客户端发起请求测试 ①导入Spring和SpringMVC的坐标 123456789101112&lt;!--Spring坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--SpringMVC坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; ①导入Servlet和Jsp的坐标 123456789101112&lt;!--Servlet坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--Jsp坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId &gt;&lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; ②在web.xml配置SpringMVC的核心控制器 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ③创建Controller和业务方法 123456public class QuickController &#123; public String quickMethod()&#123; System.out.println(&quot;quickMethod running.....&quot;); return &quot;index&quot;; &#125;&#125; ③创建视图页面index.jsp 12345&lt;html&gt; &lt;body&gt; &lt;h2&gt;Hello SpringMVC!&lt;/h2&gt; &lt;/body&gt;&lt;/html&gt; ④配置注解 12345678@Controllerpublic class QuickController &#123;@RequestMapping(&quot;/quick&quot;) public String quickMethod()&#123; System.out.println(&quot;quickMethod running.....&quot;); return &quot;index&quot;; &#125;&#125; ⑤创建spring-mvc.xml 12345678910111213&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--配置注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;&lt;/beans&gt; ⑥访问测试地址 ![3bf85dedf23dc49ba1d0f13506927621.png](en-resource://database/1983:2) http://localhost:8080/itheima_springmvc1/quick 控制台打印 页面显示 2.3 SpringMVC流程图示 2.4 知识要点SpringMVC的开发步骤 ①导入SpringMVC相关坐标②配置SpringMVC核心控制器DispathcerServlet③创建Controller类和视图页面④使用注解配置Controller类中业务方法的映射地址⑤配置SpringMVC核心文件spring-mvc.xml⑥客户端发起请求测试 3. SpringMVC组件解析3.1 SpringMVC的执行流程 ①用户发送请求至前端控制器DispatcherServlet。②DispatcherServlet收到请求调用HandlerMapping处理器映射器。③处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。④DispatcherServlet调用HandlerAdapter处理器适配器。⑤HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。⑥Controller执行完成返回ModelAndView。⑦HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。⑧DispatcherServlet将ModelAndView传给ViewReslover视图解析器。⑨ViewReslover解析后返回具体View。⑩DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户。 3.2 SpringMVC组件解析 前端控制器：DispatcherServlet 用户请求到达前端控制器，它就相当于MVC 模式中的C，DispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性。 处理器映射器：HandlerMapping HandlerMapping负责根据用户请求找到Handler 即处理器，SpringMVC提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 处理器适配器：HandlerAdapter 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 处理器：Handler 它就是我们开发中要编写的具体业务控制器。由DispatcherServlet把用户请求转发到Handler。由Handler 对具体的用户请求进行处理。 视图解析器：View Resolver View Resolver 负责将处理结果生成View 视图，View Resolver 首先根据逻辑视图名解析成物理视名，即具体的页面地址，再生成View 视图对象，最后对View 进行渲染将处理结果通过页面展示给用户。 视图：View SpringMVC框架提供了很多的View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面 3.3 SpringMVC注解解析@RequestMapping 作用：用于建立请求URL 和处理请求方法之间的对应关系 位置： 类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录 方法上，请求URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径 属性： value：用于指定请求的URL。它和path属性的作用是一样的 method：用于指定请求的方式 params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样 例如： params= {“accountName”}，表示请求参数必须有accountName params= {“moeny!100”}，表示请求参数中money不能是100 mvc命名空间引入 命名空间：xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; 约束地址：http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd 组件扫描 SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用&lt;context:component-scanbase-package=“com.itheima.controller&quot;/&gt;进行组件扫描。 3.4 SpringMVC的XML配置解析 视图解析器 SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org/springframework/web/servlet/DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下： org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver 翻看该解析器源码，可以看到该解析器的默认设置，如下： 1234REDIRECT_URL_PREFIX = &quot;redirect:&quot; --重定向前缀FORWARD_URL_PREFIX = &quot;forward:&quot; --转发前缀（默认值）prefix = &quot;&quot;; --视图名称前缀suffix = &quot;&quot;; --视图名称后缀 我们可以通过属性注入的方式修改视图的的前后缀 123456&lt;!--配置内部资源视图解析器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 3.5 知识要点SpringMVC的相关组件 前端控制器：DispatcherServlet 处理器映射器：HandlerMapping 处理器适配器：HandlerAdapter 处理器：Handler 视图解析器：View Resolver 视图：View SpringMVC的注解和配置 请求映射注解：@RequestMapping 视图解析器配置： 1234REDIRECT_URL_PREFIX = &quot;redirect:&quot; FORWARD_URL_PREFIX = &quot;forward:&quot; prefix = &quot;&quot;; suffix = &quot;&quot;;","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"02_IoC和DI注解开发","slug":"黑马程序员/SSM框架/02_IoC和DI注解开发","date":"2021-07-28T02:03:43.000Z","updated":"2021-07-28T02:42:46.779Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/02_IoC和DI注解开发/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/02_IoC%E5%92%8CDI%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","excerpt":"","text":"1.Spring配置数据源1.1 数据源（连接池）的作用•数据源(连接池)是提高程序性能如出现的•事先实例化数据源，初始化部分连接资源•使用连接资源时从数据源中获取•使用完毕后将连接资源归还给数据源 常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等 数据源的开发步骤 ①导入数据源的坐标和数据库驱动坐标②创建数据源对象③设置数据源的基本连接数据④使用数据源获取连接资源和归还连接资源 1.2 数据源的手动创建①导入c3p0和druid的坐标 123456789101112&lt;!--C3P0连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--Druid连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; ①导入mysql数据库驱动坐标 123456&lt;!--mysql驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.39&lt;/version&gt;&lt;/dependency&gt; ②创建C3P0连接池 12345678910111213@Testpublic void testC3P0() throws Exception &#123; //创建数据源 ComboPooledDataSource dataSource = new ComboPooledDataSource(); //设置数据库连接参数 dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; ②创建Druid连接池 12345678910111213@Testpublic void testDruid() throws Exception &#123; //创建数据源 DruidDataSource dataSource = new DruidDataSource(); //设置数据库连接参数 dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; ③提取jdbc.properties配置文件 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=root ④读取jdbc.properties配置文件创建连接池 123456789101112@Testpublic void testC3P0ByProperties() throws Exception &#123; //加载类路径下的 jdbc.propertiesResourceBundle rb = ResourceBundle.getBundle(&quot;jdbc&quot;); ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(rb.getString(&quot;jdbc.driver&quot;)); dataSource.setJdbcUrl(rb.getString(&quot;jdbc.url&quot;)); dataSource.setUser(rb.getString(&quot;jdbc.username&quot;)); dataSource.setPassword(rb.getString(&quot;jdbc.password&quot;)); Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; 1.3 Spring配置数据源可以将DataSource的创建权交由Spring容器去完成 DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的 DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入 123456&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/bean&gt; 测试从容器当中获取数据源 1234ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);DataSource dataSource = (DataSource) applicationContext.getBean(&quot;dataSource&quot;);Connection connection = dataSource.getConnection();System.out.println(connection); 1.4 抽取jdbc配置文件applicationContext.xml加载jdbc.properties配置文件获得连接信息。 首先，需要引入context命名空间和约束路径： 命名空间：xmlns:context=”http://www.springframework.org/schema/context&quot; 约束路径：http://www.springframework.org/schema/context ` http://www.springframework.org/schema/context/spring-context.xsd` 1234567&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt; 1.5 知识要点Spring容器加载properties文件 12&lt;context:property-placeholder location=&quot;xx.properties&quot;/&gt;&lt;property name=&quot;&quot; value=&quot;$&#123;key&#125;&quot;/&gt; 2.Spring注解开发2.1 Spring原始注解Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。 Spring原始注解主要是替代的配置 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 注意： 使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。 12&lt;!--注解的组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt; 使用@Compont或@Repository标识UserDaoImpl需要Spring进行实例化。 12345678//@Component(&quot;userDao&quot;)@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(&quot;save running... ...&quot;); &#125;&#125; 使用@Compont或@Service标识UserServiceImpl需要Spring进行实例化 使用@Autowired或者@Autowired+@Qulifier或者@Resource进行userDao的注入 123456789101112//@Component(&quot;userService&quot;)@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService &#123; /*@Autowired @Qualifier(&quot;userDao&quot;)*/ @Resource(name=&quot;userDao&quot;) private UserDao userDao; @Override public void save() &#123; userDao.save(); &#125;&#125; 使用@Value进行字符串的注入 12345678910111213@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123; @Value(&quot;注入普通数据&quot;) private String str; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Override public void save() &#123; System.out.println(str); System.out.println(driver); System.out.println(&quot;save running... ...&quot;); &#125;&#125; 使用@Scope标注Bean的范围 //@Scope(“prototype”)@Scope(“singleton”)public class UserDaoImpl implements UserDao { //此处省略代码} 使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法 12345678@PostConstructpublic void init()&#123; System.out.println(&quot;初始化方法....&quot;);&#125;@PreDestroypublic void destroy()&#123; System.out.println(&quot;销毁方法.....&quot;);&#125; 2.2 Spring新注解使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下： 非自定义的Bean的配置：&lt;bean&gt; 加载properties文件的配置：&lt;context:property-placeholder&gt; 组件扫描的配置：&lt;context:component-scan&gt; 引入其他文件：&lt;import&gt; 注解 说明 @Configuration 用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解 @ComponentScan 用于指定 Spring 在初始化容器时要扫描的包。 作用和在 Spring 的 xml 配置文件中的 &lt;context:component-scan base-package=”com.itheima”/&gt;一样 @Bean 使用在方法上，标注将该方法的返回值存储到 Spring 容器中 @PropertySource 用于加载.properties 文件中的配置 @Import 用于导入其他配置类 @Configuration @ComponentScan @Import 12345@Configuration@ComponentScan(&quot;com.itheima&quot;)@Import(&#123;DataSourceConfiguration.class&#125;)public class SpringConfiguration &#123;&#125; @PropertySource @value 1234567891011@PropertySource(&quot;classpath:jdbc.properties&quot;)public class DataSourceConfiguration &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password;&#125; @Bean 123456789@Bean(name=&quot;dataSource&quot;)public DataSource getDataSource() throws PropertyVetoException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); return dataSource;&#125; 测试加载核心配置类创建Spring容器 123456789@Testpublic void testAnnoConfiguration() throws Exception &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfiguration.class); UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;); userService.save(); DataSource dataSource = (DataSource) applicationContext.getBean(&quot;dataSource&quot;); Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; 3. Spring集成Junit3.1 原始Junit测试Spring的问题在测试类中，每个测试方法都有以下两行代码： 12ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);IAccountService as = ac.getBean(&quot;accountService&quot;,IAccountService.class); 这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。 3.2 上述问题解决思路•让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它•将需要进行测试Bean直接在测试类中进行注入 3.3 Spring集成Junit步骤①导入spring集成Junit的坐标②使用@Runwith注解替换原来的运行期③使用@ContextConfiguration指定配置文件或配置类④使用@Autowired注入需要测试的对象⑤创建测试方法进行测试 3.4 Spring集成Junit代码实现①导入spring集成Junit的坐标 123456789101112&lt;!--此处需要注意的是，spring5 及以上版本要求junit 的版本必须是4.12 及以上--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; ②使用@Runwith注解替换原来的运行期 123@RunWith(SpringJUnit4ClassRunner.class)public class SpringJunitTest &#123;&#125; ③使用 @ContextConfiguration 指定配置文件或配置类 1234567@RunWith(SpringJUnit4ClassRunner.class)//加载spring核心配置文件//@ContextConfiguration(value = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)//加载spring核心配置类@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123;&#125; ④使用@Autowired注入需要测试的对象 123456@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123; @Autowired private UserService userService;&#125; ⑤创建测试方法进行测试 12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123; @Autowired private UserService userService; @Test public void testUserService()&#123; userService.save(); &#125;&#125; 3.5 知识要点Spring集成Junit步骤 ①导入spring集成Junit的坐标②使用@Runwith注解替换原来的运行期③使用@ContextConfiguration指定配置文件或配置类④使用@Autowired注入需要测试的对象⑤创建测试方法进行测试","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"01_IoC和DI","slug":"黑马程序员/SSM框架/01_IoC和DI","date":"2021-07-26T15:11:01.000Z","updated":"2021-07-28T02:42:17.545Z","comments":true,"path":"2021/07/26/黑马程序员/SSM框架/01_IoC和DI/","link":"","permalink":"http://example.com/2021/07/26/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/01_IoC%E5%92%8CDI/","excerpt":"","text":"1. Spring简介1.1 Spring是什么Spring是分层的Java SE/EE应用full-stack 轻量级开源框架，以IoC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核。 提供了展现层SpringMVC和持久层Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。 1.2 Spring发展历程1997 年，IBM提出了EJB 的思想1998 年，SUN制定开发标准规范EJB1.01999 年，EJB1.1 发布2001 年，EJB2.0 发布2003 年，EJB2.1 发布2006 年，EJB3.0 发布 Rod Johnson （Spring 之父） Expert One-to-One J2EE Design and Development(2002)阐述了J2EE 使用EJB 开发设计的优点及解决方案 Expert One-to-One J2EE Development without EJB(2004)阐述了J2EE 开发不使用EJB的解决方式（Spring 雏形） 2017 年9 月份发布了Spring 的最新版本Spring5.0 通用版（GA） 1.3 Spring的优势1）方便解耦，简化开发通过Spring 提供的IoC容器，可以将对象间的依赖关系交由Spring 进行控制，避免硬编码所造成的过度耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 2）AOP 编程的支持通过Spring的AOP 功能，方便进行面向切面编程，许多不容易用传统OOP 实现的功能可以通过AOP 轻松实现。 3）声明式事务的支持可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务管理，提高开发效率和质量。 4）方便程序的测试可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。 5）方便集成各种优秀框架Spring对各种优秀框架（ Struts 、 Hibernate 、 Hessian 、 Quartz 等）的支持。 6）降低 JavaEE API 的使用难度Spring对 JavaEE API （如 JDBC 、 JavaMail 、远程调用等）进行了薄薄的封装层，使这些 API 的使用难度大为降低。 7）Java 源码是经典学习范例Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对 Java 设计模式灵活运用以及对 Java 技术的高深造诣。它的源代码无意是Java 技术的最佳实践的范例。 1.4 Spring的体系结构![223ba3738ce35e28651e751646b24899.png](01_IoC和DI/2031_1 (1).png) 2. Spring快速入门2.1 Spring程序开发步骤 ①导入Spring 开发的基本包坐标②编写Dao 接口和实现类③创建Spring 核心配置文件④在Spring 配置文件中配置UserDaoImpl⑤使用Spring 的API 获得Bean 实例 2.2 导入Spring开发的基本包坐标123456789101112&lt;properties&gt; &lt;spring.version&gt;5.0.5.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!--导入spring的context坐标，context依赖core、beans、expression--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.3编写 Dao 接口和实现类12345678910public interface UserDao &#123; public void save();&#125;public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 2.4 创建Spring核心配置文件在类路径下（resources）创建applicationContext.xml配置文件 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 2.5 在Spring配置文件中配置UserDaoImpl12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;/bean&gt;&lt;/beans&gt; 2.6 使用Spring的API获得Bean实例123456@Testpublic void test1()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save();&#125; 2.7 知识要点Spring的开发步骤 ①导入坐标②创建Bean③创建applicationContext.xml④在配置文件中进行配置⑤创建ApplicationContext对象getBean 3. Spring配置文件3.1 Bean标签基本配置用于配置对象交由Spring来创建。默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。 基本属性： id：Bean实例在Spring容器中的唯一标识 class：Bean的全限定名称 3.2 Bean标签范围配置scope：指对象的作用范围，取值如下： 取值范围 说明 singleton 默认值，单例的 prototype 多例的 request WEB项目中，Spring创建一个Bean的对象，将对象存入到request域中 session WEB项目中，Spring创建一个Bean的对象，将对象存入到session域中 global session WEB项目中，应用在Portlet环境，如果没有Portlet环境，那么global session相当于session 当scope的取值为singleton时 Bean的实例化个数：1个 Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例 Bean的生命周期： 对象创建：当应用加载，创建容器时，对象就被创建了 对象运行：只要容器在，对象一直活着 对象销毁：当应用卸载，销毁容器时，对象就被销毁了 2）当scope的取值为prototype时 Bean的实例化个数：多个 Bean的实例化时机：当调用getBean()方法时实例化Bean - 对象创建：当使用对象时，创建新的对象实例 - 对象运行：只要对象在使用中，就一直活着 - 对象销毁：当对象长时间不用时，被Java 的垃圾回收器回收了 3.3 Bean生命周期配置 init-method：指定类中的初始化方法名称 destroy-method：指定类中销毁方法名称 3.4 Bean实例化三种方式 无参构造方法实例化 工厂静态方法实例化 工厂实例方法实例化 1）使用无参构造方法实例化 它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; 2）工厂静态方法实例化 工厂的静态方法返回Bean实例 12345public class StaticFactoryBean &#123; public static UserDao createUserDao()&#123; return new UserDaoImpl(); &#125;&#125; 1&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.factory.StaticFactoryBean&quot; factory-method=&quot;createUserDao&quot; /&gt; 3）工厂实例方法实例化 工厂的非静态方法返回Bean实例 12345public class DynamicFactoryBean &#123; public UserDao createUserDao()&#123; return new UserDaoImpl(); &#125;&#125; 12&lt;bean id=&quot;factoryBean&quot; class=&quot;com.itheima.factory.DynamicFactoryBean&quot;/&gt;&lt;bean id=&quot;userDao&quot; factory-bean=&quot;factoryBean&quot; factory-method=&quot;createUserDao&quot;/&gt; 3.5 Bean的依赖注入入门①创建UserService，UserService 内部在调用UserDao的save() 方法 12345678public class UserServiceImpl implements UserService &#123; @Override public void save() &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); &#125;&#125; ②将UserServiceImpl 的创建权交给Spring &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;/&gt; ③从Spring 容器中获得UserService 进行操作 12ApplicationContext applicationContext= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);UserService userService= (UserService) applicationContext.getBean(&quot;userService&quot;);userService.save(); 3.6 Bean的依赖注入分析目前UserService实例和UserDao实例都存在与Spring容器中，当前的做法是在容器外部获得UserService实例和UserDao实例，然后在程序中进行结合。 ![2037_1 (1)](01_IoC和DI/2037_1 (1).png) 因为UserService和UserDao都在Spring容器中，而最终程序直接使用的是UserService，所以可以在Spring容器中，将UserDao设置到UserService内部。 3.7 Bean的依赖注入概念依赖注入（Dependency Injection）：它是Spring 框架核心IOC 的具体实现。 在编写程序时，通过控制反转，把对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况。IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。 那这种业务层和持久层的依赖关系，在使用Spring 之后，就让Spring 来维护了。简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。 怎么将UserDao怎样注入到UserService内部呢？ 构造方法 set方法 1）set方法注入 在UserServiceImpl中添加setUserDao方法 123456789public class UserServiceImplimplements UserService&#123; private UserDao userDao; public void setUserDao(UserDaouserDao) &#123; this.userDao= userDao; &#125; @Overridepublic void save() &#123; userDao.save(); &#125;&#125; 配置Spring容器调用set方法进行注入 12345&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt; P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下： 首先，需要引入P命名空间：xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 其次，需要修改注入方式 &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot; p:userDao-ref=&quot;userDao&quot;/&gt; 2）构造方法注入 创建有参构造 12345678public class UserServiceImpl implements UserService &#123; @Override public void save() &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); &#125;&#125; 配置Spring容器调用有参构造时进行注入 1234&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 3.8 Bean的依赖注入的数据类型上面的操作，都是注入的引用Bean，除了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。 注入数据的三种数据类型 普通数据类型 引用数据类型 集合数据类型 其中引用数据类型，此处就不再赘述了，之前的操作都是对UserDao对象的引用进行注入的，下面将以set方法注入为例，演示普通数据类型和集合数据类型的注入。 1）普通数据类型的注入 1234567891011121314public class UserDaoImpl implements UserDao &#123; private String company; private int age; public void setCompany(String company) &#123; this.company = company; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void save() &#123; System.out.println(company+&quot;===&quot;+age); System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 1234&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;company&quot; value=&quot;传智播客&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2）集合数据类型（List）的注入 12345678910public class UserDaoImpl implements UserDao &#123; private List&lt;String&gt; strList; public void setStrList(List&lt;String&gt; strList) &#123; this.strList = strList; &#125; public void save() &#123; System.out.println(strList); System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 123456789&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;strList&quot;&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 3）集合数据类型 List User&gt;）的注入 12345678910public class UserDaoImpl implements UserDao &#123; private List&lt;User&gt; userList; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125; public void save() &#123; System.out.println(userList); System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 123456789101112&lt;bean id=&quot;u1&quot; class=&quot;com.itheima.domain.User&quot;/&gt;&lt;bean id=&quot;u2&quot; class=&quot;com.itheima.domain.User&quot;/&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;userList&quot;&gt; &lt;list&gt; &lt;bean class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean class=&quot;com.itheima.domain.User&quot;/&gt; &lt;ref bean=&quot;u1&quot;/&gt; &lt;ref bean=&quot;u2&quot;/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 4）集合数据类型（Map&lt;String,User&gt;）的注入 12345678910public class UserDaoImpl implements UserDao &#123; private Map&lt;String,User&gt; userMap; public void setUserMap(Map&lt;String, User&gt; userMap) &#123; this.userMap = userMap; &#125; public void save() &#123; System.out.println(userMap); System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 12345678910&lt;bean id=&quot;u1&quot; class=&quot;com.itheima.domain.User&quot;/&gt;&lt;bean id=&quot;u2&quot; class=&quot;com.itheima.domain.User&quot;/&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;userMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;user1&quot; value-ref=&quot;u1&quot;/&gt; &lt;entry key=&quot;user2&quot; value-ref=&quot;u2&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 5）集合数据类型（Properties）的注入 12345678910public class UserDaoImpl implements UserDao &#123; private Properties properties; public void setProperties(Properties properties) &#123; this.properties = properties; &#125; public void save() &#123; System.out.println(properties); System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 123456789&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;p1&quot;&gt;aaa&lt;/prop&gt; &lt;prop key=&quot;p2&quot;&gt;bbb&lt;/prop&gt; &lt;prop key=&quot;p3&quot;&gt;ccc&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 3.9引入其他配置文件（分模块开发）实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载&lt;import resource=&quot;applicationContext-xxx.xml&quot;/&gt; 4. Spring相关API4.1 ApplicationContext的继承体系applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象 4.2 ApplicationContext的实现类1）ClassPathXmlApplicationContext它是从类的根路径下加载配置文件推荐使用这种 2）FileSystemXmlApplicationContext它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 3）AnnotationConfigApplicationContext当使用注解配置容器对象时，需要使用此类来创建spring 容器。它用来读取注解。 4.3 getBean()方法使用123456789public Object getBean(String name) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBean(name);&#125; public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException&#123; assertBeanFactoryActive(); return getBeanFactory().getBean(requiredType);&#125; 其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错。 123ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);UserService userService1 = (UserService) applicationContext.getBean(&quot;userService&quot;);UserService userService2 = applicationContext.getBean(UserService.class); 4.4 知识要点1234Spring的重点APIApplicationContext app = newClasspathXmlApplicationContext(&quot;xml文件&quot;)app.getBean(&quot;id&quot;)app.getBean(Class)","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-07-26T13:22:00.116Z","updated":"2021-07-26T13:22:00.116Z","comments":true,"path":"2021/07/26/hello-world/","link":"","permalink":"http://example.com/2021/07/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"黑马程序员 springboot","slug":"黑马程序员-springboot","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot/"},{"name":"黑马程序员 redis","slug":"黑马程序员-redis","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-redis/"},{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]}