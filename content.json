{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"11_主从复制","slug":"黑马程序员/redis/11_主从复制","date":"2021-08-04T10:07:30.000Z","updated":"2021-08-04T10:23:20.379Z","comments":true,"path":"2021/08/04/黑马程序员/redis/11_主从复制/","link":"","permalink":"http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","excerpt":"","text":"主从复制简介互联网“三高”架构 高并发 高性能 高可用 你的“Redis”是否高可用单机redis的风险与问题 问题1.机器故障 现象：硬盘故障、系统崩溃 本质：数据丢失，很可能对业务造成灾难性打击 结论：基本上会放弃使用redis. 问题2.容量瓶颈 现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存 本质：穷，硬件条件跟不上 结论：放弃使用redis 结论： 为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据冗余备份。 多台服务器连接方案 提供数据方：master 主服务器，主节点，主库 主客户端 接收数据方：slave 从服务器，从节点，从库 从客户端 需要解决的问题： 数据同步 核心工作： master的数据复制到slave中 主从复制主从复制即将master中的数据即时、有效的复制到slave中 特征：一个master可以拥有多个slave，一个slave只对应一个master 职责： master: 写数据 执行写操作时，将出现变化的数据自动同步到slave 读数据（可忽略） slave: 读数据 写数据（禁止） 高可用集群 主从复制的作用 读写分离：master写、slave读，提高服务器的读写负载能力 负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量 故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复 数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式 高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案 主从复制工作流程总述 主从复制过程大体可以分为3个阶段 建立连接阶段（即准备阶段） 数据同步阶段 命令传播阶段 阶段一：建立连接阶段 建立slave到master的连接，使master能够识别slave，并保存slave端口号 建立连接阶段工作流程步骤1：设置master的地址和端口，保存master信息 步骤2：建立socket连接 步骤3：发送ping命令（定时器任务） 步骤4：身份验证 步骤5：发送slave端口信息 至此，主从连接成功！ 状态： slave： ​ 保存master的地址与端口 master： ​ 保存slave的端口 总体： ​ 之间创建了连接的socket 主从连接（slave连接master） 方式一：客户端发送命令 ```slaveof 12345- 方式二：启动服务器参数 - ``` redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt; 方式三：服务器配置 ```slaveof 1234567891011121314151617- slave系统信息 - master_link_down_since_seconds - masterhost - masterport- master系统信息 - slave_listening_port(多个)#### 主从断开连接- 客户端发送命令 - ``` slaveof no one 说明： slave断开连接后，不会删除已有数据，只是不再接受master发送的数据 授权访问 master客户端发送命令设置密码 ```requirepass 12345678 - - master配置文件设置密码 - ``` config set requirepass &lt;password&gt; config get requirepass slave客户端发送命令设置密码 ```auth 12345- slave配置文件设置密码 - ``` masterauth &lt;password&gt; slave启动服务器设置密码 ```redis-server –a 1234567891011121314151617181920212223242526272829303132333435363738#### 阶段二：数据同步阶段工作流程- 在slave初次连接master后，复制master中的所有数据到slave- 将slave的数据库状态更新成master当前的数据库状态#### 数据同步阶段工作流程步骤1：请求同步数据 步骤2：创建RDB同步数据 步骤3：恢复RDB同步数据 步骤4：请求部分同步数据 步骤5：恢复部分同步数据 至此，数据同步工作完成！ 状态： slave： ​ 具有master端全部数据，包含RDB过程接收的数据 master： ​ 保存slave当前数据同步的位置 总体： 之间完成了数据克隆![image-20210804100004054](11_主从复制/image-20210804100004054.png)#### 数据同步阶段master说明1. 如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行2. 复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。 repl-backlog-size 1mb 12345678910113. master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区 ![image-20210804100121497](11_主从复制/image-20210804100121497.png)#### 数据同步阶段slave说明1. 为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务 slave-serve-stale-data yes|no 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697982. 数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令3. 多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰4. slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，数据一致性变差，应谨慎选择#### 阶段三：命令传播阶段- 当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，同步的动作称为命令传播- master将接收到的数据变更命令发送给slave，slave接收命令后执行命令- 主从复制过程大体可以分为3个阶段 - 建立连接阶段（即准备阶段） - 数据同步阶段 - 命令传播阶段#### 命令传播阶段的部分复制- 命令传播阶段出现了断网现象 - 网络闪断闪连 忽略 - 短时间网络中断 部分复制 - 长时间网络中断 全量复制- 部分复制的三个核心要素 - 服务器的运行 id（run id） - 主服务器的复制积压缓冲区 - 主从服务器的复制偏移量#### 服务器运行ID（runid）- 概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id- 组成：运行id由40位字符组成，是一个随机的十六进制字符 - 例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce- 作用：运行id被用于在服务器间进行传输，识别身份 - 如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别- 实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid#### 复制缓冲区- 概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区![image-20210804100510720](11_主从复制/image-20210804100510720.png)#### 复制缓冲区内部工作原理- 组成 - 偏移量 - 字节值- 工作原理 - 通过offset区分不同的slave当前数据传播的差异 - master记录已发送的信息对应的offset - slave记录已接收的信息对应的offset![复制缓冲区/复制积压缓冲区](11_主从复制/image-20210804100811798.png)#### 复制缓冲区- 概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区 - 复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列- 由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区- 作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select）- 数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中主从服务器复制偏移量（offset）- 概念：一个数字，描述复制缓冲区中的指令字节位置- 分类： - master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个） - slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）- 数据来源： - master端：发送一次记录一次 - slave端：接收一次记录一次- 作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用#### 数据同步+命令传播阶段工作流程![image-20210804101026777](11_主从复制/image-20210804101026777.png)#### 心跳机制- 进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线- master心跳： - 指令：PING - 周期：由repl-ping-slave-period决定，默认10秒 - 作用：判断slave是否在线 - 查询：INFO replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常- slave心跳任务 - 指令：REPLCONF ACK &#123;offset&#125; - 周期：1秒 - 作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令 - 作用2：判断master是否在线#### 心跳阶段注意事项- 当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作 - ``` min-slaves-to-write 2 min-slaves-max-lag 8 slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步 slave数量由slave发送REPLCONF ACK命令做确认 slave延迟由slave发送REPLCONF ACK命令做确认 主从复制工作流程（完整） 主从复制常见问题频繁的全量复制（1）伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的全量复制操作 内部优化调整方案： master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave 在master关闭时执行命令 shutdown save，进行RDB持久化,将runid与offset保存到RDB文件中 repl-id repl-offset 通过redis-check-rdb命令可以查看该信息 master重启后加载RDB文件，恢复数据 重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中 master_repl_id = repl master_repl_offset = repl-offset 通过info命令可以查看该信息 作用： 本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master 频繁的全量复制（2） 问题现象 网络环境不佳，出现网络中断，slave不提供服务 问题原因 复制缓冲区过小，断网后slave的offset越界，触发全量复制 最终结果 slave反复进行全量复制 解决方案 修改复制缓冲区大小 ```repl-backlog-size 1234567891011121314151617181920212223242526272829- 建议设置如下： 1. 测算从master到slave的重连平均时长second 2. 获取master平均每秒产生写命令数据总量write_size_per_second 3. 最优复制缓冲区空间 = 2 * second * write_size_per_second频繁的网络中断（1）- 问题现象 - master的CPU占用过高 或 slave频繁断开连接- 问题原因 - slave每1秒发送REPLCONF ACK命令到master - 当slave接到了慢查询时（keys * ，hgetall等），会大量占用CPU性能 - master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应- 最终结果 - master各种资源（输出缓冲区、带宽、连接等）被严重占用- 解决方案 - 通过设置合理的超时时间，确认是否释放slave - ``` repl-timeout 该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave 频繁的网络中断（2） 问题现象 slave与master连接断开 问题原因 master发送ping指令频度较低 master设定超时时间较短 ping指令在网络中存在丢包 解决方案 提高ping指令发送的频度 ```repl-ping-slave-period 123456789101112131415161718192021 - 超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时#### 数据不一致- 问题现象 - 多个slave获取相同数据不同步- 问题原因 - 网络信息不同步，数据发送有延迟- 解决方案 - 优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象 - 监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问 - ``` slave-serve-stale-data yes|no 开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高）","categories":[],"tags":[{"name":"黑马程序员","slug":"黑马程序员","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"10_高级数据类型","slug":"黑马程序员/redis/10_高级数据类型","date":"2021-08-04T10:07:15.000Z","updated":"2021-08-04T10:22:58.258Z","comments":true,"path":"2021/08/04/黑马程序员/redis/10_高级数据类型/","link":"","permalink":"http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Bitmaps公司的年度总结会 公司的年度总结会第二天 存储需求 Bitmaps类型的基础操作 获取指定key对应偏移量上的bit值 ```getbit key offset12345- 设置指定key对应偏移量上的bit值，value只能是1或0 - ``` setbit key offset value Bitmaps类型的扩展操作**业务场景 电影网站 统计每天某一部电影是否被点播 统计每天有多少部电影被点播 统计每周/月/年有多少部电影被点播 统计年度哪部电影没有被点播 业务分析 对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中 ```bitop op destKey key1 [key2…]1234567891011121314 - and：交 - or：并 - not：非 - xor：异或- 统计指定key中1的数量 - ``` bitcount key [start end] Tips 21： redis 应用于信息状态统计 HyperLogLog统计独立UV 原始方案：set 存储每个用户的id（字符串） 改进方案：Bitmaps 存储每个用户状态（bit） 全新的方案：Hyperloglog 基数 基数是数据集去重后元素个数 HyperLogLog 是用来做基数统计的，运用了LogLog的算法 LogLog算法 HyperLogLog类型的基本操作 添加数据 ```pfadd key element [element …]12345- 统计数据 - ``` pfcount key [key ...] 合并数据 ```pfmerge destkey sourcekey [sourcekey…]1234567891011121314151617181920212223242526272829303132Tips 22：- redis 应用于独立信息统计#### 相关说明- 用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据- 核心是基数估算算法，最终数值存在一定误差- 误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值- 耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数- pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大- Pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多少### GEO#### 火热的生活服务类软件- 微信 / 陌陌- 美团 / 饿了么- 携程 / 马蜂窝- 高德 / 百度- ……#### GEO类型的基本操作- 添加坐标点 - ``` geoadd key longitude latitude member [longitude latitude member ...] 获取坐标点 ```geopos key member [member …]12345- 计算坐标点距离 - ``` geodist key member1 member2 [unit] 添加坐标点 ```georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]12345- 获取坐标点 - ``` georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count] 计算经纬度 geohash key member [member ...] Tips 23： redis 应用于地理位置计算","categories":[],"tags":[{"name":"黑马程序员","slug":"黑马程序员","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"09_redis服务器配置","slug":"黑马程序员/redis/09_redis服务器配置","date":"2021-08-04T10:07:01.000Z","updated":"2021-08-04T10:13:51.816Z","comments":true,"path":"2021/08/04/黑马程序员/redis/09_redis服务器配置/","link":"","permalink":"http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/09_redis%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/","excerpt":"","text":"服务器基础配置服务器端设定 设置服务器以守护进程的方式运行 ```daemonize yes|no12345- 绑定主机地址 - ``` bind 127.0.0.1 设置服务器端口号 ```port 637912345- 设置数据库数量 - ``` databases 16 日志配置 设置服务器以指定日志记录级别 ```loglevel debug|verbose|notice|warning12345- 日志记录文件名 - ``` logfile 端口号.log 注意：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频度 客户端配置 设置同一时间最大客户端连接数，默认无限制。当客户端连接到达上限，Redis会关闭新的连接 ```maxclients 012345- 客户端闲置等待最大时长，达到最大值后关闭连接。如需关闭该功能，设置为 0 - ``` timeout 300 多服务器快捷配置 导入并加载指定配置文件信息，用于快速创建redis公共配置较多的redis实例配置文件，便于维护 include /path/server-端口号.conf","categories":[],"tags":[{"name":"黑马程序员","slug":"黑马程序员","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"08_删除策略","slug":"黑马程序员/redis/08_删除策略","date":"2021-08-04T10:06:41.000Z","updated":"2021-08-04T10:22:30.357Z","comments":true,"path":"2021/08/04/黑马程序员/redis/08_删除策略/","link":"","permalink":"http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/","excerpt":"","text":"过期数据Redis中的数据特征 Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态 XX ：具有时效性的数据 -1 ：永久有效的数据 -2 ：已经过期的数据 或 被删除的数据 或 未定义的数据 过期的数据真的删除了吗？ Redis中的数据特征 数据删除策略 定时删除 惰性删除 定期删除 数据删除策略时效性数据的存储结构 数据删除策略的目标在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露 定时删除 创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作 优点：节约内存，到时就删除，快速释放掉不必要的内存占用 缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量 总结：用处理器性能换取存储空间（拿时间换空间） 惰性删除 数据到达过期时间，不做处理。等下次访问该数据时 如果未过期，返回数据 发现已过期，删除，返回不存在 优点：节约CPU性能，发现必须删除的时候才删除 缺点：内存压力很大，出现长期占用内存的数据 总结：用存储空间换取处理器性能（拿时间换空间） 定期删除两种方案都走极端，有没有折中方案？ Redis启动服务器初始化时，读取配置server.hz的值，默认为10 每秒钟执行server.hz次serverCron()–&gt;(databasesCron()–&gt;(activeExpireCycle())) activeExpireCycle()对每个expires[*]逐一进行检测，每次执行250ms/server.hz 对某个expires[]检测时，随机挑选W个key检测 如果key超时，删除key 如果一轮中删除的key的数量&gt;W25%，循环该过程 如果一轮中删除的key的数量≤W25%，检查下一个expires[]，0-15循环* W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值 参数current_db用于记录activeExpireCycle() 进入哪个expires[*] 执行 如果activeExpireCycle()执行时间到期，下次从current_db继续向下执行 周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度 特点1：CPU性能占用设置有峰值，检测频度可自定义设置 特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理 总结：周期性抽查存储空间（随机抽查，重点抽查） 删除策略比对 定时删除 节约内存，无占用 不分时段占用CPU资源，频度高 拿时间换空间 惰性删除 内存占用严重 延时执行，CPU利用率高 拿空间换时间 定期删除 内存定期随机清理 每秒花费固定的CPU资源维护内存 随机抽查，重点抽查 逐出算法新数据进入检测当新数据进入redis时，如果内存不足怎么办？ Redis使用内存存储数据，在执行每一个命令前，会调用freeMemoryIfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。 注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。 1(error) OOM command not allowed when used memory &gt;&#x27;maxmemory&#x27; 影响数据逐出的相关配置 最大可使用内存 ```maxmemory 1234567 - 占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。- 每次选取待删除数据的个数 - ``` maxmemory-samples 选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据 删除策略 maxmemory-policy 达到最大内存后的，对被挑选出来的数据进行删除的策略 检测易失数据（可能会过期的数据集server.db[i].expires ） ① volatile-lru：挑选最近最少使用的数据淘汰 ② volatile-lfu：挑选最近使用次数最少的数据淘汰 ③ volatile-ttl：挑选将要过期的数据淘汰 ④ volatile-random：任意选择数据淘汰 检测全库数据（所有数据集server.db[i].dict ） ⑤ allkeys-lru：挑选最近最少使用的数据淘汰 ⑥ allkeys-lfu：挑选最近使用次数最少的数据淘汰 ⑦ allkeys-random：任意选择数据淘汰 放弃数据驱逐 ⑧ no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory） 数据逐出策略配置依据 使用INFO命令输出监控信息，查询缓存 hit 和 miss 的次数，根据业务需求调优Redis配置","categories":[],"tags":[{"name":"黑马程序员","slug":"黑马程序员","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"07_redis事务","slug":"黑马程序员/redis/07_redis事务","date":"2021-08-04T10:06:24.000Z","updated":"2021-08-04T10:22:05.528Z","comments":true,"path":"2021/08/04/黑马程序员/redis/07_redis事务/","link":"","permalink":"http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/07_redis%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"Redis 事务事务简介什么是事务Redis执行指令过程中，多条连续执行的指令被干扰，打断，插队 redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性按照添加顺序依次执行，中间不会被打断或者干扰。 一个队列中，一次性、顺序性、排他性的执行一系列命令 事务基本操作事务的边界事务的基本操作 开启事务 ```multi123456789- 作用 - 设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中- 执行事务 - ``` exec 作用 设定事务的结束位置，同时执行事务。与multi成对出现，成对使用 注意：加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行 事务定义过程中发现出了问题，怎么办？ 取消事务 ```discard12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061- 作用 - 终止当前事务的定义，发生在multi之后，exec之前#### 事务的工作流程![image-20210801000649399](07_redis事务/image-20210801000649399.png)#### 事务的注意事项**定义事务的过程中，命令格式输入错误怎么办？**- 语法错误 - 指命令书写格式有误- 处理结果 - 如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行。包括那些语法正确的命令。**定义事务的过程中，命令执行出现错误怎么办？**- 运行错误 - 指命令格式正确，但是无法正确的执行。例如对list进行incr操作- 处理结果 - 能够正确运行的命令会执行，运行错误的命令不会被执行&gt; 注意：已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。### 手动进行事务回滚- 记录操作过程中被影响的数据之前的状态 - 单数据：string - 多数据：hash、list、set、zset- 设置指令恢复所有的被修改的项 - 单数据：直接set（注意周边属性，例如时效） - 多数据：修改对应值或整体克隆复制### 锁#### 基于特定条件的事务执行**业务场景**天猫双11热卖过程中，对已经售罄的货物追加补货，4个业务员都有权限进行补货。补货的操作可能是一系列的操作，牵扯到多个连续操作，如何保障不会重复操作？**业务分析**- 多个客户端有可能同时操作同一组数据，并且该数据一旦被操作修改后，将不适用于继续操作- 在操作之前锁定要操作的数据，一旦发生变化，终止当前操作#### 基于特定条件的事务执行——锁**解决方案**- 对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行 - ``` watch key1 [key2……] 取消对所有 key 的监视 ```unwatch123456789101112131415161718192021222324Tips 18：- redis 应用基于状态控制的批量任务执行#### 基于特定条件的事务执行**业务场景**天猫双11热卖过程中，对已经售罄的货物追加补货，且补货完成。客户购买热情高涨，3秒内将所有商品购买完毕。本次补货已经将库存全部清空，如何避免最后一件商品不被多人同时购买？【超卖问题】**业务分析**- 使用watch监控一个key有没有改变已经不能解决问题，此处要监控的是具体数据- 虽然redis是单线程的，但是多个客户端对同一数据同时进行操作时，如何避免不被同时修改？#### 基于特定条件的事务执行——分布式锁**解决方案**- 使用 setnx 设置一个公共锁 - ``` setnx lock-key value 利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功 对于返回设置成功的，拥有控制权，进行下一步的具体业务操作 对于返回设置失败的，不具有控制权，排队或等待 操作完毕通过del操作释放锁 注意：上述解决方案是一种设计概念，依赖规范保障，具有风险性 Tips 19： redis 应用基于分布式锁对应的场景控制 基于特定条件的事务执行业务场景 依赖分布式锁的机制，某个用户操作时对应客户端宕机，且此时已经获取到锁。如何解决？ 业务分析 由于锁操作由用户控制加锁解锁，必定会存在加锁后未解锁的风险 需要解锁操作不能仅依赖用户控制，系统级别要给出对应的保底处理方案 基于特定条件的事务执行——分布式锁改良解决方案 使用 expire 为锁key添加时间限定，到时不释放，放弃锁 expire lock-key second pexpire lock-key milliseconds 由于操作通常都是微秒或毫秒级，因此该锁定时间不宜设置过大。具体时间需要业务测试后确认。 例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。 测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时 锁时间设定推荐：最大耗时120%+平均网络延迟110% 如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可 redssion","categories":[],"tags":[{"name":"黑马程序员","slug":"黑马程序员","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"06_redis持久化","slug":"黑马程序员/redis/06_redis持久化","date":"2021-08-04T10:05:49.000Z","updated":"2021-08-04T10:20:36.232Z","comments":true,"path":"2021/08/04/黑马程序员/redis/06_redis持久化/","link":"","permalink":"http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/","excerpt":"","text":"持久化简介意外的断电 “自动备份” 什么是持久化利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。 为什么要进行持久化防止数据的意外丢失，确保数据安全性 持久化过程保存什么 将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据 将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程 RDBRDB启动方式谁，什么时间，干什么事情 命令执行 谁：redis操作者（用户） 什么时间：即时（随时进行） 干什么事情：保存数据 RDB启动方式 —— save指令 命令 1save 作用 ​ 手动执行一次保存操作 RDB启动方式 —— save指令相关配置(写在conf文件中) dbfilename dump.rdb 说明：设置本地数据库文件名，默认值为 dump.rdb 经验：通常设置为dump-端口号.rdb dir 说明：设置存储.rdb文件的路径 经验：通常设置成存储空间较大的目录中，目录名称data rdbcompression yes 说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩 经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大） rdbchecksum yes 说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行 经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险 redis在启动时会自动恢复。 RDB启动方式 —— save指令工作原理 数据量过大，单线程执行方式造成效率过低如何处理？ 后台执行 谁：redis操作者（用户）发起指令；redis服务器控制指令执行 什么时间：即时（发起）；合理的时间（执行） 干什么事情：保存数据 RDB启动方式 —— bgsave指令 命令 1bgsave 作用 ​ 手动启动后台保存操作，但不是立即执行 RDB启动方式 —— bgsave指令工作原理 注意： bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用。 RDB启动方式 —— bgsave指令相关配置 dbfilename dump.rdb dir rdbcompression yes rdbchecksum yes stop-writes-on-bgsave-error yes ​ 说明：后台存储过程中如果出现错误现象，是否停止保存操作​ 经验：通常默认为开启状态 反复执行保存指令，忘记了怎么办？不知道数据产生了多少变化，何时保存？ 自动执行 谁：redis服务器发起指令（基于条件） 什么时间：满足条件 干什么事情：保存数据 RDB启动方式 ——save配置 配置 1save second changes 作用 满足限定时间范围内key的变化数量达到指定数量即进行持久化 参数 second：监控时间范围 changes：监控key的变化量 位置 在conf文件中进行配置 范例 123save 900 1 save 300 10 save 60 10000 RDB启动方式 ——save配置原理 注意： save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的 save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系 save配置启动后执行的是bgsave操作 save配置相关配置 dbfilename dump.rdb dir rdbcompression yes rdbchecksum yes RDB三种启动方式对比 方式 save指令 bgsave指令 读写 同步 异步 阻塞客户端指令 是 否 额外内存消耗 否 是 启动新进程 否 是 rdb特殊启动形式 全量复制 在主从复制中详细讲解 服务器运行过程中重启 ```debug reload12345- 关闭服务器时指定保存数据 - ``` shutdown save 默认情况下执行shutdown命令时，自动执行bgsave(如果没有开启AOF持久化功能) RDB优点 RDB是一个紧凑压缩的二进制文件，存储效率较高 RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景 RDB恢复数据的速度要比AOF快很多 应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。 Rdb缺点 RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据 bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能 Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象 AOFRDB存储的弊端 存储数据量较大，效率较低 基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低 大数据量下的IO性能较低 基于fork创建子进程，内存产生额外消耗 宕机带来的数据丢失风险 解决思路 不写全数据，仅记录部分数据 降低区分数据是否改变的难度，改记录数据为记录操作过程 对所有操作均进行记录，排除丢失数据的风险 AOF概念 AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程 AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式 AOF写数据过程 AOF写数据三种策略(appendfsync) always(每次） 每次写入操作均同步到AOF文件中，数据零误差，性能较低，不建议使用。 everysec（每秒） 每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，性能较高 ，建议使用，也是默认配置 在系统突然宕机的情况下丢失1秒内的数据 no（系统控制） 由操作系统控制每次同步到AOF文件的周期，整体过程不可控 AOF功能开启 配置 ```appendonly yes|no123456789- 作用 - 是否开启AOF持久化功能，默认为不开启状态- 配置 - ``` appendfsync always|everysec|no 作用 AOF写数据策略 AOF相关配置 配置 ```appendfilename filename123456789- 作用 - AOF持久化文件名，默认文件名未appendonly.aof，建议配置为appendonly-端口号.aof- 配置 - ``` dir 作用 AOF持久化文件保存路径，与RDB持久化文件保持一致即可 AOF写数据遇到的问题如果连续执行如下指令该如何处理 AOF重写随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令进行记录。 AOF重写作用 降低磁盘占用量，提高磁盘利用率 提高持久化效率，降低持久化写时间，提高IO性能 降低数据恢复用时，提高数据恢复效率 AOF重写规则 进程内已超时的数据不再写入文件 忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令 如del key1、 hdel key2、srem key3、set key4 111、set key4 222等 对同一数据的多条写命令合并为一条命令 如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c。 为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素 AOF重写方式 手动重写 ```bgrewriteaof123456- 自动重写 - ``` auto-aof-rewrite-min-size size auto-aof-rewrite-percentage percentage RDB启动方式 —— bgsave指令工作原理 AOF手动重写 —— bgrewriteaof指令工作原理 AOF自动重写方式 自动重写触发条件设置 ```auto-aof-rewrite-min-size sizeauto-aof-rewrite-percentage percent123456- 自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ） - ``` aof_current_size aof_base_size 自动重写触发条件 AOF工作流程 AOF重写流程 AOF缓冲区同步文件策略，由参数appendfsync控制 系统调用write和fsync说明： write操作会触发延迟写（delayed write）机制，Linux在内核提供页缓冲区用来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步硬盘操作依赖于系统调度机制，列如：缓冲区页空间写满或达到特定时间周期。同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。 fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞知道写入硬盘完成后返回，保证了数据持久化。 除了write、fsync、Linx还提供了sync、fdatasync操作，具体API说明参见： RDB与AOF区别RDB VS AOF 持久化方式 RDB AOF 占用存储空间 小（数据级：压缩） 大（指令级：重写） 存储速度 慢 快 恢复速度 快 慢 数据安全性 会丢失数据 依据策略决定 资源消耗 高/重量级 低/轻量级 启动优先级 低 高 RDB与AOF的选择之惑 对数据非常敏感，建议使用默认的AOF持久化方案 AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。 注意：由于AOF文件存储体积较大，且恢复速度较慢 数据呈现阶段有效性，建议使用RDB持久化方案 数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段点数据恢复通常采用RDB方案 注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结： 综合比对 RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊 如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF 如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB 灾难恢复选用RDB 双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量 持久化应用场景 Tips 1：redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性 Tips 3：redis应用于各种结构型和非结构型高热度数据访问加速 Tips 4：redis 应用于购物车数据存储设计 Tips 5：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计 Tips 6：redis 应用于具有操作先后顺序的数据控制 Tips 7：redis 应用于最新消息展示 Tips 9：redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索 Tips 12：redis 应用于基于黑名单与白名单设定的服务控制 Tips 13：redis 应用于计数器组合排序功能对应的排名 Tips 15：redis 应用于即时任务/消息队列执行管理 Tips 16：redis 应用于按次结算的服务控制","categories":[],"tags":[{"name":"黑马程序员","slug":"黑马程序员","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"05_linux环境安装redis","slug":"黑马程序员/redis/05_linux环境安装redis","date":"2021-08-04T10:04:49.000Z","updated":"2021-08-04T10:11:56.686Z","comments":true,"path":"2021/08/04/黑马程序员/redis/05_linux环境安装redis/","link":"","permalink":"http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/05_linux%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85redis/","excerpt":"","text":"Redis 安装基于Linux环境安装Redis基于Center OS7安装Redis 下载安装包 ​ wget http://download.redis.io/releases/redis-?.?.?.tar.gz 解压 ​ tar –xvf 文件名.tar.gz 编译 ​ make 安装 (直接进入解压目录下运行 make install就行) ​ make install [destdir=/目录] Redis基础环境设置 创建软链接 ​ ln -s 原始目录名 快速访问目录名 创建配置文件管理目录 ​ mkdir conf ​ mkdir config 创建数据文件管理目录 ​ mkdir data Redis服务启动 默认配置启动 ​ redis-server ​ redis-server –-port 6379 ​ redis-server –-port 6380 …… 指定配置文件启动 ​ redis-server redis.conf ​ redis-server redis-6379.conf ​ redis-server redis-6380.conf …… ​ redis-server conf/redis-6379.conf ​ redis-server config/redis-6380.conf …… Redis客户端连接 默认连接 ​ redis-cli 连接指定服务器 ​ redis-cli -h 127.0.0.1 ​ redis-cli –port 6379 ​ redis-cli -p 6379 ​ redis-cli -h 127.0.0.1 –port 6379 Redis服务端配置 基本配置 daemonize yes 以守护进程方式启动，使用本启动方式，redis将以服务的形式存在，日志将不再打印到命令窗口中 port 6*** 设定当前服务启动端口号 dir “/自定义目录/redis/data“ 设定当前服务文件保存位置，包含日志文件、持久化文件（后面详细讲解）等 logfile &quot;6***.log“ 设定日志文件名，便于查阅","categories":[],"tags":[{"name":"黑马程序员","slug":"黑马程序员","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"04_jedis","slug":"黑马程序员/redis/04_jedis","date":"2021-08-04T10:04:30.000Z","updated":"2021-08-04T10:16:35.181Z","comments":true,"path":"2021/08/04/黑马程序员/redis/04_jedis/","link":"","permalink":"http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/04_jedis/","excerpt":"","text":"Jedis简介编程语言与redis Java语言连接redis服务 ​ Jedis ​ SpringData Redis ​ Lettuce C 、C++ 、C# 、Erlang、Lua 、Objective-C 、Perl 、PHP 、Python 、Ruby 、Scala 可视化连接redis客户端 ​ Redis Desktop Manager ​ Redis Client ​ Redis Studio HelloWorld（Jedis版）准备工作 jar包导入 ​ 下载地址：https://mvnrepository.com/artifact/redis.clients/jedis 基于maven 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; 客户端连接redis 连接redis 1Jedis jedis = new Jedis(&quot;localhost&quot;, 6379); 操作redis 1234jedis.set(&quot;name&quot;, &quot;itheima&quot;);jedis.get(&quot;name&quot;);jedis.lpush(&quot;list1&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);List&lt;String&gt; list1 = jedis.lrange(&quot;list&quot;,&quot;0&quot;,&quot;-1&quot;); 关闭redis连接 1jedis.close(); API文档 ​ http://xetorthio.github.io/jedis/ Jedis读写redis数据案例：服务调用次数控制 人工智能领域的语义识别与自动对话将是未来服务业机器人应答呼叫体系中的重要技术，百度自研用户评价语义识别服务，免费开放给企业试用，同时训练百度自己的模型。现对试用用户的使用行为进行限速，限制每个用户每分钟最多发起10次调用 案例要求 设定A、B、C三个用户 A用户限制10次/分调用，B用户限制30次/分调用，C用户不限制 案例：需求分析 设定一个服务方法，用于模拟实际业务调用的服务，内部采用打印模拟调用 在业务调用前服务调用控制单元，内部使用redis进行控制，参照之前的方案 对调用超限使用异常进行控制，异常处理设定为打印提示信息 主程序启动3个线程，分别表示3种不同用户的调用 案例：实现步骤 设定业务方法 123void business(String id,long num)&#123; System.out.println(&quot;用户&quot;+id+&quot;发起业务调用，当前第&quot;+num+&quot;次&quot;); &#125; 设定多线类，模拟用户调用 123456789101112public void run()&#123; while(true)&#123; jd.service(id); //模拟调用间隔，设定为1.x秒 try&#123; Random r = new Random(); Thread.sleep(1000+ r.nextInt(200)); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; 设计redis控制方案 123456789101112131415161718192021void service(String id)&#123; Jedis jedis = new Jedis(&quot;localhost&quot;, 6379); String value = jedis.get(&quot;compid:&quot; + id); //判定是否具有调用计数控制，利用异常进行控制处理 if(value == null) &#123; //没有控制，创建控制计数器 jedis.setex(&quot;compid:&quot; + id, 20, &quot;&quot;+(Long.MAX_VALUE-10)); &#125;else&#123; //有控制，自增，并调用业务 try&#123; Long val = jedis.incr(&quot;compid:&quot;+id); business(id,10+val-Long.MAX_VALUE); &#125;catch (JedisDataException e)&#123; //调用次数溢出，弹出提示 System.out.println(&quot;用户：&quot;+id+&quot;使用次数已达到上限，请稍后再试，或升级VIP会员&quot;); return; &#125;finally&#123; jedis.close(); &#125; &#125; &#125; 设计启动主程序 1234public static void main(String[] args) &#123; MyThread t1 = new MyThread(&quot;初级用户&quot;); t1.start(); &#125; 后续1：对业务控制方案进行改造，设定不同用户等级的判定 后续2：将不同用户等级对应的信息、限制次数等设定到redis中，使用hash保存 Jedis简易工具类开发基于连接池获取连接 JedisPool：Jedis提供的连接池技术 ​ poolConfig:连接池配置对象 ​ host:redis服务地址 ​ port:redis服务端口号 123public JedisPool(GenericObjectPoolConfig poolConfig, String host, int port) &#123; this(poolConfig, host, port, 2000, (String)null, 0, (String)null); &#125; 封装连接参数 jedis.properties 1234jedis.host=localhost jedis.port=6379 jedis.maxTotal=30 jedis.maxIdle=10 加载配置信息 静态代码块初始化资源 123456789101112static&#123; //读取配置文件 获得参数值 ResourceBundle rb = ResourceBundle.getBundle(&quot;jedis&quot;); host = rb.getString(&quot;jedis.host&quot;); port = Integer.parseInt(rb.getString(&quot;jedis.port&quot;)); maxTotal = Integer.parseInt(rb.getString(&quot;jedis.maxTotal&quot;)); maxIdle = Integer.parseInt(rb.getString(&quot;jedis.maxIdle&quot;)); poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(maxTotal); poolConfig.setMaxIdle(maxIdle); jedisPool = new JedisPool(poolConfig,host,port); &#125; 获取连接 对外访问接口，提供jedis连接对象，连接从连接池获取 1234public static Jedis getJedis()&#123; Jedis jedis = jedisPool.getResource(); return jedis; &#125; 可视化客户端Redis Desktop Manager","categories":[],"tags":[{"name":"黑马程序员","slug":"黑马程序员","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"03_redis通用指令","slug":"黑马程序员/redis/03_redis通用指令","date":"2021-08-04T10:04:06.000Z","updated":"2021-08-04T10:11:19.965Z","comments":true,"path":"2021/08/04/黑马程序员/redis/03_redis通用指令/","link":"","permalink":"http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/03_redis%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4/","excerpt":"","text":"Redis 通用指令key通用指令key 特征 key是一个字符串，通过key获取redis中保存的数据 key应该设计哪些操作？ 对于key自身状态的相关操作，例如：删除，判定存在，获取类型等 对于key有效性控制相关操作，例如：有效期设定，判定是否有效，有效状态的切换等 对于key快速查询操作，例如：按指定策略查询key …… key 基本操作 删除指定key 1del key 获取key是否存在 1exists key 获取key的类型 1type key key 扩展操作（时效性控制） 为指定key设置有效期 1234expire key secondspexpire key millisecondsexpireat key timestamp #设置时间戳，linux下通常使用时间戳来控制pexpireat key milliseconds-timestamp 获取key的有效时间 12ttl key #key不存在返回-2 key存在返回-1 ，key设置了有效期，返回有效时常pttl key 切换key从时效性转换为永久性 1persist key key 扩展操作（查询模式） 查询key keys pattern 12345 - 查询模式规则 \\* 匹配任意数量的任意符号 ? 配合一个任意符号 [] 匹配一个指定符号 keys * 查询所有 keys it* 查询所有以it开头 keys *heima 查询所有以heima结尾 keys ??heima 查询所有前面两个字符任意，后面以heima结尾 keys user:? 查询所有以user:开头，最后一个字符任意 keys u[st]er:1 查询所有以u开头，以er:1结尾，中间包含一个字母，s或t 12345#### key 其他操作- 为key改名 rename key newkey #会覆盖newkey renamenx key newkey #newkey已拥有会失败 123- 对所有key排序 sort #用来对列表，集合排序，但并不改变列表集合的顺序 123- 其他key通用操作 help @generic 1234567891011121314151617181920### 数据库通用指令#### 数据库key 的重复问题- key是由程序员定义的- redis在使用过程中，伴随着操作数据量的增加，会出现大量的数据以及对应的key- 数据不区分种类、类别混杂在一起，极易出现重复或冲突**解决方案**- redis为每个服务提供有16个数据库，编号从0到15- 每个数据库之间的数据相互独立#### db 基本操作- 切换数据库 select index 123- 其他操作 quit ping #测试链接是否联通 echo message #原样输出，可以输出日志 12345#### db 相关操作- 数据移动 move key db 123- 数据清除 dbsize #查看库里有多少key flushdb #刷掉现在的数据 flushall #刷掉所有数据","categories":[],"tags":[{"name":"黑马程序员","slug":"黑马程序员","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"02_redis数据类型","slug":"黑马程序员/redis/02_redis数据类型","date":"2021-08-04T10:03:42.000Z","updated":"2021-08-04T10:09:32.018Z","comments":true,"path":"2021/08/04/黑马程序员/redis/02_redis数据类型/","link":"","permalink":"http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"02_redis 数据类型数据存储类型介绍业务数据的特殊性作为缓存使用 原始业务功能设计 秒杀 618活动 双11活动 排队购票 运营平台监控到的突发高频访问数据 突发时政要闻，被强势关注围观 高频、复杂的统计数据 在线人数 投票排行榜 附加功能 系统功能优化或升级 单服务器升级集群 Session 管理 Token 管理 Redis 数据类型（5种常用） string String hash HashMap list LinkedList set HashSet sorted_set TreeSet stringredis 数据存储格式 redis 自身是一个 Map，其中所有的数据都是采用 key : value 的形式存储 数据类型指的是存储的数据的类型，也就是 value 部分的类型，key 部分永远都是字符串 string 类型 存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型 存储数据的格式：一个存储空间保存一个数据 存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用（但仍然是字符串） string 类型数据的基本操作 添加/修改数据 1set key value 获取数据 1get key 删除数据（返回 (integer) 1 代表成功， (integer) 0 代表失败） 1del key 添加/修改多个数据(m 指的是 Multiple[ˈmʌltɪpl]) 1mset key1 value1 key2 value2 … 获取多个数据 1mget key1 key2 … 获取数据字符个数（字符串长度） 1strlen key 追加信息到原始信息后部（如果原始信息存在就追加，否则新建） 1append key value string 类型数据的基础操作 string 类型数据的扩展操作业务场景 大型企业级应用中，分表操作是基本操作，使用多张表存储同类型数据，但是对应的主键 id 必须保证统一性，不能重复。Oracle 数据库具有 sequence 设定，可以解决该问题，但是 MySQL数据库并不具有类似的机制，那么如何解决？ 解决方案 设置数值数据增加指定范围的值 123incr key incrby key increment incrbyfloat key increment 设置数值数据减少指定范围的值 12decr key decrby key increment string 作为数值操作 string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算。 redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。 注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE） Tips 1： redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性 此方案适用于所有数据库，且支持数据库集群 业务场景“最强女生”启动海选投票，只能通过微信投票，每个微信号每 4 小时只能投1票。 电商商家开启热门商品推荐，热门商品不能一直处于热门期，每种商品热门期维持3天，3天后自动取消热门。 新闻网站会出现热点新闻，热点新闻最大的特征是时效性，如何自动控制热点新闻的时效性。 news_id:HB314790725 00：30 解决方案 设置数据具有指定的生命周期 12345setex key seconds value setex tel 10 1# 如果期间在设置一个tel的值 如 setex tel 2 上面的设定会失效psetex key milliseconds value Tips 2： redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作 string 类型数据操作的注意事项 数据操作不成功的反馈与数据正常操作之间的差异（通过使用的指令区分） 表示运行结果是否成功 (integer) 0 → false 失败 (integer) 1 → true 成功 表示运行结果值 (integer) 3 → 3 3个 (integer) 1 → 1 1个 数据未获取到 （nil）等同于null 数据最大存储量 512MB 数值计算最大范围（java中的long的最大值） 9223372036854775807 string 类型应用场景业务场景 主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量 解决方案 在redis中为大V用户设定用户信息，以表名，用户主键和属性值作为key，后台设定定时刷新策略即可 eg: user:id:3506728370:fans → 12210947 eg:user:id:3506728370:blogs → 6164 eg: user:id:3506728370:focuss → 83 在redis中以json格式存储大V用户信息，定时刷新（也可以使用hash类型） eg: user:id:3506728370 → &#123;&quot;id&quot;:3506728370,&quot;name&quot;:&quot;春晚&quot;,&quot;fans&quot;:12210862,&quot;blogs&quot;:6164,&quot;focus&quot;:83&#125; Tips 3： redis应用于各种结构型和非结构型高热度数据访问加速 key 的设置约定 数据库中的热点数据key命名惯例 表名: 主键名: 主键值: 字段名 eg1： order: id: 29437595: name eg2： equip: id: 390472345: type eg3： news: id: 202004150: title hashhash 类型存储的困惑 对象类数据的存储如果具有较频繁的更新需求操作会显得笨重 新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息 需要的存储结构：一个存储空间保存多个键值对数据 hash类型：底层使用哈希表结构实现数据存储 hash 类型数据的基本操作 添加/修改数据 1hset key field value 获取数据 12hget key field hgetall key #会把file value都显示出来 删除数据 1hdel key field1 [field2] 添加/修改多个数据 1hmset key field1 value1 field2 value2 … 获取多个数据 1hmget key field1 field2 … 获取哈希表中字段的数量 1hlen key 获取哈希表中是否存在指定的字段 1hexists key field hash 类型数据扩展操作 获取哈希表中所有的字段名或字段值 12hkeys key hvals key 设置指定字段的数值数据增加指定范围的值 12hincrby key field increment #可以是复数hincrbyfloat key field increment hash 类型数据操作的注意事项 hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil） 每个 hash 可以存储 2 ^ 23 - 1 个键值对 hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，更不可以将hash作为对象列表使用 hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈 hash 类型应用场景业务场景 电商网站购物车设计与实现 业务分析 仅分析购物车的redis存储模型 添加、浏览、更改数量、删除、清空 购物车于数据库间持久化同步（不讨论） 购物车于订单间关系（不讨论） ​ 提交购物车：读取数据生成订单 ​ 商家临时价格调整：隶属于订单级别 未登录用户购物车信息存储（不讨论） cookie存储 解决方案 以客户id作为key，每位客户创建一个hash存储结构存储对应的购物车信息 将商品编号作为field，购买数量作为value进行存储 添加商品：追加全新的field与value 浏览：遍历hash 更改数量：自增/自减，设置value值 删除商品：删除field 清空：删除key 此处仅讨论购物车中的模型设计 购物车与数据库间持久化同步、购物车与订单间关系、未登录用户购物车信息存储不进行讨论 当前设计是否加速了购物车的呈现 当前仅仅是将数据存储到了redis中，并没有起到加速的作用，商品信息还需要二次查询数据库 每条购物车中的商品记录保存成两条field field1专用于保存购买数量 ​ 命名格式：商品id:nums ​ 保存数据：数值 field2专用于保存购物车中显示的信息，包含文字描述，图片地址，所属商家信息等 (提升：独立hash，不同用户购买的商品信息可能相同。) ​ 命名格式：商品id:info ​ 保存数据：json 12hsetnx key field value#如果当前key中对象field有值就什么都不做，如果没有则加载。 Tips 4： redis 应用于购物车数据存储设计 业务场景 双11活动日，销售手机充值卡的商家对移动、联通、电信的30元、50元、100元商品推出抢购活动，每种商品抢购上限1000张 解决方案 以商家id作为key 将参与抢购的商品id作为field 将参与抢购的商品数量作为对应的value 抢购时使用降值的方式控制产品数量 实际业务中还有超卖等实际问题，这里不做讨论 Tips 5： redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计 业务场景 string存储对象（json）与hash存储对象区别：string讲究整体性，读操作为主，hash操作更新更灵活一些。 原则上：redis只做数据提供和保存，尽量不要使用业务压到redis上， 如判断是否存在。 listlist 类型 数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分 需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序 list类型：保存多个数据，底层使用双向链表存储结构实现 list 类型数据基本操作 添加/修改数据 12lpush key value1 [value2] ……rpush key value1 [value2] …… 获取数据 1234lrange key start stop #start stop为索引 # 倒数第一个为-1 如 lrange 0 -1lindex key indexllen key 获取并移除数据 12lpop keyrpop key list 类型数据扩展操作 规定时间内获取并移除数据（可以等待，可以从若干个列表中取） 123blpop key1 [key2] timeoutbrpop key1 [key2] timeoutbrpoplpush source destination timeout 业务场景 微信朋友圈点赞，要求按照点赞顺序显示点赞好友信息 如果取消点赞，移除对应好友信息 解决方案 移除指定数据（count为移除的数目） 1lrem key count value Tips 6： redis 应用于具有操作先后顺序的数据控制 list 类型数据操作注意事项 list中保存的数据都是string类型的，数据总容量是有限的，最多2 ^ 23 - 1 个元素 (4294967295)。 list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作 获取全部数据操作结束索引设置为-1 list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载 list 类型应用场景业务场景 twitter、新浪微博、腾讯微博中个人用户的关注列表需要按照用户的关注顺序进行展示，粉丝列表需要将最近关注的粉丝列在前面 新闻、资讯类网站如何将最新的新闻或资讯按照发生的时间顺序展示？ 企业运营过程中，系统将产生出大量的运营数据，如何保障多台服务器操作日志的统一顺序输出？ 解决方案 依赖list的数据具有顺序的特征对信息进行管理 使用队列模型解决多路信息汇总合并的问题 使用栈模型解决最新消息的问题 Tips 7： redis 应用于最新消息展示 setset 类型 新的存储需求：存储大量的数据，在查询方面提供更高的效率 需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询 set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的 set 类型数据的基本操作 添加数据 1sadd key member1 [member2] 获取全部数据 1smembers key 删除数据 1srem key member1 [member2] 获取集合数据总量 1scard key 判断集合中是否包含指定数据 1sismember key member set 类型数据的扩展操作业务场景 每位用户首次使用今日头条时会设置3项爱好的内容，但是后期为了增加用户的活跃度、兴趣点，必须让用户对其他信息类别逐渐产生兴趣，增加客户留存度，如何实现？ 业务分析 系统分析出各个分类的最新或最热点信息条目并组织成set集合 随机挑选其中部分信息 配合用户关注信息分类中的热点信息组织成展示的全信息集合 解决方案 随机获取集合中指定数量的数 1srandmember key [count] 随机获取集合中的某个数据并将该数据移出集合 1spop key [count] Tips 8： redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等 业务场景 脉脉为了促进用户间的交流，保障业务成单率的提升，需要让每位用户拥有大量的好友，事实上职场新人不具有更多的职场好友，如何快速为用户积累更多的好友？ 新浪微博为了增加用户热度，提高用户留存性，需要微博用户在关注更多的人，以此获得更多的信息或热门话题，如何提高用户关注他人的总量？ QQ新用户入网年龄越来越低，这些用户的朋友圈交际圈非常小，往往集中在一所学校甚至一个班级中，如何帮助用户快速积累好友用户带来更多的活跃度？ 微信公众号是微信信息流通的渠道之一，增加用户关注的公众号成为提高用户活跃度的一种方式，如何帮助用户积累更多关注的公众号？ 美团外卖为了提升成单量，必须帮助用户挖掘美食需求，如何推荐给用户最适合自己的美食？ 解决方案 求两个集合的交、并、差集 123sinter key1 [key2] sunion key1 [key2] sdiff key1 [key2] 求两个集合的交、并、差集并存储到指定集合中 123sinterstore destination key1 [key2] sunionstore destination key1 [key2] sdiffstore destination key1 [key2] 将指定数据从原始集合中移动到目标集合中 1smove source destination member Tips 9： redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索 显示共同关注（一度） 显示共同好友（一度） 由用户A出发，获取到好友用户B的好友信息列表（一度） 由用户A出发，获取到好友用户B的购物清单列表（二度） 由用户A出发，获取到好友用户B的游戏充值列表（二度） set 类型数据操作的注意事项 set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份 set 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间 set 类型应用场景业务场景 集团公司共具有12000名员工，内部OA系统中具有700多个角色，3000多个业务操作，23000多种数据，每位员工具有一个或多个角色，如何快速进行业务操作的权限校验？ 业务场景 公司对旗下新的网站做推广，统计网站的PV（访问量）,UV（独立访客）,IP（独立IP）。 PV：网站被访问次数，可通过刷新页面提高访问量 UV：网站被不同用户访问的次数，可通过cookie统计访问量，相同用户切换IP地址，UV不变 IP：网站被不同IP地址访问的总次数，可通过IP地址统计访问量，相同IP不同用户访问，IP不变 解决方案 利用set集合的数据去重特征，记录各种访问数据 建立string类型数据，利用incr统计日访问量（PV） 建立set模型，记录不同cookie数量（UV） 建立set模型，记录不同IP数量（IP） Tips 11： redis 应用于同类型数据的快速去重 业务场景 黑名单 ​ 资讯类信息类网站追求高访问量，但是由于其信息的价值，往往容易被不法分子利用，通过爬虫技术，快速获取信息，个别特种行业网站信息通过爬虫获取分析后，可以转换成商业机密进行出售。例如第三方火车票、机票、酒店刷票代购软件，电商刷评论、刷好评。 ​ 同时爬虫带来的伪流量也会给经营者带来错觉，产生错误的决策，有效避免网站被爬虫反复爬取成为每个网站都要考虑的基本问题。在基于技术层面区分出爬虫用户后，需要将此类用户进行有效的屏蔽，这就是黑名单的典型应用。 ​ ps:不是说爬虫一定做摧毁性的工作，有些小型网站需要爬虫为其带来一些流量。 白名单 ​ 对于安全性更高的应用访问，仅仅靠黑名单是不能解决安全问题的，此时需要设定可访问的用户群体，依赖白名单做更为苛刻的访问验证。 解决方案 基于经营战略设定问题用户发现、鉴别规则 周期性更新满足规则的用户黑名单，加入set集合 用户行为信息达到后与黑名单进行比对，确认行为去向 黑名单过滤IP地址：应用于开放游客访问权限的信息源 黑名单过滤设备信息：应用于限定访问设备的信息源 黑名单过滤用户：应用于基于访问权限的信息源 Tips 12： redis 应用于基于黑名单与白名单设定的服务控制 sorted_setsorted_set 类型 新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式 需要的存储结构：新的存储模型，可以保存可排序的数据 sorted_set类型：在set的存储结构基础上添加可排序字段 sorted_set 类型数据的基本操作 添加数据 1234zadd key score1 member1 [score2 member2]#注意score在前zadd scores 100 zszadd scores 34 gf 获取全部数据 12zrange key start stop [WITHSCORES]zrevrange key start stop [WITHSCORES] #反转 删除数据 1zrem key member [member ...] 按条件获取数据 1234zrangebyscore key min max [WITHSCORES] [LIMIT]zrangebyscore scores 50 99 withscores linmit 0 3 #查询结果的0 1 2数据zrevrangebyscore key max min [WITHSCORES] 条件删除数据 12zremrangebyrank key start stop zremrangebyscore key min max 注意： min与max用于限定搜索查询的条件 start与stop用于限定查询范围，作用于索引，表示开始和结束索引 offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量 获取集合数据总量 12zcard keyzcount key min max 集合交、并操作 123zinterstore destination numkeys key [key ...] #numkeys为集合个数，求交集时score会求和，也可以改为求最小最大zunionstore destination numkeys key [key ...] sorted_set 类型数据的扩展操作业务场景 票选广东十大杰出青年，各类综艺选秀海选投票 各类资源网站TOP10（电影，歌曲，文档，电商，游戏等） 聊天室活跃度统计 游戏好友亲密度 业务分析 为所有参与排名的资源建立排序依据 解决方案 score值获取与修改 12zrank key member zrevrank key member 获取数据对应的索引（排名） 12zscore key member zincrby key increment member Tips 13： redis 应用于计数器组合排序功能对应的排名 sorted_set 类型数据操作的注意事项 score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992 score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时候要慎重 sorted_set 底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据，score值将被反复覆盖，保留最后一次修改的结果 sorted_set 类型应用场景业务场景 ​ 基础服务+增值服务类网站会设定各位会员的试用，让用户充分体验会员优势。例如观影试用VIP、游戏VIP体验、云盘下载体验VIP、数据查看体验VIP。当VIP体验到期后，如果有效管理此类信息。即便对于正式VIP用户也存在对应的管理方式。 ​ 网站会定期开启投票、讨论，限时进行，逾期作废。如何有效管理此类过期信息。 解决方案 对于基于时间线限定的任务处理，将处理时间记录为score值，利用排序功能区分处理的先后顺序 记录下一个要处理的时间，当到期后处理对应任务，移除redis中的记录，并记录下一个要处理的时间 当新任务加入时，判定并更新当前下一个要处理的任务时间 为提升sorted_set的性能，通常将任务根据特征存储成若干个sorted_set。例如1小时内，1天内，周内，月内，季内，年度等，操作时逐级提升，将即将操作的若干个任务纳入到1小时内处理的队列中 获取当前系统时间 1time Tips 14： redis 应用于定时任务执行顺序管理或任务过期管理 业务场景 任务/消息权重设定应用 当任务或者消息待处理，形成了任务队列或消息队列时，对于高优先级的任务要保障对其优先处理，如何实现任务权重管理。 解决方案 对于带有权重的任务，优先处理权重高的任务，采用score记录权重即可 多条件任务权重设定 ​ 如果权重条件过多时，需要对排序score值进行处理，保障score值能够兼容2条件或者多条件，例如外贸订单优先于国内订单，总裁订单优先于员工订单，经理订单优先于员工订单 因score长度受限，需要对数据进行截断处理，尤其是时间设置为小时或分钟级即可（折算后） 先设定订单类别，后设定订单发起角色类别，整体score长度必须是统一的，不足位补0。第一排序规则首位不得是0 例如外贸101，国内102，经理004，员工008。 员工下的外贸单score值为101008（优先） 经理下的国内单score值为102004 Tips 15： redis 应用于即时任务/消息队列执行管理 数据类型实践案例业务场景人工智能领域的语义识别与自动对话将是未来服务业机器人应答呼叫体系中的重要技术，百度自研用户评价语义识别服务，免费开放给企业试用，同时训练百度自己的模型。现对试用用户的使用行为进行限速，限制每个用户每分钟最多发起10次调用 解决方案 设计计数器，记录调用次数，用于控制业务执行次数。以用户id作为key，使用次数作为valu 在调用前获取次数，判断是否超过限定次数 ​ 不超过次数的情况下，每次调用计数+1 ​ 业务调用失败，计数-1 为计数器设置生命周期为指定周期，例如1秒/分钟，自动清空周期内使用次数 解决方案改良 取消最大值的判定，利用incr操作超过最大值抛出异常的形式替代每次判断是否大于最大值 判断是否为nil， ​ 如果是，设置为Max-次数 ​ 如果不是，计数+1 ​ 业务调用失败，计数-1 遇到异常即+操作超过上限，视为使用达到上限 Tips 16： edis 应用于限时按次结算的服务控制 业务场景使用微信的过程中，当微信接收消息后，会默认将最近接收的消息置顶，当多个好友及关注的订阅号同时发送消息时，该排序会不停的进行交替。同时还可以将重要的会话设置为置顶。一旦用户离线后，再次打开微信时，消息该按照什么样的顺序显示？ 业务分析 解决方案 依赖list的数据具有顺序的特征对消息进行管理，将list结构作为栈使用 对置顶与普通会话分别创建独立的list分别管理 当某个list中接收到用户消息后，将消息发送方的id从list的一侧加入list（此处设定左侧） 多个相同id发出的消息反复入栈会出现问题，在入栈之前无论是否具有当前id对应的消息，先删除对应id 推送消息时先推送置顶会话list，再推送普通会话list，推送完成的list清除所有数据 消息的数量，也就是微信用户对话数量采用计数器的思想另行记录，伴随list操作同步更新 Tips 17： redis 应用于基于时间顺序的数据操作，而不关注具体时间 解决方案列表 Tips 1：redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性 Tips 2：redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作 Tips 3：redis应用于各种结构型和非结构型高热度数据访问加速 Tips 4：redis 应用于购物车数据存储设计 Tips 5：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计 Tips 6：redis 应用于具有操作先后顺序的数据控制 Tips 7：redis 应用于最新消息展示 Tips 8：redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等 Tips 9：redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索 Tips 10：redis 应用于同类型不重复数据的合并、取交集操作 Tips 11：redis 应用于同类型数据的快速去重 Tips 12：redis 应用于基于黑名单与白名单设定的服务控制 Tips 13：redis 应用于计数器组合排序功能对应的排名 Tips 14：redis 应用于定时任务执行顺序管理或任务过期管理 Tips 15：redis 应用于及时任务/消息队列执行管理 Tips 16：redis 应用于按次结算的服务控制 Tips 17：redis 应用于基于时间顺序的数据操作，而不关注具体时间","categories":[],"tags":[{"name":"黑马程序员","slug":"黑马程序员","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"SpringBoot_day02","slug":"黑马程序员/Spring_boot/SpringBoot_day02","date":"2021-08-01T13:55:34.000Z","updated":"2021-08-03T08:37:16.457Z","comments":true,"path":"2021/08/01/黑马程序员/Spring_boot/SpringBoot_day02/","link":"","permalink":"http://example.com/2021/08/01/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/Spring_boot/SpringBoot_day02/","excerpt":"","text":"SpringBoot 原理分析SpringBoot自动配置Condition是在 Spring 4.0 增加的条件判断功能，通过这个可以功能可以实现选择性的创建 Bean 操作。 SpringBoot是如何知道要创建哪个 Bean 的？比如 SpringBoot 是如何知道要创建 RedisTemplate 的？ 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 12345678910@SpringBootApplicationpublic class Test1Application &#123; public static void main(String[] args) &#123; //启动SpringBoot的应用，返回Spring的IOC容器 ConfigurableApplicationContext context = SpringApplication.run(Test1Application.class, args); //获取Bean，redisTemplate Object redisTemplate = context.getBean(&quot;redisTemplate&quot;); System.out.println(redisTemplate); &#125;&#125; Spring会根据Condition判断有没有redis对应的字节码文件，有就创建Bean。 案例：需求在Spring 的 IOC 容器中有一个 User 的 Bean ，现要求 导入 Jedis 坐标后，加载该 Bean ，没导入，则不加载。 将类的判断定义为动态的。判断哪个字节码文件存在可以动态指定。 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt; 123456789101112131415//注意实现的是spirngframework.context.annotation包下的条件接口public class ClassCondition implements Condition &#123; @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; //导入 Jedis 坐标后，加载该 Bean，否则不会创建该bean，并会抛出异常 //判断：redis.clients.jedis.Jedis文件是否存在 try &#123; Class&lt;?&gt; aClass = Class.forName(&quot;redis.clients.jedis.Jedis&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); return false; &#125; return true; &#125;&#125; 12345678@Configurationpublic class UserConfig &#123; @Bean @Conditional(ClassCondition.class) public User user()&#123; return new User(); &#125;&#125; 12345678910@SpringBootApplicationpublic class Test1Application &#123; public static void main(String[] args) &#123; //启动SpringBoot的应用，返回Spring的IOC容器 ConfigurableApplicationContext context = SpringApplication.run(Test1Application.class, args); Object user = context.getBean(&quot;user&quot;); System.out.println(user); &#125;&#125; 将类的判断设置为动态的 12345678910111213141516171819202122232425//注意实现的是spirngframework.context.annotation包下的条件接口public class ClassCondition implements Condition &#123; /** * * @param conditionContext 上下文对象。用于获取环境，IOC容器，ClassLoader对象 * @param annotatedTypeMetadata 注解元对象。可以用于获取注解定义的属性值。 * @return */ @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; //导入 Jedis 坐标后，加载该 Bean //判断：redis.clients.jedis.Jedis文件是否存在 Map&lt;String, Object&gt; map = annotatedTypeMetadata.getAnnotationAttributes(ConditionOnClass.class.getName()); String[] value = (String[])map.get(&quot;value&quot;); try &#123; for(String className : value)&#123; Class&lt;?&gt; aClass = Class.forName(className); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); return false; &#125; return true; &#125;&#125; 1234567@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional(ClassCondition.class)public @interface ConditionOnClass &#123; String[] value();&#125; 123456789101112131415@Configurationpublic class UserConfig &#123; @Bean// @Conditional(ClassCondition.class) @ConditionOnClass(&quot;redis.clients.jedis.Jedis&quot;) public User user()&#123; return new User(); &#125; @Bean @ConditionalOnProperty(name = &quot;itcast&quot;,havingValue = &quot;itheima&quot;) public User user2()&#123; return new User(); &#125;&#125; 12#application.propertiesitcast=itheima 123456789101112@SpringBootApplicationpublic class Test1Application &#123; public static void main(String[] args) &#123; //启动SpringBoot的应用，返回Spring的IOC容器 ConfigurableApplicationContext context = SpringApplication.run(Test1Application.class, args); Object user1 = context.getBean(&quot;user&quot;); Object user2 = context.getBean(&quot;user2&quot;); System.out.println(user1); System.out.println(user2); &#125;&#125; Condition小结 自定义条件： 定义条件类：自定义类实现 Condition 接口，重写 matches 方法，在 matches 方法中进行逻辑判断，返回boolean 值 。 matches 方法两个参数： context ：上下文对象，可以获取属性值，获取类加载器，获取 BeanFactory 等。 metadata ：元数据对象，用于获取注解属性。 判断条件： 在初始化 Bean 时，使用 @Conditional 条件类 class 注解 SpringBoot 提供的常用条件注解：• ConditionalOnProperty 判断配置文件中是否有对应属性和值才初始化 Bean• ConditionalOnClass 判断环境中是否有对应字节码文件才初始化 Bean• ConditionalOnMissingBean 判断环境中没有对应 Bean 才初始化 Bean 切换内置web 服务器SpringBoot的 web 环境中默认使用 tomcat 作为内置服务器，其实 SpringBoot 提供了 4 中内置服务器供我们选择，我们可以很方便的进行切换。Jetty，Netty，Tomcat，Undertow。 引入web环境依赖，会自动加入tomcat服务器。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 更改为使用Jetty服务器。 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--排除tomcat依赖--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入jetty的依赖--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; @Enable注解SpringBoot中提供了很多 Enable 开头的注解，这些注解都是用于动态启用某些功能的。而其底层原理是使用 @Import 注解导入一些配置类，实现 Bean 的动态加载。 SpringBoot工程是否可以直接获取 jar 包（第三方）中定义的 Bean? 不可以 other模块中： 1234package com.itheima.domain;public class User &#123;&#125; 1234567891011121314package com.itheima.config;import com.itheima.domain.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class UserConfig &#123; @Bean public User user() &#123; return new User(); &#125;&#125; Enable模块中内容： 获取另外一模块内容， 12345&lt;dependency&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;springboot-enable-other&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819202122232425262728293031323334package com.itheima.springbootenable;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.Bean;import redis.clients.jedis.Jedis;import java.util.Map;/** * @ComponentScan 扫描范围：当前引导类所在包及其子包 * * com.itheima.springbootenable * com.itheima.config * //1.使用@ComponentScan扫描com.itheima.config包 * //2.可以使用@Import注解，加载类。这些类都会被Spring创建，并放入IOC容器 * //3.可以对Import注解进行封装。 */@SpringBootApplication//@ComponentScan(&quot;com.itheima.config&quot;)//@Import(UserConfig.class)@EnableUserpublic class SpringbootEnableApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(SpringbootEnableApplication.class, args); //获取Bean Object user = context.getBean(&quot;user&quot;); System.out.println(user); &#125;&#125; 12345678910111213//使用注解需要在other模块下建立此注解。package com.itheima.config;import org.springframework.context.annotation.Import;import java.lang.annotation.*;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(UserConfig.class)public @interface EnableUser &#123;&#125; @Import注解@Enable 底层依赖于 @Import 注解导入一些类，使用 @Import 导入的类会被 Spring 加载到 IOC 容器中。而 @Import 提供 4 种用法: 导入 Bean 导入配置类 导入 ImportSelector 实现类。一般用于加载配置文件中的类 导入 ImportBeanDefinitionRegistrar 实现类。 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.springbootenable;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.Bean;import redis.clients.jedis.Jedis;import java.util.Map;/** * Import4中用法： * 1. 导入Bean * 2. 导入配置类 * 3. 导入ImportSelector的实现类。 * 4. 导入ImportBeanDefinitionRegistrar实现类 *///@Import(User.class)//@Import(UserConfig.class)//@Import(MyImportSelector.class)//@Import(&#123;MyImportBeanDefinitionRegistrar.class&#125;)@SpringBootApplicationpublic class SpringbootEnableApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(SpringbootEnableApplication.class, args); User user = context.getBean(User.class); System.out.println(user); Role role = context.getBean(Role.class); System.out.println(role); /* Map&lt;String, User&gt; map = context.getBeansOfType(User.class); System.out.println(map);*/ /* Object user = context.getBean(&quot;user&quot;); System.out.println(user); //第四种方法，起的名称叫做user */ &#125;&#125; 12345678910111213141516171819package com.itheima.config;import com.itheima.domain.Role;import com.itheima.domain.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;//@Configuration//使用import导入类，可以省略该注解public class UserConfig &#123; @Bean public User user() &#123; return new User(); &#125; @Bean public Role role() &#123; return new Role(); &#125;//role和user一样，就是个domain包下的类&#125; 第三种方式：other模块中 123456789101112package com.itheima.config;import org.springframework.context.annotation.ImportSelector;import org.springframework.core.type.AnnotationMetadata;public class MyImportSelector implements ImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[]&#123;&quot;com.itheima.domain.User&quot;, &quot;com.itheima.domain.Role&quot;&#125;; //字符串可以从配置文件中获取。 &#125;&#125; 第四种方式：other模块中 12345678910111213141516package com.itheima.config;import com.itheima.domain.User;import org.springframework.beans.factory.support.AbstractBeanDefinition;import org.springframework.beans.factory.support.BeanDefinitionBuilder;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;import org.springframework.core.type.AnnotationMetadata;public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(User.class).getBeanDefinition(); registry.registerBeanDefinition(&quot;user&quot;, beanDefinition); &#125;&#125; @EnableAutoConfiguration注解 @EnableAutoConfiguration（位于@SpringApplicaton中） 注解内部使用 @Import(AutoConfigurationImportSelector.class) 来加载配置类。 配置文件位置： META INF/spring.factories ，该配置文件中定义了大量的配置类，当 SpringBoot 应用启动时，会自动加载这些配置类，初始化 Bean 并不是所有的 Bean 都会被初始化，在配置类中使用 Condition 来加载满足条件的 Bean 依赖可以在mvnrepository.com网站搜索如使用mybatis 可以搜索 mybatis spring-boot。 123456&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--第三方提供的依赖会把名字放前面--&gt; 案例：需求 自定义redis starter 。要求当导入 redis 坐标时， SpringBoot 自动创建 Jedis 的 Bean 案例：实现步骤 创建 redis spring boot autoconfigure 模块 创建 redis spring boot starter 模块 依赖 redis springboot autoconfigure 的模块 在 redis spring boot autoconfigure 模块中初始化 Jedis 的Bean 。并定义 META INF/ spring.factories 文件 在测试模块中引入自定义的 redis starter 依赖，测试获取Jedis 的 Bean ，操作 redis 。 创建redis-spring-boot-autoconfigure模块（包名为configure） 引入jedis依赖 1234&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt; 新建核心配置类 123456789101112131415161718192021222324package com.itheima.redis.config;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import redis.clients.jedis.Jedis;@Configuration@EnableConfigurationProperties(RedisProperties.class)//使RedisProperties类被spring识别@ConditionalOnClass(Jedis.class)//Jedis在的时候才会加载Beanpublic class RedisAutoConfiguration &#123; /** * 提供Jedis的bean */ @Bean @ConditionalOnMissingBean(name = &quot;jedis&quot;)//如果没有叫做jedis的Bean才会加载 public Jedis jedis(RedisProperties redisProperties) &#123; System.out.println(&quot;RedisAutoConfiguration....&quot;); return new Jedis(redisProperties.getHost(), redisProperties.getPort()); &#125;&#125; 新建实体类 将实体类于配置文件相绑定 12345678910package com.itheima.redis.config;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = &quot;redis&quot;)public class RedisProperties &#123; private String host = &quot;localhost&quot;; private int port = 6379; //getter setter方法&#125; 在resources目录下新建META-INF/spring.factories文件 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.itheima.redis.config.RedisAutoConfiguration 创建redis-spring-boot-starter模块（包名为redis） 引入依赖 123456&lt;!--引入configure--&gt;&lt;dependency&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;redis-spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 使用enable模块 引入自定义的模块依赖 123456&lt;!--自定义的redis的starter--&gt;&lt;dependency&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;redis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627package com.itheima.springbootenable;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.Bean;import redis.clients.jedis.Jedis;import java.util.Map;@SpringBootApplicationpublic class SpringbootEnableApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(SpringbootEnableApplication.class, args); Jedis jedis = context.getBean(Jedis.class); System.out.println(jedis); jedis.set(&quot;name&quot;,&quot;itcast&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); &#125;//会打印RedisAutoConfiguration.... @Bean public Jedis jedis()&#123; return new Jedis(&quot;localhost&quot;,6379); &#125;//不会打印RedisAutoConfiguration.... ，证明ConditionalOnMissingBean生效&#125; 新建application.properties 12redis.port=6666#链接会失败，证明生效 SpringBoot监听机制Java的监听机制SpringBoot监听机制，其实是对 Java 提供的事件监听机制的封装。Java中的事件监听机制定义了以下几个角色： 事件： Event ，继承 java.util.EventObject 类的对象 事件源： Source ，任意对象 Object 监听器： Listener ，实现 java.util.EventListener 接口 的对象 SpringBoot监听机制SpringBoot在项目启动时，会对几个监听器进行回调，我们可以实现这些监听器接口，在项目启动时完成一些操作。ApplicationContextInitializer、 SpringApplicationRunListener 、 CommandLineRunner 、ApplicationRunner 前两个类想要生效需要先配置META-INF/spring.factories文件 123org.springframework.context.ApplicationContextInitializer=com.itheima.springbootlistener.listener.MyApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=com.itheima.springbootlistener.listener.MySpringApplicationRunListener 新建MyApplicationContextInitializer类 1234567891011121314package com.itheima.springbootlistener.listener;import org.springframework.context.ApplicationContextInitializer;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.stereotype.Component;@Componentpublic class MyApplicationContextInitializer implements ApplicationContextInitializer &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println(&quot;ApplicationContextInitializer....initialize&quot;); //可以用于项目还没有准备IOC容器之前检测一些资源是否存在。 &#125;&#125; 新建MySpringApplicationRunListener类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.springbootlistener.listener;import org.springframework.boot.SpringApplication;import org.springframework.boot.SpringApplicationRunListener;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.core.env.ConfigurableEnvironment;import org.springframework.stereotype.Component;public class MySpringApplicationRunListener implements SpringApplicationRunListener &#123; //SpringApplication 为项目启动时 事件源，可以产生很多生命周期事件 该构造不能省略 public MySpringApplicationRunListener(SpringApplication application, String[] args) &#123; &#125; @Override public void starting() &#123; System.out.println(&quot;starting...项目启动中&quot;); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; System.out.println(&quot;environmentPrepared...环境对象开始准备&quot;); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println(&quot;contextPrepared...上下文对象开始准备&quot;); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println(&quot;contextLoaded...上下文对象开始加载&quot;); &#125; @Override public void started(ConfigurableApplicationContext context) &#123; System.out.println(&quot;started...上下文对象加载完成&quot;); &#125; @Override public void running(ConfigurableApplicationContext context) &#123; System.out.println(&quot;running...项目启动完成，开始运行&quot;); &#125; @Override public void failed(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println(&quot;failed...项目启动失败&quot;); &#125;&#125; 新建MyCommandLineRunner类 12345678910111213141516package com.itheima.springbootlistener.listener;import org.springframework.boot.CommandLineRunner;import org.springframework.stereotype.Component;import java.util.Arrays;@Componentpublic class MyCommandLineRunner implements CommandLineRunner &#123; //与下面那种用法基本相同 @Override public void run(String... args) throws Exception &#123; System.out.println(&quot;CommandLineRunner...run&quot;); System.out.println(Arrays.asList(args)); &#125;&#125; 新建MyApplicationRunner类 1234567891011121314151617181920package com.itheima.springbootlistener.listener;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.stereotype.Component;import java.util.Arrays;/** * 当项目启动后执行run方法。可以执行缓存预热，如让redis在项目启动时把数据库信息提前加载到缓存， * 防止第一个人查询时缓存里没有数据 */@Componentpublic class MyApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(&quot;ApplicationRunner...run&quot;); System.out.println(Arrays.asList(args.getSourceArgs())); &#125;&#125; SpringBoot 启动流程分析启动流程 Spring Boot 监控SpringBoot监控概述SpringBoot自带监控功能 Actuator ，可以帮助实现对程序内部运行情况监控，比如监控状况、 Bean 加载情况、配置属性、日志信息等。 SpringBoot监控使用使用步骤 导入依赖坐标 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--在Ops中可以直接勾选--&gt; 访问 http://localhost:8080/acruator 路径 描述 /beans 描述应用程序上下文里全部的Bean，以及它们的关系 /env 获取全部环境属性 /env/{name} 根据名称获取特定的环境属性值 /health 报告应用程序的健康指标，这些值由HealthIndicator的实现类提供 /info 获取应用程序的定制信息，这些信息由info打头的属性提供（配置文件中） /mappings 描述全部的URI路径，以及它们和控制器(包含Actuator端点)的映射关系 /metrics 报告各种应用程序度量信息，比如内存用量和HTTP请求计数 /metrics/{name} 报告指定名称的应用程序度量值 /trace 提供基本的HTTP请求跟踪信息(时间戳、HTTP头等) application.properties 12345678info.name=zhangsaninfo.age=22#开启健康检查的完整信息，为了安全默认为关闭，有up和 down两种状态management.endpoint.health.show-details=always#将web的所有的监控endpoint暴露出来management.endpoints.web.exposure.include=* SpringBoot监控 Spring Boot Admin Spring Boot Admin 是一个开源社区项目，用于管理和监控 SpringBoot 应用程序。 Spring Boot Admin 有两个角色，客户端 ( 和服务端 ）。 应用程序作为 Spring Boot Admin Client 向为 Spring Boot Admin Server 注册 Spring Boot Admin Server 的 UI 界面将 Spring Boot Admin Client 的 Actuator Endpoint 上的一些监控信息。 使用步骤 admin-server（可以监控多个client模块） 创建 admin server 模块 导入依赖坐标spring-boot-admin-starter-server 和web模块 在引导类上启用监控功能 EnableAdminServer 12345678@EnableAdminServer@SpringBootApplicationpublic class SpringbootAdminServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootAdminServerApplication.class, args); &#125;&#125; 两个项目在一个地址，端口都是8080会重复，为方便，更改下端口 新建application.properties文件 1server.port=9000 admin-client 创建 admin client 模块 导入依赖坐标spring-boot-admin-starter-client 和web模块 配置相关信息： server 地址等 application.properties文件 1234# 执行admin.server地址spring.boot.admin.client.url=http://localhost:9000management.endpoint.health.show-details=alwaysmanagement.endpoints.web.exposure.include=* 启动 server 和 client 服务，访问 server（localhost:9000） SpringBoot 项目部署SpringBoot项目部署SpringBoot项目开发完毕后，支持两种方式部署到服务器： jar 包 官方推荐 创建deploy模块，导入web依赖，新建一个Controller类 12345678@RequestMapping(&quot;/user&quot;)@RestControllerpublic class UserController &#123; @RequestMapping(&quot;/findAll&quot;) public String findAll()&#123; return &quot;succcess&quot;; &#125;&#125; 使用在Maven Project中点击package打为jar包（默认极为打为jar包） 将jar包放在服务器 执行java -jar .\\*.jar即可 war 包 更改项目中的pom文件&lt;packaging&gt;war&lt;/packaging&gt; 更改引导类继承SpringBootServletInitializer类，重写configure方法。 12345678910@SpringBootApplicationpublic class SpringbootDeployApplication extends SpringBootServletInitializer &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootDeployApplication.class, args); &#125; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; return builder.sources(SpringbootDeployApplication.class); &#125;&#125; 将war包放在tomcat的webapps目录下，启动Tomcat即可。 访问地址为localhost:8080/springboot/user/findAll,spirngboot为war包名称，也是在tomcat中的虚拟目录。 内置更改的端口号也不会生效，这时更改端口号需要在Tomcat的外置配置文件中更改。","categories":[],"tags":[{"name":"黑马程序员 springboot","slug":"黑马程序员-springboot","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot/"}]},{"title":"01_redis入门","slug":"黑马程序员/redis/01_redis入门","date":"2021-07-31T08:47:55.000Z","updated":"2021-08-04T03:07:59.068Z","comments":true,"path":"2021/07/31/黑马程序员/redis/01_redis入门/","link":"","permalink":"http://example.com/2021/07/31/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/01_redis%E5%85%A5%E9%97%A8/","excerpt":"","text":"Redis入门Redis 简介12306 问题现象 海量用户 高并发 罪魁祸首——关系型数据库 性能瓶颈：磁盘IO性能低下 扩展瓶颈：数据关系复杂，扩展性差，不便于大规模集群 解决思路Nosql： 降低磁盘IO次数，越低越好 —— 内存存储 去除数据间关系，越简单越好 —— 不存储关系，仅存储数据 NosqlNoSQL：即 Not-Only SQL（ 泛指非关系型的数据库），作为关系型数据库的补充。 作用：应对基于海量用户和海量数据前提下的数据处理问题。 特征： 可扩容，可伸缩 大数据量下高性能 灵活的数据模型 高可用 常见 Nosql 数据库： Redis memcache HBase MongoDB 解决方案（电商场景） Redis概念：Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。 特征： 数据间没有必然的关联关系 内部采用单线程机制进行工作 高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。 多数据类型支持 字符串类型 string 列表类型 list 散列类型 hash 集合类型 set 有序集合类型 sorted_set 持久化支持。可以进行数据灾难恢复 Redis 的应用 为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息等 任务队列，如秒杀、抢购、购票排队等 即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等 时效性信息控制，如验证码控制、投票控制等 分布式数据共享，如分布式集群架构中的 session 分离 消息队列 分布式锁 Redis 的下载与安装Redis 的下载Linux 版（适用于企业级开发） Redis 高级开始使用 以4.0 版本作为主版本 Windows 版本（适合零基础学习） Redis 入门使用 以 3.2 版本作为主版本 下载地址：https://github.com/MSOpenTech/redis/tags 安装 Redis 启动 Redis服务器启动 端口：6379 PID：随机生成 客户端连接 Redis 的基本操作命令行模式工具使用思考 功能性命令 清除屏幕信息 帮助信息查阅 退出指令 信息添加 功能：设置 key，value 数据 命令 1set key value 范例 1set name itheima 信息查询 功能：根据 key 查询对应的 value，如果不存在，返回空（nil） 命令 1get key 范例 1get name 清除屏幕信息 功能：清除屏幕中的信息 命令 1clear 退出客户端命令行模式 功能：退出客户端 命令 123quit exit &lt;ESC&gt; 帮助 功能：获取命令帮助文档，获取组中所有命令信息名称 命令 12help 命令名称 help @组名 总结Redis 入门 Redis 简介 Redis 的下载与安装 Redis 的基本操作 set/get clear help","categories":[],"tags":[{"name":"黑马程序员","slug":"黑马程序员","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"SpringBoot_day01","slug":"黑马程序员/Spring_boot/SpringBoot_day01","date":"2021-07-30T08:04:16.000Z","updated":"2021-07-30T08:05:50.662Z","comments":true,"path":"2021/07/30/黑马程序员/Spring_boot/SpringBoot_day01/","link":"","permalink":"http://example.com/2021/07/30/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/Spring_boot/SpringBoot_day01/","excerpt":"","text":"SpringBoot 概述SpringBoot 概念SpringBoot提供了一种快速使用Spring的方式，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。2014 年4 月，Spring Boot 1.0.0 发布。Spring的顶级项目之一(https://spring.io)。 Spring 缺点1）配置繁琐 虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。 所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但它要求的回报也不少。 2）依赖繁琐 项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。 SpringBoot 功能1）自动配置 Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是SpringBoot自动完成的。 2）起步依赖 起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。 3）辅助功能 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等。 Spring Boot 并不是对Spring 功能上的增强，而是提供了一种快速使用Spring 的方式。 小结SpringBoot提供了一种快速开发Spring项目的方式，而不是对Spring功能上的增强。 Spring的缺点： 配置繁琐 依赖繁琐 SpringBoot功能： 自动配置 起步依赖：依赖传递 辅助功能 SpringBoot 快速入门案例：需求 搭建SpringBoot工程，定义HelloController.hello()方法，返回”Hello SpringBoot!”。 案例：实现步骤 ①创建Maven项目②导入SpringBoot起步依赖③定义Controller④编写引导类⑤启动测试 步骤 新建maven项目（不适用模板） pom.xml文件中引入依赖，在官方文档中寻找Getting Started，将parent和denpendencies内容复制到pom.xml文件中12345678910111213141516171819&lt;!--springboot工程需要继承的父工程--&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt; &lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--功能：写配置文件的时候会给提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编写controller 12345678@RestController//@RestController注解相当于@ResponseBody ＋ @Controllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello Spring Boot&quot;; &#125;&#125; 编写引导类12345678/*** 引导类 一般以Application结尾, SpringBoot项目的入口*/public class HelloApplication&#123; public static void main(String[] args)&#123; SpringApplication.run(HelloApplication.class, args); &#125;&#125; 运行 访问 localhost:8080/hello即可 小结 SpringBoot在创建项目时，使用jar的打包方式。 SpringBoot的引导类，是项目入口，运行main方法就可以启动项目。 使用SpringBoot和Spring构建的项目，业务代码编写方式完全一样。 案例：需求 使用idea搭建SpringBoot工程，定义HelloController.hello()方法，返回”Hello SpringBoot!”。 案例：步骤 新建Spring Initializr项目（需要联网） 选择依赖 点击web，勾选Spring Web 编写Controller类1234567@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello Spring Boot&quot;; &#125;&#125; 启动 SpringBoot 起步依赖原理分析起步依赖原理分析 1）spring-boot-starter-parent 2）spring-boot-starter-web 小结 在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。 在各种starter中，定义了完成该功能需要的坐标合集，其中大部分版本信息来自于父工程。 我们的工程继承parent，引入starter后，通过依赖传递，就可以简单方便获得需要的jar包，并且不会存在版本冲突等问题。 SpringBoot 配置配置文件分类SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml（application.yaml）进行配置。 properties： 1server.port=8080 yml: 12server: port: 8080 注意：冒号和8080之间必须有空格。 SpringBoot提供了2种配置文件类型：properteis和yml/yaml 默认配置文件名称：application 在同一级目录下优先级为：properties &gt; yml &gt; yaml YAMLYAML全称是YAML Ain’t Markup Language 。YAML是一种直观的能够被电脑识别的数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，比如：C/C++, Ruby, Python, Java, Perl, C#, PHP等。YML文件是以数据为核心的，比传统的xml方式更加简洁。YAML文件的扩展名可以使用.yml或者.yaml。 properties:12server.port=8080server.address=127.0.0.1 1234&lt;server&gt; &lt;port&gt;8080&lt;/port&gt; &lt;address&gt;127.0.0.1&lt;/address&gt;&lt;/server&gt; 123server: port: 8080 address: 127.0.0.1 简洁，以数据为核心 YAML：基本语法 大小写敏感 数据值前边必须有空格，作为分隔符 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格（各个系统Tab对应的空格数目可能不同，导致层次混乱，idea会自动转换空格）。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 # 表示注释，从这个字符一直到行尾，都会被解析器忽略。 12345server: port: 8080 address: 127.0.0.1name: abc YAML：数据格式 对象(map)：键值对的集合 1234person: name: zhangsan# 行内写法person: &#123;name: zhangsan&#125; 数组：一组按次序排列的值 12345address: -beijing -shanghai# 行内写法address: [beijing,shanghai] 纯量：单个的、不可再分的值 12msg1: &#x27;hello \\n world&#x27; # 单引忽略转义字符，原样输出msg2: &quot;hello \\n world&quot; # 双引识别转义字符 YAML：参数引用1234name: lisiperson: name: $&#123;name&#125; # 引用上边定义的name值 YAML：小结1）配置文件类型 properties：和以前一样 yml/yaml：注意空格 2）yaml：简洁，以数据为核心 基本语法 大小写敏感 数据值前边必须有空格，作为分隔符 使用空格缩进表示层级关系，相同缩进表示同一级 数据格式 对象 数组: 使用“-”表示数组每个元素 纯量 参数引用 ${key} 读取配置内容1）@Value 2）Environment 3）@ConfigurationProperties 123456789101112131415161718@RestControllerpublic class HelloController &#123; @Value(&quot;$&#123;name&#125;&quot;)//要和yml中名字相同 private String name; @Value(&quot;$&#123;person.name&#125;&quot;) private String name2; @Value(&quot;$&#123;person.age&#125;&quot;) private int age; @Value(&quot;$&#123;address[0]&#125;&quot;)//数组 private String address1; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; System.out.println(name); return &quot;hello Spring Boot&quot;; &#125;&#125; 123456789101112@RestControllerpublic class HelloController &#123; @Autowired private Environment env; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; System.out.println(env.getProperty(&quot;person.name&quot;)); System.out.println(env.getProperty(&quot;address[0]&quot;)); return &quot;hello Spring Boot&quot;; &#125;&#125; 12345678910111213141516171819@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String name; private int age; ..getter setter toString方法&#125;@RestControllerpublic class HelloController &#123; @Autowired private Person person; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; System.out.println(person); return &quot;hello Spring Boot&quot;; &#125;&#125; profile我们在开发Spring Boot应用时，通常同一套程序会被安装到不同环境，比如：开发、测试、生产等。其中数据库地址、服务器端口等等配置都不同，如果每次打包时，都要修改配置文件，那么非常麻烦。profile功能就是来进行动态配置切换的。 1）profile配置方式 多profile文件方式（需要在application.properties激活） application-dev.properties 1server.port: 8081 application-test.properties 1server.port: 8082 application-pro.properties 1server.port: 8083 yml多文档方式 application.yml文件内容 1234567891011121314151617181920---server: port: 8081spring: profiles: dev ---server: port: 8082spring: profiles: test---server: port: 8083spring: profiles: pro---#激活spring: profiles: active: dev 2）profile激活方式 配置文件application.properties1spring.profiles.active=dev 虚拟机参数 点击EditConfigutation，配置vm options为 -Dspring.profiles.active=test 命令行参数 点击EditConfigutation，配置Program arguments为 --spring.profiles.active=pro Profile-小结1）profile是用来完成不同环境下，配置动态切换功能的。 2）profile配置方式 多profile文件方式：提供多个配置文件，每个代表一种环境。 application-dev.properties/yml 开发环境 application-test.properties/yml 测试环境 application-pro.properties/yml 生产环境 yml多文档方式： 在yml中使用 --- 分隔不同配置 3）profile激活方式 配置文件：再配置文件中配置：spring.profiles.active=dev 虚拟机参数：在VM options 指定：-Dspring.profiles.active=dev 命令行参数：使用package命令打包，成为jar包后，直接使用命令java –jar xxx.jar --spring.profiles.active=dev 内部配置加载顺序Springboot程序启动时，会从以下位置加载配置文件： file:./config/：当前项目下的/config目录下 file:./ ：当前项目的根目录 classpath:/config/：classpath的/config目录 classpath:/ ：classpath的根目录 加载顺序为上文的排列顺序，高优先级配置的属性会生效 注意：file那两个不符合maven结构不会被打进jar包中，命令行运行不会加载。 外部配置加载顺序通过官网查看外部属性加载顺序： https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html 可以通过命令行更改配置java -jar .\\***.jar --server.port=8082 --server.servlet.context-path=/hehe 也可以通过指定外部文件java -jar .\\***.jar --spring.config.location=e://application.properties jar包也会自动加载同级目录下的application.properties 或config/application.properties文件。 外部配置可以用来在部署时更改内容（已经打成了jar包）。 SpringBoot 整合其他框架案例：需求SpringBoot整合Junit。 案例：实现步骤 搭建SpringBoot工程 引入starter-test起步依赖 编写测试类 添加测试相关注解 @RunWith(SpringRunner.class) @SpringBootTest(classes = 启动类.class) 编写测试方法 123456789101112131415161718192021222324@Servicepublic class UserService&#123; public void add()&#123; System.out.println(&quot;add...&quot;); &#125;&#125;/*** UserService的测试类* 如果测试类是引导类包或者包下的子包，可以省略classes * 如UserServiceTest 在test/java 的 com.itheima.springboottest包下* SpringbootTestApplication在main/java的com.itheima.springboottest包下*/@Runwith(SpringRunner.class)@SpringBootTest(classes = SpringbootTestApplication.class)public class UserServiceTest &#123; @Autowired private UserService userService; @Test public void add()&#123; userService.add(); &#125;&#125; 案例：需求SpringBoot整合Redis。 案例：实现步骤 搭建SpringBoot工程(Nosql) 引入redis起步依赖 spring-boot-starter-data-redis 编写redis相关属性 注入RedisTemplate模板 编写测试方法，测试 1234567891011121314151617181920@Runwith(SpringRunner.class)@SpringBootTestpublic class SpringbootRedisApplicationTests &#123; //redis链接信息默认为本机的ip 6379端口号 @Autowired private RedisTemplate redisTemplate; @Test public void testSet()&#123; //存入数据 redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;zhangsan&quot;); &#125; @Test public void testGet()&#123; //获取数据 Object name = redisTemplate.boundValueOps(&quot;name&quot;).get(); System.out.println(name); &#125;&#125; 12345#application.yml 更改redis ip地址端口号 输入redis会有提示，可以选择spring: redis: host: 127.0.0.1 port: 6379 案例：需求SpringBoot整合MyBatis。 案例：实现步骤 搭建SpringBoot工程(勾选SQL中的MySQL Driver 依赖和 MyBatis Framework依赖) 引入mybatis起步依赖(mybatis-spring-boot-starter,spring-boot 开头的都是spring官方提供的)，添加mysql驱动 mysql-connector-java 编写DataSource和MyBatis相关配置 定义表和实体类 编写dao和mapper文件/纯注解开发 测试 1234567//user实体类public class User &#123; private int id; private String username; private String password; //getter setter toString方法&#125; 123456789#application.xml 需要配置时区，不然会出错spring: datasource: url: jdbc:mysql:///springboot？serverTimezone=UTC driver: com.mysql.jdbc.Driver #会建议使用 com.mysql.cj.jdbc.Driver驱动，上面那个版本太老了。 username: root password: root 123456@Mapper@Repositorypublic interface UserMapper &#123; @Select(&quot;select * from t_user&quot;) public List&lt;User&gt; findAll();&#125; 123456789101112@RunWith(SpringRunner.class)@SpringBootTestpublic class springbootMybatisApplication &#123; @Autowired private UserMapper userMapper; @Test public void testFindAll() &#123; List&lt;User&gt; list = userMapper.findAll(); System.out.println(list); &#125;&#125; 使用xml 新建UserXmlMapper类和UserMapper类基本相同即可 123456&lt;!--还需要一个约束头--&gt;&lt;mapper namespace=&quot;com.itheima.springbootmybatis.mapper.UserXmlMapper&quot;&gt; &lt;select id =&quot;findAll&quot; resultType = &quot;user&quot;&gt; select * from t_user &lt;/select&gt;&lt;/mapper&gt; 12345#application.yml 添加mybatis: mapper-locations: classpath:mapper/*Mapper.xml #mapper映射文件路径 type-aliases-package: com.itheima.springbootmybatis.domain #config-location: #指定mybatis的核心配置文件 稍微更改下测试类运行即可。","categories":[],"tags":[{"name":"黑马程序员 springboot","slug":"黑马程序员-springboot","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot/"}]},{"title":"16_MyBatis注解开发","slug":"黑马程序员/SSM框架/16_MyBatis注解开发","date":"2021-07-28T02:38:21.000Z","updated":"2021-07-28T02:48:32.028Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/16_MyBatis注解开发/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/16_MyBatis%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","excerpt":"","text":"1.Mybatis的注解开发1.1 MyBatis的常用注解这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper 映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。 @Insert：实现新增@Update：实现更新@Delete：实现删除@Select：实现查询@Result：实现结果集封装@Results：可以与@Result 一起使用，封装多个结果集@One：实现一对一结果集封装@Many：实现一对多结果集封装 1.2 MyBatis的增删改查我们完成简单的user表的增删改查的操作 123456789101112131415161718192021222324252627282930313233343536373839404142private UserMapper userMapper;@Beforepublic void before() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); userMapper = sqlSession.getMapper(UserMapper.class);&#125;@Testpublic void testAdd() &#123; User user = new User(); user.setUsername(&quot;测试数据&quot;); user.setPassword(&quot;123&quot;); user.setBirthday(new Date()); userMapper.add(user);&#125;@Testpublic void testUpdate() throws IOException &#123; User user = new User(); user.setId(16); user.setUsername(&quot;测试数据修改&quot;); user.setPassword(&quot;abc&quot;); user.setBirthday(new Date()); userMapper.update(user);&#125;@Testpublic void testDelete() throws IOException &#123; userMapper.delete(16);&#125;@Testpublic void testFindById() throws IOException &#123; User user = userMapper.findById(1); System.out.println(user);&#125;@Testpublic void testFindAll() throws IOException &#123; List&lt;User&gt; all = userMapper.findAll(); for(User user : all)&#123; System.out.println(user); &#125;&#125; 修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可 1234&lt;mappers&gt; &lt;!--扫描使用注解的类--&gt; &lt;mapper class=&quot;com.itheima.mapper.UserMapper&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt; 或者指定扫描包含映射关系的接口所在的包也可以 1234&lt;mappers&gt; &lt;!--扫描使用注解的类所在的包--&gt; &lt;package name=&quot;com.itheima.mapper&quot;&gt;&lt;/package&gt;&lt;/mappers&gt; 接口中方法上添加注解即可 1234567891011121314151617public interface UserMapper &#123; @Insert(&quot;insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;birthday&#125;)&quot;) public void save(User user); @Update(&quot;update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;&quot;) public void update(User user); @Delete(&quot;delete from user where id=#&#123;id&#125;&quot;) public void delete(int id); @Select(&quot;select * from user where id=#&#123;id&#125;&quot;) public User findById(int id); @Select(&quot;select * from user&quot;) public List&lt;User&gt; findAll();&#125; 1.3 MyBatis的注解实现复杂映射开发实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置 注解 说明 @Results 代替的是标签该注解中可以使用单个@Result注解，也可以使用@Result集合。使用格式：@Results（{@Result（），@Result（）}）或@Results（@Result（）） @Resut 代替了标签和标签 @Result中属性介绍： column：数据库的列名 property：需要装配的属性名 one：需要使用的@One 注解（@Result（one=@One）（））） many：需要使用的@Many 注解（@Result（many=@many）（））） @One （一对一） 代替了 标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。 @One注解属性介绍： select: 指定用来多表查询的 sqlmapper 使用格式：@Result(column=” “,property=””,one=@One(select=””)) @Many （多对一） 代替了标签, 是是多表查询的关键，在注解中用来指定子查询返回对象集合。 使用格式：@Result(property=””,column=””,many=@Many(select=””)) 1.4 一对一查询 一对一查询的模型 用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户 一对一查询的语句 对应的sql语句： select * from orders; select * from user where id=查询出订单的uid; 查询的结果如下： 3. 创建Order和User实体 123456789public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125; 1234567public class User &#123; private int id; private String username; private String password; private Date birthday;&#125; 4. 创建OrderMapper接口 123public interface OrderMapper &#123; List&lt;Order&gt; findAll();&#125; 5. 使用注解配置Mapper 6. 测试结果 1234567@Testpublic void testSelectOrderAndUser() &#123; List&lt;Order&gt; all = orderMapper.findAll(); for(Order order : all)&#123; System.out.println(order); &#125;&#125; 1.5 一对多查询 一对多查询的模型 用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单 ![2129_2 (2)](16_MyBatis注解开发/2129_2 (2).png) 一对多查询的语句 对应的sql语句： select * from user; select * from orders where uid=查询出用户的id; 查询的结果如下： 3. 修改User实体 123456789public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125; 123456789public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList;&#125; 4. 创建UserMapper接口 1List&lt;User&gt; findAllUserAndOrder(); 5. 使用注解配置Mapper 6. 测试结果 123456789List&lt;User&gt; all = userMapper.findAllUserAndOrder();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Order&gt; orderList = user.getOrderList(); for(Order order : orderList)&#123; System.out.println(order); &#125; System.out.println(&quot;-----------------------------&quot;);&#125; 1.6 多对多查询 多对多查询的模型 用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 多对多查询的语句 对应的sql语句： select * from user;select * from role r,user_roleurwhere r.id=ur.role_idand ur.user_id=用户的id 查询的结果如下： 3. 创建Role实体，修改User实体 1234567891011public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList; //代表当前用户具备哪些角色 private List&lt;Role&gt; roleList;&#125; 123456public class Role &#123; private int id; private String rolename;&#125; 4. 添加UserMapper接口方法 1List&lt;User&gt; findAllUserAndRole(); 5. 使用注解配置Mapper 6. 测试结果 12345678910UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAllUserAndRole();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Role&gt; roleList = user.getRoleList(); for(Role role : roleList)&#123; System.out.println(role); &#125; System.out.println(&quot;----------------------------------&quot;);&#125;","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"15_MyBatis多表操作","slug":"黑马程序员/SSM框架/15_MyBatis多表操作","date":"2021-07-28T02:38:03.000Z","updated":"2021-07-28T02:48:04.246Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/15_MyBatis多表操作/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/15_MyBatis%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"1.Mybatis多表查询1.1 一对一查询 一对一查询的模型 用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户 一对一查询的语句 对应的sql语句：select * from orders o,user u where o.uid=u.id; 查询的结果如下： 3. 创建Order和User实体 12345678public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125; 1234567public class User &#123; private int id; private String username; private String password; private Date birthday;&#125; 4. 创建OrderMapper接口 123public interface OrderMapper &#123; List&lt;Order&gt; findAll();&#125; 5. 配置OrderMapper.xml 1234567891011121314&lt;mapper namespace=&quot;com.itheima.mapper.OrderMapper&quot;&gt; &lt;resultMap id=&quot;orderMap&quot; type=&quot;com.itheima.domain.Order&quot;&gt; &lt;id column=&quot;oid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;&gt;&lt;/result&gt; &lt;result column=&quot;total&quot; property=&quot;total&quot;&gt;&lt;/result&gt; &lt;result column=&quot;uid&quot; property=&quot;user.id&quot;&gt;&lt;/result&gt; &lt;result column=&quot;username&quot; property=&quot;user.username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;password&quot; property=&quot;user.password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;user.birthday&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;orderMap&quot;&gt; select *,o.id oid from orders o,user u where o.uid=u.id &lt;/select&gt;&lt;/mapper&gt; 其中还可以配置如下： 1234567891011&lt;resultMap id=&quot;orderMap&quot; type=&quot;com.itheima.domain.Order&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;&gt;&lt;/result&gt; &lt;result column=&quot;total&quot; property=&quot;total&quot;&gt;&lt;/result&gt; &lt;association property=&quot;user&quot; javaType=&quot;com.itheima.domain.User&quot;&gt; &lt;id column=&quot;uid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt; 6. 测试结果 12345OrderMapper mapper = sqlSession.getMapper(OrderMapper.class);List&lt;Order&gt; all = mapper.findAll();for(Order order : all)&#123; System.out.println(order);&#125; 1.2 一对多查询 一对多查询的模型 用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单 ![2109_2 (1)](15_MyBatis多表操作/2109_2 (1).png) 一对多查询的语句 对应的sql语句：select *,o.id oidfrom user u left join orders o on u.id=o.uid; 查询的结果如下： 3. 修改User实体 123456789public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125; 123456789public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList;&#125; 4. 创建UserMapper接口 123public interface UserMapper &#123; List&lt;User&gt; findAll();&#125; 5. 配置UserMapper.xml 12345678910111213141516&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;com.itheima.domain.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;orderList&quot; ofType=&quot;com.itheima.domain.Order&quot;&gt; &lt;result column=&quot;oid&quot; property=&quot;id&quot;&gt;&lt;/result&gt; &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;&gt;&lt;/result&gt; &lt;result column=&quot;total&quot; property=&quot;total&quot;&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt; select *,o.id oid from user u left join orders o on u.id=o.uid &lt;/select&gt;&lt;/mapper&gt; 6. 测试结果 12345678910UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAll();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Order&gt; orderList = user.getOrderList(); for(Order order : orderList)&#123; System.out.println(order); &#125; System.out.println(&quot;----------------------------------&quot;);&#125; 1.3 多对多查询 多对多查询的模型 用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 多对多查询的语句 对应的sql语句：select u.*,r.*,r.id rid from user u left join user_roleuron u.id=ur.user_id inner join role r on ur.role_id=r.id; 查询的结果如下： 3. 创建Role实体，修改User实体 12345678910public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList; //代表当前用户具备哪些角色 private List&lt;Role&gt; roleList;&#125; 12345public class Role &#123; private int id; private String rolename;&#125; 4. 添加UserMapper接口方法 1List&lt;User&gt; findAllUserAndRole(); 5. 配置UserMapper.xml 1234567891011121314&lt;resultMap id=&quot;userRoleMap&quot; type=&quot;com.itheima.domain.User&quot;&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/result&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;roleList&quot; ofType=&quot;com.itheima.domain.Role&quot;&gt; &lt;result column=&quot;rid&quot; property=&quot;id&quot;&gt;&lt;/result&gt; &lt;result column=&quot;rolename&quot; property=&quot;rolename&quot;&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;findAllUserAndRole&quot; resultMap=&quot;userRoleMap&quot;&gt; select u.*,r.*,r.id rid from user u left join user_role ur on u.id=ur.user_id inner join role r on ur.role_id=r.id&lt;/select&gt; 6. 测试结果 1234567891011UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAllUserAndRole();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Role&gt; roleList = user.getRoleList(); for(Role role : roleList)&#123; System.out.println(role); &#125; System.out.println(&quot;----------------------------------&quot;);&#125; 1.4 知识小结MyBatis多表配置方式： 一对一配置：使用&lt;resultMap&gt;做配置一对多配置：使用&lt;resultMap&gt;+&lt;collection&gt;做配置多对多配置：使用&lt;resultMap&gt;+&lt;collection&gt;做配置","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"14_MyBatis核心配置文件深入","slug":"黑马程序员/SSM框架/14_MyBatis核心配置文件深入","date":"2021-07-28T02:37:21.000Z","updated":"2021-07-28T02:47:28.102Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/14_MyBatis核心配置文件深入/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/14_MyBatis%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%B7%B1%E5%85%A5/","excerpt":"","text":"1. MyBatis核心配置文件深入1.1 typeHandlers标签无论是MyBatis在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时，都会用类型处理器将获取的值以合适的方式转换成Java 类型。下表描述了一些默认的类型处理器（截取部分）。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现org.apache.ibatis.type.TypeHandler接口，或继承一个很便利的类org.apache.ibatis.type.BaseTypeHandler，然后可以选择性地将它映射到一个JDBC类型。例如需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。 开发步骤： ①定义转换类继承类BaseTypeHandler②覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult为查询时mysql的字符串类型转换成java的Type类型的方法③在MyBatis核心配置文件中进行注册④测试转换是否正确 1234567891011121314public class MyDateTypeHandler extends BaseTypeHandler&lt;Date&gt; &#123; public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType type) &#123; preparedStatement.setString(i,date.getTime()+&quot;&quot;); &#125; public Date getNullableResult(ResultSet resultSet, String s) throws SQLException &#123; return new Date(resultSet.getLong(s)); &#125; public Date getNullableResult(ResultSet resultSet, int i) throws SQLException &#123; return new Date(resultSet.getLong(i)); &#125; public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException &#123; return callableStatement.getDate(i); &#125;&#125; 1234&lt;!--注册类型自定义转换器--&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=&quot;com.itheima.typeHandlers.MyDateTypeHandler&quot;&gt;&lt;/typeHandler&gt;&lt;/typeHandlers&gt; 测试添加操作： 12user.setBirthday(new Date());userMapper.add2(user); 测试查询操作： 1.2 plugins标签MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据 开发步骤： ①导入通用PageHelper的坐标②在mybatis核心配置文件中配置PageHelper插件③测试分页数据获取 ①导入通用 PageHelper 坐标 1234567891011&lt;!-- 分页助手 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;3.7.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt; ②在mybatis核心配置文件中配置PageHelper插件 12345&lt;!-- 注意：分页助手的插件 配置在通用馆mapper之前 --&gt;&lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt; &lt;!-- 指定方言 --&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;&lt;/plugin&gt; ③测试分页代码实现 12345678910@Testpublic void testPageHelper()&#123; //设置分页参数 PageHelper.startPage(1,2); List&lt;User&gt; select = userMapper2.select(null); for(User user : select)&#123; System.out.println(user); &#125;&#125; 获得分页相关的其他参数 12345678//其他分页的数据PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(select);System.out.println(&quot;总条数：&quot;+pageInfo.getTotal());System.out.println(&quot;总页数：&quot;+pageInfo.getPages());System.out.println(&quot;当前页：&quot;+pageInfo.getPageNum());System.out.println(&quot;每页显示长度：&quot;+pageInfo.getPageSize());System.out.println(&quot;是否第一页：&quot;+pageInfo.isIsFirstPage());System.out.println(&quot;是否最后一页：&quot;+pageInfo.isIsLastPage()); 1.3 知识小结MyBatis核心配置文件常用标签： 1、properties标签：该标签可以加载外部的properties文件2、typeAliases标签：设置类型别名3、environments标签：数据源环境配置标签4、typeHandlers标签：配置自定义类型处理器5、plugins标签：配置MyBatis的插件","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"13_MyBatis映射文件深入（动态SQL）","slug":"黑马程序员/SSM框架/13_MyBatis映射文件深入（动态SQL）","date":"2021-07-28T02:36:56.000Z","updated":"2021-07-28T02:46:52.793Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/13_MyBatis映射文件深入（动态SQL）/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/13_MyBatis%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E6%B7%B1%E5%85%A5%EF%BC%88%E5%8A%A8%E6%80%81SQL%EF%BC%89/","excerpt":"","text":"1.MyBatis映射文件深入1.1 动态sql语句 动态sql语句概述 Mybatis的映射文件中，前面我们的SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的SQL是动态变化的，此时在前面的学习中我们的SQL 就不能满足要求了。 参考的官方文档，描述如下： ![2091_1 (1)](13_MyBatis映射文件深入（动态SQL）/2091_1 (1).png) 动态SQL 之 我们根据实体类的不同取值，使用不同的SQL语句来进行查询。比如在id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。 1234567891011&lt;select id=&quot;findByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from User &lt;where&gt; &lt;if test=&quot;id!=0&quot;&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;username!=null&quot;&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 当查询条件id和username都存在时，控制台打印的sql语句如下： 12345678 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User condition = new User(); condition.setId(1); condition.setUsername(&quot;lucy&quot;); User user = userMapper.findByCondition(condition); … … … 当查询条件只有id存在时，控制台打印的sql语句如下： 1234567 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User condition = new User(); condition.setId(1); User user = userMapper.findByCondition(condition); … … … 动态SQL 之 循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。 12345678&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; select * from User &lt;where&gt; &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 测试代码片段如下： 1234567 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int[] ids = new int[]&#123;2,5&#125;; List&lt;User&gt; userList = userMapper.findByIds(ids); System.out.println(userList); … … … foreach标签的属性含义如下： &lt;foreach&gt;标签用于遍历集合，它的属性： collection：代表要遍历的集合元素，注意编写时不要写#{} open：代表语句的开始部分 close：代表结束部分 item：代表遍历集合的每个元素，生成的变量名 sperator：代表分隔符 1.2 SQL片段抽取Sql中可将重复的sql提取出来，使用时用include 引用即可，最终达到sql重用的目的 12345678910111213&lt;!--抽取sql片段简化编写--&gt;&lt;sql id=&quot;selectUser&quot; select * from User&lt;/sql&gt;&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; where id=#&#123;id&#125;&lt;/select&gt;&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 1.3 知识小结MyBatis映射文件配置：&lt;select&gt;：查询&lt;insert&gt;：插入&lt;update&gt;：修改&lt;delete&gt;：删除&lt;where&gt;：where条件&lt;if&gt;：if判断&lt;foreach&gt;：循环&lt;sql&gt;：sql片段抽取","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"12_MyBatis的Dao层实现方式","slug":"黑马程序员/SSM框架/12_MyBatis的Dao层实现方式","date":"2021-07-28T02:36:30.000Z","updated":"2021-07-28T02:46:29.972Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/12_MyBatis的Dao层实现方式/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/12_MyBatis%E7%9A%84Dao%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/","excerpt":"","text":"1.Mybatis的Dao层实现1.1 传统开发方式 编写UserDao接口 123public interface UserDao &#123; List&lt;User&gt; findAll() throws IOException;&#125; 编写UserDaoImpl实现 12345678910public class UserDaoImpl implements UserDao &#123; public List&lt;User&gt; findAll() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;); sqlSession.close(); return userList; &#125;&#125; 3. 测试传统方式123456@Testpublic void testTraditionDao() throws IOException &#123; UserDao userDao = new UserDaoImpl(); List&lt;User&gt; all = userDao.findAll(); System.out.println(all);&#125; 1.2 代理开发方式 代理开发方式介绍 采用Mybatis的代理开发方式实现DAO 层的开发，这种方式是我们后面进入企业的主流。 Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper 接口开发需要遵循以下规范： 1、Mapper.xml文件中的namespace与mapper接口的全限定名相同 2、Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 3、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 4、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 1.2 代理开发方式 编写UserMapper接口 测试代理方式 1234567891011@Testpublic void testProxyDao() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); //获得MyBatis框架生成的UserMapper接口的实现类 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.findById(1); System.out.println(user); sqlSession.close();&#125; 1.3 知识小结MyBatis的Dao层实现的两种方式： 手动对Dao进行实现：传统开发方式 代理方式对Dao进行实现： UserMapperuserMapper = sqlSession.getMapper(UserMapper.class);","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"11_MyBatis入门操作","slug":"黑马程序员/SSM框架/11_MyBatis入门操作","date":"2021-07-28T02:36:02.000Z","updated":"2021-07-28T02:58:55.863Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/11_MyBatis入门操作/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/11_MyBatis%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"1.Mybatis简介1.1 原始jdbc操作（查询数据） 1.1 原始jdbc操作（插入数据）1.2 原始jdbc操作的分析原始jdbc开发存在的问题如下： ①数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能②sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。③查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置 应对上述问题给出的解决方案： ①使用数据库连接池初始化连接资源②将sql语句抽取到xml配置文件中③使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射 1.3 什么是Mybatis mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。 最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbcapi底层访问细节，使我们不用与jdbcapi打交道，就可以完成对数据库的持久化操作。 2. Mybatis的快速入门2.1 MyBatis开发步骤MyBatis官网地址：http://www.mybatis.org/mybatis-3/ MyBatis开发步骤： ①添加MyBatis的坐标②创建user数据表③编写User实体类④编写映射文件UserMapper.xml⑤编写核心文件SqlMapConfig.xml⑥编写测试类 2.2 环境搭建 导入MyBatis的坐标和其他相关坐标 1234567891011121314151617181920212223242526&lt;!--mybatis坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql驱动坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--单元测试坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--日志坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt; 创建user数据表 编写User实体 123456public class User &#123; private int id; private String username; private String password; //省略get和set方法&#125; 编写UserMapper.xml映射文件 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 编写MyBatis核心文件(SqlMapConfig.xml) 1234567891011121314151617181920&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN“ &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--数据源环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///test&quot;/&gt;&lt;!-- 等同于 &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;--&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.3 编写测试代码1234567891011121314151617public class MyBatisTest&#123; @Test public void test1() throws IOException &#123; //加载核心配置文件 InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //获得sqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); //获得sqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //执行sql语句 List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;); //打印结果 System.out.println(userList); //释放资源 sqlSession.close(); &#125;&#125; 2.4 知识小结MyBatis开发步骤： ①添加MyBatis的坐标②创建user数据表③编写User实体类④编写映射文件UserMapper.xml⑤编写核心文件SqlMapConfig.xml⑥编写测试类 3. MyBatis的映射文件概述 4. MyBatis的增删改查操作4.1 MyBatis的插入数据操作 编写UserMapper映射文件 12345&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;insert id=&quot;add&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; 编写插入实体User的代码 12345678InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int insert = sqlSession.insert(&quot;userMapper.add&quot;, user);System.out.println(insert);//提交事务sqlSession.commit();sqlSession.close(); 插入操作注意问题 插入语句使用insert标签 在映射文件中使用parameterType属性指定要插入的数据类型 Sql语句中使用#{实体属性名}方式引用实体中的属性值 插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象); 插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即sqlSession.commit() 4.2 MyBatis的修改数据操作 编写UserMapper映射文件 12345&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 编写修改实体User的代码 1234567InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int update = sqlSession.update(&quot;userMapper.update&quot;, user);System.out.println(update);sqlSession.commit();sqlSession.close(); 修改操作注意问题 修改语句使用update标签 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象); 4.3 MyBatis的删除数据操作 编写UserMapper映射文件 12345&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 编写删除数据的代码 1234567InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int delete = sqlSession.delete(&quot;userMapper.delete&quot;,3);System.out.println(delete);sqlSession.commit();sqlSession.close(); 删除操作注意问题 删除语句使用delete标签 Sql语句中使用#{任意字符串}方式引用传递的单个参数 删除操作使用的API是sqlSession.delete(“命名空间.id”,Object); 4.4 知识小结增删改查映射配置与API： 1234567891011121314151617增删改查映射配置与API：查询数据： List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;); &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from User &lt;/select&gt;添加数据： sqlSession.insert(&quot;userMapper.add&quot;, user); &lt;insert id=&quot;add&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt;修改数据： sqlSession.update(&quot;userMapper.update&quot;, user); &lt;update id=&quot;update&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125; &lt;/update&gt;删除数据：sqlSession.delete(&quot;userMapper.delete&quot;,3); &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; 5. MyBatis核心配置文件概述5.1 MyBatis核心配置文件层级关系 5.2 MyBatis常用配置解析 environments标签 数据库环境的配置，支持多环境配置 其中，事务管理器（transactionManager）类型有两种： JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如JEE 应用服务器的上下文）。默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将closeConnection属性设置为false 来阻止它默认的关闭行为。 其中，数据源（dataSource）类型有三种： UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED：这种数据源的实现利用“池”的概念将JDBC 连接对象组织起来。 JNDI：这个数据源的实现是为了能在如EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个JNDI 上下文的引用。 mapper标签 该标签的作用是加载映射的，加载方式有如下几种： 使用相对于类路径的资源引用，例如： &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt; 使用完全限定资源定位符（URL），例如： &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt; 使用映射器接口实现类的完全限定类名，例如： &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt; 将包内的映射器接口实现全部注册为映射器，例如： &lt;package name=&quot;org.mybatis.builder&quot;/&gt; Properties标签 实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件 typeAliases标签 类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下 配置typeAliases（该标签要放在properties标签后面，约束有一定的顺序），为com.itheima.domain.User定义别名为user 上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名 别名 数据类型 string String long Long int Integer double Double boolean Boolean … … … … 5.3 知识小结核心配置文件常用配置： 1、properties标签：该标签可以加载外部的properties文件 &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt; 2、typeAliases标签：设置类型别名 &lt;typeAlias type=&quot;com.itheima.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt; 3、mappers标签：加载映射配置 &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;&gt;&lt;/mapper&gt; 4、environments标签：数据源环境配置标签 MyBatis相应API6.1 SqlSession工厂构建器SqlSessionFactoryBuilder常用API：SqlSessionFactorybuild(InputStreaminputStream) 通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象 1234String resource = &quot;org/mybatis/builder/mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream); 其中，Resources 工具类，这个类在org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个web URL 中加载资源文件。 6.2 SqlSession工厂对象SqlSessionFactorySqlSessionFactory有多个个方法创建SqlSession实例。常用的有如下两个： 方法 解释 openSession() 会默认开启一个事务，但事务不会自动提交，也就意味着需要手动提交该事务，更新操作数据才会持久化到数据库中 openSession(boolean autoCommit) 参数为是否自动提交，如果设置为true，那么不需要手动提交事务 6.3 SqlSession会话对象SqlSession实例在MyBatis中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。 执行语句的方法主要有： 12345&lt;T&gt; T selectOne(String statement, Object parameter) &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) int insert(String statement, Object parameter) int update(String statement, Object parameter) int delete(String statement, Object parameter) 操作事务的方法主要有： 12void commit()void rollback()","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"10_声明式事务控制","slug":"黑马程序员/SSM框架/10_声明式事务控制","date":"2021-07-28T02:35:39.000Z","updated":"2021-07-28T02:45:58.048Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/10_声明式事务控制/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/10_%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/","excerpt":"","text":"1. 编程式事务控制相关对象1.1 PlatformTransactionManagerPlatformTransactionManager 接口是spring 的事务管理器，它里面提供了我们常用的操作事务的方法。 方法 说明 TransactionStatus getTransaction(TransactionDefination defination) 获取事务的状态信息 void commit(TransactionStatus status) 提交事务 void rollback(TransactionStatus status) 回滚事务 注意： PlatformTransactionManager 是接口类型，不同的Dao 层技术则有不同的实现类，例如：Dao 层技术是jdbc 或mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager Dao 层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager 1.2 TransactionDefinitionTransactionDefinition 是事务的定义信息对象，里面有如下方法： 方法 说明 int getIsolationLevel() 获得事务的隔离级别 int getPropogationBehavior() 获得事务的传播行为 int getTimeout() 获得超时时间 boolean isReadOnly() 是否只读 事务隔离级别 设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。 ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED 读未提交 ISOLATION_READ_COMMITTED 不可重复读 ISOLATION_REPEATABLE_READ 可重复读 ISOLATION_SERIALIZABLE 串行化 隔离级别 脏读 不可重复读 幻读 读未提交 Yes Yes Yes 不可重复读 No Yes Yes 可重复读 No No Yes 串行化 No No No 事务传播行为 REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER：以非事务方式运行，如果当前存在事务，抛出异常 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED 类似的操作 超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置 是否只读：建议查询时设置为只读 1.3 TransactionStatusTransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。 方法 说明 boolean hasSavepoint() 是否存储回滚点 boolean isCompleted() 事务是否完成 boolean isNewTransaction() 是否是新事务 boolean isRollbackOnly() 事务是否回滚 1.4 知识要点编程式事务控制三大对象 PlatformTransactionManager TransactionDefinition TransactionStatus 2. 基于XML 的声明式事务控制2.1 什么是声明式事务控制Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在Spring 配置文件中声明式的处理事务来代替代码式的处理事务。 声明式事务处理的作用 事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便 注意：Spring 声明式事务控制底层就是AOP。 2.2 声明式事务控制的实现声明式事务控制明确事项： 谁是切点？ 谁是通知？ 配置切面？ ①引入tx命名空间 1234567891011121314&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; ②配置事务增强 1234567891011&lt;!--平台事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--事务增强配置--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; ③配置事务AOP 织入 12345&lt;!--事务的aop增强--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; ④测试事务控制转账业务代码 123456@Overridepublic void transfer(String outMan, String inMan, double money) &#123; accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money);&#125; 2.3 切点方法的事务参数的配置123456&lt;!--事务增强配置--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 其中，tx:method 代表切点方法的事务参数的配置，例如： &lt;tx:method name=&quot;transfer&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; timeout=&quot;-1&quot; read-only=&quot;false&quot;/&gt; name：切点方法名称 isolation:事务的隔离级别 propogation：事务的传播行为 timeout：超时时间 read-only：是否只读 2.4 知识要点声明式事务控制的配置要点 平台事务管理器配置 事务通知的配置 事务aop织入的配置 3. 基于注解的声明式事务控制3.1 使用注解配置声明式事务控制 编写AccoutDao 1234567891011@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements AccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public void out(String outMan, double money) &#123; jdbcTemplate.update(&quot;update account set money=money-? where name=?&quot;,money,outMan); &#125; public void in(String inMan, double money) &#123; jdbcTemplate.update(&quot;update account set money=money+? where name=?&quot;,money,inMan); &#125;&#125; 编写AccoutService 123456789101112@Service(&quot;accountService&quot;)@Transactional(isolation = Isolation.READ_COMMITTED)public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED) public void transfer(String outMan, String inMan, double money) &#123; accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money); &#125;&#125; 编写applicationContext.xml 配置文件 12345&lt;!—之前省略datsSource、jdbcTemplate、平台事务管理器的配置--&gt;&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;&lt;!--事务的注解驱动--&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 3.2 注解配置声明式事务控制解析①使用@Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同xml 配置方式，例如隔离级别、传播行为等。②注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。③使用在方法上，不同的方法可以采用不同的事务参数配置。④Xml配置文件中要开启事务的注解驱动&lt;tx:annotation-driven /&gt; 3.3 知识要点注解声明式事务控制的配置要点 平台事务管理器配置（xml方式） 事务通知的配置（@Transactional注解配置） 事务注解驱动的配置&lt;tx:annotation-driven/&gt;","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"09_AOP","slug":"黑马程序员/SSM框架/09_AOP","date":"2021-07-28T02:35:24.000Z","updated":"2021-07-28T02:45:40.909Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/09_AOP/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/09_AOP/","excerpt":"","text":"1. Spring 的AOP 简介1.1 什么是AOPAOP 为Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP 是OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 1.2 AOP 的作用及其优势 作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复代码，提高开发效率，并且便于维护 1.3 AOP 的底层实现实际上，AOP 的底层是通过Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 1.4 AOP 的动态代理技术常用的动态代理技术 JDK 代理: 基于接口的动态代理技术 cglib 代理：基于父类的动态代理技术 1.5 JDK 的动态代理①目标类接口 123public interface TargetInterface &#123; public void method();&#125; ②目标类 123456public class Target implements TargetInterface &#123; @Override public void method()&#123; System.out.println(&quot;Target running....&quot;); &#125;&#125; ③动态代理代码 12345678910111213Target target = new Target();//创建目标对象//创建代理对象TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;前置增强代码...&quot;); Object invoke = method.invoke(target, args); System.out.println(&quot;后置增强代码...&quot;); return invoke; &#125;&#125;); ④调用代理对象的方法测试 12// 测试,当调用接口的任何方法时，代理对象的代码都无序修改proxy.method(); 1.6 cglib 的动态代理①目标类 12345public class Target &#123; public void method() &#123; System.out.println(&quot;Target running....&quot;); &#125;&#125; ②动态代理代码 12345678910111213Target target = new Target();//创建目标对象Enhancer enhancer = new Enhancer();//创建增强器enhancer.setSuperclass(Target.class);//设置父类enhancer.setCallback(new MethodInterceptor() &#123; //设置回调 @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;前置代码增强....&quot;); Object invoke = method.invoke(target, objects); System.out.println(&quot;后置代码增强....&quot;); return invoke; &#125;&#125;);Target proxy = (Target) enhancer.create();//创建代理对象 ③调用代理对象的方法测试 12//测试,当调用接口的任何方法时，代理对象的代码都无序修改proxy.method(); ![2021_2 (1)](09_AOP/2021_2 (1).png) 1.7 AOP 相关概念Spring 的AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。 在正式讲解AOP 的操作之前，我们必须理解AOP 的相关术语，常用的术语如下： Target（目标对象）：代理的目标对象 Proxy （代理）：一个类被AOP 织入增强后，就产生一个结果代理类 Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点 Pointcut（切入点）：所谓切入点是指我们要对哪些Joinpoint进行拦截的定义 Advice（通知/ 增强）：所谓通知是指拦截到Joinpoint之后所要做的事情就是通知 Aspect（切面）：是切入点和通知（引介）的结合 Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入 1.8 AOP 开发明确的事项 需要编写的内容 编写核心业务代码（目标类的目标方法） 编写切面类，切面类中有通知(增强功能方法) 在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合 AOP 技术实现的内容 Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 AOP 底层使用哪种代理方式 在spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 1.9 知识要点 aop：面向切面编程 aop底层实现：基于JDK的动态代理和基于Cglib的动态代理 aop的重点概念： Pointcut（切入点）：被增强的方法 Advice（通知/ 增强）：封装增强业务逻辑的方法 Aspect（切面）：切点+通知 Weaving（织入）：将切点与通知结合的过程 开发明确事项： 谁是切点（切点表达式配置） 谁是通知（切面类中的增强方法） 将切点和通知进行织入配置 2. 基于XML 的AOP 开发2.1 快速入门①导入AOP 相关坐标②创建目标接口和目标类（内部有切点）③创建切面类（内部有增强方法）④将目标类和切面类的对象创建权交给spring⑤在applicationContext.xml 中配置织入关系⑥测试代码 ①导入AOP 相关坐标 123456789101112&lt;!--导入spring的context坐标，context依赖aop--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj的织入--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt;&lt;/dependency&gt; ②创建目标接口和目标类（内部有切点） 123public interface TargetInterface &#123; public void method();&#125; 123456public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println(&quot;Target running....&quot;); &#125;&#125; ③创建切面类（内部有增强方法） 12345678910111213public class MyAspect &#123; //前置增强方法 public void before()&#123; System.out.println(&quot;前置代码增强.....&quot;); &#125; public Object around(ProceedingJoinPoint pjb) throws Throwable &#123; System.out.println(&quot;环绕前增强&quot;); Object proceed = pjb.proceed();//切点方法 System.out.println(&quot;环绕前增强&quot;); return proceed; &#125;&#125; ④将目标类和切面类的对象创建权交给spring 1234&lt;!--配置目标类--&gt;&lt;bean id=&quot;target&quot; class=&quot;com.itheima.aop.Target&quot;&gt;&lt;/bean&gt;&lt;!--配置切面类--&gt;&lt;bean id=&quot;myAspect&quot; class=&quot;com.itheima.aop.MyAspect&quot;&gt;&lt;/bean&gt; ⑤在applicationContext.xml 中配置织入关系 导入aop命名空间 1234567891011121314&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 配置切点表达式和前置增强的织入关系 12345678&lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!--配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt; &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(public void com.itheima.aop.Target.method())&quot;&gt;&lt;/aop:before&gt; &lt;aop:around method=&quot;around&quot; pointcut=&quot;execution(* com.itheima.aop.*.*(..))&quot;&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; ⑥测试代码 12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class AopTest&#123; @Autowired private TargetInterface target; @Test public void test1()&#123; target.method(); &#125;&#125; ⑦测试结果 2.2 XML 配置AOP 详解 切点表达式的写法 execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号*代表任意 包名与类名之间一个点. 代表当前包下的类，两个点.. 表示当前包及其子包下的类 参数列表可以使用两个点.. 表示任意个数，任意类型的参数列表 例如： 12345execution(public void com.itheima.aop.Target.method())execution(void com.itheima.aop.Target.*(..))execution(* com.itheima.aop.*.*(..))execution(* com.itheima.aop..*.*(..))execution(* *..*.*(..)) 通知的类型 通知的配置语法： &lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式&quot;&gt;&lt;/aop:通知类型&gt; 名称 标签 说明 前置通知 &lt;aop:before&gt; 用于配置前置通知。指定增强的方法在切入点方法之前执行 后置通知 &lt;aop:after returning&gt; 用于配置后置通知。指定增强的方法在切入点方法之后执行 环绕通知 &lt;aop:around&gt; 用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行 异常抛出通知 &lt;aop:throwing&gt; 用于配置异常抛出通知。指定增强的方法在出现异常时执行 最终通知 &lt;aop:after&gt; 用于配置最终通知。无论增强方式执行是否有异常都会执行 3. 切点表达式的抽取当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用pointcut-ref 属性代替pointcut 属性来引用抽取后的切点表达式。 1234567&lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.itheima.aop.*.*(..))&quot;/&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 2.3 知识要点 aop织入的配置12345&lt;aop:config&gt; &lt;aop:aspec tref=“切面类”&gt; &lt;aop:before method=“通知方法名称” pointcut=“切点表达式&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 通知的类型：前置通知、后置通知、环绕通知、异常抛出通知、最终通知 切点表达式的写法：execution([修饰符] 返回值类型包名.类名.方法名(参数)) 3. 基于注解的AOP 开发3.1 快速入门基于注解的aop开发步骤： ①创建目标接口和目标类（内部有切点）②创建切面类（内部有增强方法）③将目标类和切面类的对象创建权交给spring④在切面类中使用注解配置织入关系⑤在配置文件中开启组件扫描和AOP 的自动代理⑥测试 ①创建目标接口和目标类（内部有切点） 123public interface TargetInterface &#123; public void method();&#125; 123456public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println(&quot;Target running....&quot;); &#125;&#125; ②创建切面类（内部有增强方法） 123456public class MyAspect &#123; //前置增强方法 public void before()&#123; System.out.println(&quot;前置代码增强.....&quot;); &#125;&#125; ③将目标类和切面类的对象创建权交给spring 1234567891011121314@Component(&quot;target&quot;)public class Target implements TargetInterface&#123; @Override public void method() &#123; System.out.println(&quot;Target running....&quot;); &#125;&#125;@Component(&quot;myAspect&quot;)public class MyAspect&#123; public void before()&#123; System.out.println(&quot;前置代码增强.....&quot;); &#125;&#125; ④在切面类中使用注解配置织入关系 12345678@Component(&quot;myAspect&quot;)@Aspectpublic class MyAspect &#123; @Before(&quot;execution(* com.itheima.aop.*.*(..))&quot;) public void before()&#123; System.out.println(&quot;前置代码增强.....&quot;); &#125;&#125; ⑤在配置文件中开启组件扫描和AOP 的自动代理 12345&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.itheima.aop&quot;/&gt;&lt;!--aop的自动代理--&gt;&lt;aop:aspectj-autoproxy/&gt; ⑥测试代码 12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class AopTest&#123; @Autowired private TargetInterface target; @Test public void test1()&#123; target.method(); &#125;&#125; ⑦测试结果 3.2 注解配置AOP 详解 注解通知的类型 通知的配置语法：@通知注解(“切点表达式”) 名称 标签 说明 前置通知 @Before 用于配置前置通知。指定增强的方法在切入点方法之前执行 后置通知 @AfterReturning 用于配置后置通知。指定增强的方法在切入点方法之后执行 环绕通知 @Around 用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行 异常抛出通知 @AfterThrowing 用于配置异常抛出通知。指定增强的方法在出现异常时执行 最终通知 @After 用于配置最终通知。无论增强方式执行是否有异常都会执行 切点表达式的抽取 同xml 配置aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下： 1234567891011@Component(&quot;myAspect&quot;)@Aspect//标注当前MyAspect是一个切面类public class MyAspect&#123; @Before(&quot;MyAspect.myPoint()&quot;) public void before()&#123; System.out.println(&quot;前置代码增强.....&quot;); &#125; @Pointcut(&quot;execution(* com.itheima.aop.*.*(..))&quot;) public void myPoint()&#123; &#125;&#125; 注解 aop 开发步骤①使用 @Aspect 标注切面类②使用 通知注解标注通知方法③在配置文件中配置 aop 自动代理 aop :aspectj autoproxy 通知注解类型 名称 标签 说明 前置通知 @Before 用于配置前置通知。指定增强的方法在切入点方法之前执行 后置通知 @AfterReturning 用于配置后置通知。指定增强的方法在切入点方法之后执行 环绕通知 @Around 用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行 异常抛出通知 @AfterThrowing 用于配置异常抛出通知。指定增强的方法在出现异常时执行 最终通知 @After 用于配置最终通知。无论增强方式执行是否有异常都会执行","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"08_异常处理机制","slug":"黑马程序员/SSM框架/08_异常处理机制","date":"2021-07-28T02:35:02.000Z","updated":"2021-07-28T02:45:14.045Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/08_异常处理机制/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/08_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/","excerpt":"","text":"1. SpringMVC异常处理1.1 异常处理的思路系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。 系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理，如下图： 1.2 异常处理两种方式 使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver 实现Spring的异常处理接口HandlerExceptionResolver自定义自己的异常处理器 1.3 简单异常处理器SimpleMappingExceptionResolverSpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置 12345678910&lt;!--配置简单映射异常处理器--&gt;&lt;bean class=“org.springframework.web.servlet.handler.SimpleMappingExceptionResolver”&gt; &lt;property name=“defaultErrorView” value=“error”/&gt; 默认错误视图 &lt;property name=“exceptionMappings”&gt; &lt;map&gt; 异常类型 错误视图 &lt;entry key=&quot;com.itheima.exception.MyException&quot; value=&quot;error1&quot;/&gt; &lt;entry key=&quot;java.lang.ClassCastException&quot; value=&quot;error2&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 1.4 自定义异常处理步骤①创建异常处理器类实现HandlerExceptionResolver②配置异常处理器③编写异常页面④测试异常跳转 ①创建异常处理器类实现HandlerExceptionResolver 123456789101112131415public class MyExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; //处理异常的代码实现 //创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); if(e instanceof MyException)&#123; modelAndView.addObject(&quot;info&quot;,&quot;自定义异常&quot;); &#125; else if(e instanceof ClassCastException)&#123; modelAndView.addObject(&quot;info&quot;,&quot;类型转换异常&quot;); &#125; modelAndView.setViewName(&quot;error&quot;); return modelAndView; &#125;&#125; ②配置异常处理器 1&lt;bean id=&quot;exceptionResolver&quot; class=&quot;com.itheima.exception.MyExceptionResolver&quot;/&gt; ③编写异常页面 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;$&#123;info&#125;&lt;/h1&gt; 这是一个最终异常的显示页面&lt;/body&gt;&lt;/html&gt; ④测试异常跳转 123456@RequestMapping(&quot;/quick22&quot;)@ResponseBodypublic void quickMethod22() throws IOException, ParseException &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); simpleDateFormat.parse(&quot;abcde&quot;);&#125; 1.5 知识要点异常处理方式 配置简单异常处理器SimpleMappingExceptionResolver 自定义异常处理器 自定义异常处理步骤 ①创建异常处理器类实现HandlerExceptionResolver②配置异常处理器③编写异常页面④测试异常跳转","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"07_SpringMVC拦截器","slug":"黑马程序员/SSM框架/07_SpringMVC拦截器","date":"2021-07-28T02:34:36.000Z","updated":"2021-07-28T02:44:44.803Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/07_SpringMVC拦截器/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/07_SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"","text":"1.SpringMVC 拦截器1.1 拦截器（interceptor）的作用Spring MVC 的拦截器类似于Servlet 开发中的过滤器Filter，用于对处理器进行预处理和后处理。 将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（Interceptor Chain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。 1.2 拦截器和过滤器区别 区别 过滤器 拦截器 使用范围 是servlet 规范中的一部分，任何Java Web 工程都可以使用 是SpringMVC 框架自己的，只有使用了SpringMVC 框架的工程才能用 拦截范围 在url pattern 中配置了/*之后，可以对所有要访问的资源拦截 只会拦截访问的控制器方法，如果访问的是jsp,html,css,image 或者 js 是不会进行拦截的 1.3 拦截器是快速入门自定义拦截器很简单，只有如下三步： ①创建拦截器类实现HandlerInterceptor接口②配置拦截器③测试拦截器的拦截效果 ①创建拦截器类实现HandlerInterceptor接口 12345678910111213141516171819public class MyHandlerInterceptor1 implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; System.out.println(&quot;preHandle running...&quot;); String param = request.getParameter(&quot;param&quot;); if(&quot;yes&quot;.equals(param))&#123; return true; &#125; esle &#123; request.getRequestDispatcher(&quot;/error.jsp&quot;).forward(request,response); reurn false; &#125; &#125; public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; modelAndView.addObject(&quot;name&quot;,&quot;itheima&quot;); System.out.println(&quot;postHandle running...&quot;); &#125; public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; System.out.println(&quot;afterCompletion running...&quot;); &#125;&#125; ②配置拦截器 1234567891011&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyHandlerInterceptor1&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyHandlerInterceptor2&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 12345678&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/user/login&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyHandlerInterceptor1&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ③测试拦截器的拦截效果（编写目标方法） 123456789@RequestMapping(&quot;/quick23&quot;)@ResponseBodypublic ModelAndViewquickMethod23() throws IOException, ParseException&#123; System.out.println(&quot;目标方法执行....&quot;); ModelAndView modelAndView= new ModelAndView(); modelAndView.addObject(&quot;name&quot;,&quot;itcast&quot;); modelAndView.setViewName(&quot;index&quot;); return modelAndView;&#125; http://localhost:8080/itheima_springmvc1/quick23 控制台打印结果 1.4 多拦截器操作同上，在编写一个MyHandlerInterceptor2操作，测试执行顺序 1.5 拦截器方法说明 方法名 说明 preHandle() 方法将在请求处理之前进行调用，该方法的返回值是布尔值Boolean 类型的，当它返回为 false 时，表示请求结束，后续的 Interceptor 和 Controller 都不会再执行；当返回值为 true 时就会继续调用下一个 Interceptor 的 preHandle 方法 postHandle() 该方法是在当前请求进行处理之后被调用，前提是preHandle 方法的返回值为true 时才能被调用，且它会在 DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对 Controller 处理之后的 ModelAndView 对象进行操作 afterCompletion() 该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行，前提是 preHandle 方法的返回值为 true 时才能被调用 1.6 知识要点自定义拦截器步骤 ①创建拦截器类实现HandlerInterceptor接口②配置拦截器③测试拦截器的拦截效果 1.7 案例-用户登录权限控制需求：用户没有登录的情况下，不能对后台菜单进行访问操作，点击菜单跳转到登录页面，只有用户登录成功后才能进行后台功能的操作","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"06_练习","slug":"黑马程序员/SSM框架/06_练习","date":"2021-07-28T02:34:21.000Z","updated":"2021-07-28T02:44:24.244Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/06_练习/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/06_%E7%BB%83%E4%B9%A0/","excerpt":"","text":"1. Spring练习环境搭建1.1 Spring环境搭建步骤①创建工程（Project&amp;Module）②导入静态页面（见资料jsp页面）③导入需要坐标（见资料中的pom.xml）④创建包结构（controller、service、dao、domain、utils）⑤导入数据库脚本（见资料test.sql）⑥创建POJO类（见资料User.java和Role.java）⑦创建配置文件（applicationContext.xml、spring-mvc.xml、jdbc.properties、log4j.properties） 1.2 用户和角色的关系 2.角色列表的展示和添加操作2.1 角色列表的展示效果 2.2 角色列表的展示步骤分析①点击角色管理菜单发送请求到服务器端（修改角色管理菜单的url地址）②创建RoleController和showList()方法③创建RoleService和showList()方法④创建RoleDao和findAll()方法⑤使用JdbcTemplate完成查询操作⑥将查询数据存储到Model中⑦转发到role-list.jsp页面进行展示 2.3 角色添加的效果 2.4 角色添加的步骤分析①点击列表页面新建按钮跳转到角色添加页面②输入角色信息，点击保存按钮，表单数据提交服务器③编写RoleController的save()方法④编写RoleService的save()方法⑤编写RoleDao的save()方法⑥使用JdbcTemplate保存Role数据到sys_role⑦跳转回角色列表页面 3.用户列表的展示和添加操作3.1 用户列表的展示效果 3.2 用户列表的展示步骤分析①点击用户管理菜单发送请求到服务器端（修改用户管理菜单的url地址）②创建RoleController和showList()方法③创建RoleService和showList()方法④创建RoleDao和findAll()方法⑤使用JdbcTemplate完成查询操作⑥将查询数据存储到Model中⑦转发到user-list.jsp页面进行展示 3.3 用户添加的效果 3.4 用户添加的步骤分析①点击列表页面新建按钮跳转到角色添加页面②输入角色信息，点击保存按钮，表单数据提交服务器③编写RoleController的save()方法④编写RoleService的save()方法⑤编写RoleDao的save()方法⑥使用JdbcTemplate保存Role数据到sys_role⑦跳转回角色列表页面 4. 删除用户操作4.1 删除用户的效果 4.2 删除用户的步骤分析①点击用户列表的删除按钮，发送请求到服务器端②编写UserController的deleteById()方法③编写UserService的deleteById()方法④编写UserDao的deleteById()方法⑤编写UserDao的deleteRelByUid()方法⑥跳回当前用户列表页面","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"05_JDBC模板","slug":"黑马程序员/SSM框架/05_JDBC模板","date":"2021-07-28T02:34:00.000Z","updated":"2021-07-28T02:43:54.800Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/05_JDBC模板/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/05_JDBC%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"1. Spring JdbcTemplate基本使用1.1 JdbcTemplate概述它是spring框架中提供的一个对象，是对原始繁琐的JdbcAPI对象的简单封装。spring框架为我们提供了很多的操作模板类。例如：操作关系型数据的JdbcTemplate和HibernateTemplate，操作nosql数据库的RedisTemplate，操作消息队列的JmsTemplate等等。 1.2 JdbcTemplate开发步骤①导入spring-jdbc和spring-tx坐标②创建数据库表和实体③创建JdbcTemplate对象④执行数据库操作 1.3 JdbcTemplate快速入门①导入坐标 12345678910111213&lt;!--springcontext依赖 c3p0 commosio mysql-connector-java等也需要自己导入，具体参考案例--&gt;&lt;!--导入spring的jdbc坐标--&gt;&lt;dependency &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--导入spring的tx坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; ②创建accout表和Accout实体 12345public class Account &#123; private String name; private double money; //省略get和set方法&#125; ③创建JdbcTemplate对象④执行数据库操作 123456789101112//1、创建数据源对象ComboPooledDataSource dataSource= new ComboPooledDataSource();dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);dataSource.setUser(&quot;root&quot;);dataSource.setPassword(&quot;root&quot;);//2、创建JdbcTemplate对象JJdbcTemplate jdbcTemplate= new JdbcTemplate();//3、设置数据源给JdbcTemplatejdbcTemplate.setDataSource(dataSource);//4、执行操作jdbcTemplate.update(&quot;insert into account values(?,?)&quot;,&quot;tom&quot;,5000); 1.4 Spring产生JdbcTemplate对象我们可以将JdbcTemplate的创建权交给Spring，将数据源DataSource的创建权也交给Spring，在Spring容器内部将数据源DataSource注入到JdbcTemplate模版对象中，配置如下： 1234567891011&lt;!--数据源DataSource--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///test&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--JdbcTemplate--&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 从容器中获得JdbcTemplate进行添加操作 123456@Testpublic void testSpringJdbcTemplate() throws PropertyVetoException&#123; ApplicationContext applicationContext= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); JdbcTemplate jdbcTemplate= applicationContext.getBean(JdbcTemplate.class); jdbcTemplate.update(&quot;insert into account values(?,?)&quot;,&quot;lucy&quot;,5000);&#125; 数据库配置一般与spirng的xml文件分开，使用jdbc.properties文件存储 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=root 修改xml文件（熟记） 1234567891011121314151617&lt;!--添加命名空间--&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd &lt;!--加载jdbc.properties--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--数据源对象--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!--JdbcTemplate--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 1.5 JdbcTemplate的常用操作修改操作 123456789101112//需要导入相关依赖@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class JdbcTemplateCRUDTest&#123; @Autowired private JdbcTemplate jdbcTemplate; @Test //测试修改操作 public void testUpdate()&#123; jdbcTemplate.update(&quot;update account set money=? where name=?&quot;,1000,&quot;tom&quot;); &#125;&#125; 删除和查询全部操作 1234567891011@Testpublic void testDelete()&#123; jdbcTemplate.update(&quot;delete from account where name=?&quot;,&quot;tom&quot;);&#125;@Testpublic void testQueryAll()&#123; List&lt;Account&gt; accounts = jdbcTemplate.query(&quot;select *from account&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); for (Account account: accounts) &#123; System.out.println(account.getName()); &#125;&#125; 查询单个数据操作操作 1234567891011121314@Test//测试查询单个对象操作public void testQueryOne()&#123; Account account= jdbcTemplate.queryForObject(&quot;select *from account where name=?&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class), &quot;tom&quot;); System.out.println(account.getName());&#125;@Test//测试查询单个简单数据操作(聚合查询)public void testQueryCount()&#123; Long aLong= jdbcTemplate.queryForObject(&quot;select count(*) from account&quot;, Long.class); System.out.println(aLong);&#125; 1.6 知识要点①导入spring-jdbc和spring-tx坐标②创建数据库表和实体③创建JdbcTemplate对象 12JdbcTemplatejdbcTemplate= new JdbcTemplate();jdbcTemplate.setDataSource(dataSource); ④执行数据库操作 更新操作：jdbcTemplate.update(sql,params) 查询操作： 12jdbcTemplate.query(sql,Mapper,params)jdbcTemplate.queryForObject(sql,Mapper,params)","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"04_SpringMVC的请求和响应","slug":"黑马程序员/SSM框架/04_SpringMVC的请求和响应","date":"2021-07-28T02:07:21.000Z","updated":"2021-07-28T02:43:27.212Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/04_SpringMVC的请求和响应/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/04_SpringMVC%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/","excerpt":"","text":"1. SpringMVC的数据响应1.1 SpringMVC的数据 响应方式1）页面跳转 直接返回字符串 通过ModelAndView对象返回 2）回写数据 直接返回字符串 返回对象或集合 1.2 页面跳转1. 返回字符串形式直接返回字符串：此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转。 返回带有前缀的字符串： 转发：forward:/WEB-INF/views/index.jsp 重定向：redirect:/index.jsp 2. 返回ModelAndView对象123456789101112@RequestMapping(&quot;/quick2&quot;)public ModelAndView quickMethod2()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(&quot;redirect:index.jsp&quot;); return modelAndView;&#125;@RequestMapping(&quot;/quick3&quot;)public ModelAndView quickMethod3()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(&quot;forward:/WEB-INF/views/index.jsp&quot;); return modelAndView;&#125; 3. 向request域存储数据在进行转发时，往往要向request域中存储数据，在jsp页面中显示，那么Controller中怎样向request域中存储数据呢？ ①通过SpringMVC框架注入的request对象setAttribute()方法设置 12345@RequestMapping(&quot;/quick&quot;)public String quickMethod(HttpServletRequest request)&#123; request.setAttribute(&quot;name&quot;,&quot;zhangsan&quot;); return &quot;index&quot;;&#125; ②通过ModelAndView的addObject()方法设置 1234567@RequestMapping(&quot;/quick3&quot;)public ModelAndView quickMethod3()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(&quot;forward:/WEB-INF/views/index.jsp&quot;); modelAndView.addObject(&quot;name&quot;,&quot;lisi&quot;); return modelAndView;&#125; 1.3 回写数据1. 直接返回字符串Web基础阶段，客户端访问服务器端，如果想直接回写字符串作为响应体返回的话，只需要使用response.getWriter().print(&quot;hello world&quot;) 即可，那么在Controller中想直接回写字符串该怎样呢？ ①通过SpringMVC框架注入的response对象，使用response.getWriter().print(&quot;hello world&quot;) 回写数据，此时不需要视图跳转，业务方法返回值为void。 1234@RequestMapping(&quot;/quick4&quot;)public void quickMethod4(HttpServletResponse response) throws IOException &#123; response.getWriter().print(&quot;hello world&quot;);&#125; ②将需要回写的字符串直接返回，但此时需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回。 12345@RequestMapping(&quot;/quick5&quot;)@ResponseBodypublic String quickMethod5() throws IOException &#123; return &quot;hello springMVC!!!&quot;;&#125; 在异步项目中，客户端与服务器端往往要进行json格式字符串交互，此时我们可以手动拼接json字符串返回。 12345@RequestMapping(&quot;/quick6&quot;)@ResponseBodypublic String quickMethod6() throws IOException &#123; return &quot;&#123;\\&quot;name\\&quot;:\\&quot;zhangsan\\&quot;,\\&quot;age\\&quot;:18&#125;&quot;;&#125; 上述方式手动拼接json格式字符串的方式很麻烦，开发中往往要将复杂的java对象转换成json格式的字符串，我们可以使用web阶段学习过的json转换工具jackson进行转换，导入jackson坐标。 12345678910111213141516&lt;!--jackson--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 通过jackson转换json格式字符串，回写字符串。 12345678910@RequestMapping(&quot;/quick7&quot;)@ResponseBodypublic String quickMethod7() throws IOException&#123; User user= new User(); user.setUsername(&quot;zhangsan&quot;); user.setAge(18); ObjectMapper objectMapper= new ObjectMapper(); String s = objectMapper.writeValueAsString(user); return s;&#125; 2. 返回对象或集合通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc.xml中进行如下配置： 12345678910&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation .RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.http.converter.json .MappingJackson2HttpMessageConverter&quot;&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 12345678@RequestMapping(&quot;/quick8&quot;)@ResponseBodypublic User quickMethod8() throws IOException &#123; User user = new User(); user.setUsername(&quot;zhangsan&quot;); user.setAge(18); return user;&#125; 在方法上添加@ResponseBody就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置。 12&lt;!--mvc的注解驱动--&gt;&lt;mvc:annotation-driven/&gt; 在SpringMVC的各个组件中，处理器映射器、处理器适配器、视图解析器称为SpringMVC的三大组件。使用&lt;mvc:annotation-driven&gt;自动加载RequestMappingHandlerMapping（处理映射器）和RequestMappingHandlerAdapter（处理适配器），可用在Spring-xml.xml配置文件中使用&lt;mvc:annotation-driven&gt;替代注解处理器和适配器的配置。同时使用&lt;mvc:annotation-driven&gt;默认底层就会集成jackson进行对象或集合的json格式字符串的转换。 2. SpringMVC获得请求数据2.1 获得请求参数客户端请求参数的格式是：name=value&amp;name=value… … 服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数： 基本类型参数 POJO类型参数 数组类型参数 集合类型参数 2.2 获得基本类型参数Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。 http://localhost:8080/itheima_springmvc1/quick9?username=zhangsan&amp;age=12 123456@RequestMapping(&quot;/quick9&quot;)@ResponseBodypublic void quickMethod9(String username,int age) throws IOException &#123; System.out.println(username); System.out.println(age);&#125; 2.3 获得POJO类型参数Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。 http://localhost:8080/itheima_springmvc1/quick9?username=zhangsan&amp;age=12 1234567891011public class User &#123; private String username; private int age; getter/setter…&#125;@RequestMapping(&quot;/quick10&quot;)@ResponseBodypublic void quickMethod10(User user) throws IOException &#123; System.out.println(user);&#125; 2.4 获得数组类型参数Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。 http://localhost:8080/itheima_springmvc1/quick11?strs=111&amp;strs=222&amp;strs=333 12345@RequestMapping(&quot;/quick11&quot;)@ResponseBodypublic void quickMethod11(String[] strs) throws IOException &#123; System.out.println(Arrays.asList(strs));&#125; 2.5 获得集合类型参数获得集合参数时，要将集合参数包装到一个POJO中才可以。 1234567&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/quick12&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;userList[0].username&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;userList[0].age&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;userList[1].username&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;userList[1].age&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt;&lt;/form&gt; 12345@RequestMapping(&quot;/quick12&quot;)@ResponseBodypublic void quickMethod12(Vo vo) throws IOException &#123; System.out.println(vo.getUserList());&#125; 12345678910111213141516public class VO &#123; private List&lt;User&gt; userList; public List&lt;User&gt; getUserList() &#123; return userList; &#125; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125; @Override public String toString() &#123; return &quot;VO&#123;&quot; + &quot;userList=&quot; + userList + &#x27;&#125;&#x27;; &#125;&#125; 当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装。 123456789101112&lt;script&gt; //模拟数据 var userList = new Array(); userList.push(&#123;username: &quot;zhangsan&quot;,age: &quot;20&quot;&#125;); userList.push(&#123;username: &quot;lisi&quot;,age: &quot;20&quot;&#125;); $.ajax(&#123; type: &quot;POST&quot;, url: &quot;/itheima_springmvc1/quick13&quot;, data: JSON.stringify(userList), contentType : &#x27;application/json;charset=utf-8&#x27; &#125;);&lt;/script&gt; 当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装。 12345@RequestMapping(&quot;/quick13&quot;)@ResponseBodypublic void quickMethod13(@RequestBody List&lt;User&gt; userList) throws IOException &#123; System.out.println(userList);&#125; 注意：通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是/,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源： 在spring-mvc.xml配置文件中指定放行的资源&lt;mvc:resources mapping=”/js/**” location=”/js/“/&gt; 使用&lt;mvc:default-servlet-handler/&gt; 标签 2.6 请求数据乱码问题当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。 123456789101112&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2.7 参数绑定注解@requestParam当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定。 1234&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/quick14&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 12345@RequestMapping(&quot;/quick14&quot;)@ResponseBodypublic void quickMethod14(@RequestParam(&quot;name&quot;) String username) throws IOException &#123; System.out.println(username);&#125; 注解@RequestParam还有如下参数可以使用： value：与请求参数名称 required：此在指定的请求参数是否必须包括，默认是true，提交时如果没有此参数则报错 defaultValue：当没有指定请求参数时，则使用指定的默认值赋值 12345@RequestMapping(&quot;/quick14&quot;)@ResponseBodypublic void quickMethod14(@RequestParam(value=&quot;name&quot;,required = false,defaultValue = &quot;itcast&quot;) String username) throws IOException &#123; System.out.println(username);&#125; 2.8 获得Restful风格的参数Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。 Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下： GET：用于获取资源 POST：用于新建资源 PUT：用于更新资源 DELETE：用于删除资源 例如： /user/1 GET ：得到id = 1 的user /user/1 DELETE：删除id = 1 的user /user/1 PUT：更新id = 1 的user /user POST：新增user 2.8 获得Restful风格的参数上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符&#123;id&#125; 对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。 http://localhost:8080/itheima_springmvc1/quick19/zhangsan 12345@RequestMapping(&quot;/quick19/&#123;name&#125;&quot;)@ResponseBodypublic void quickMethod19(@PathVariable(value = &quot;name&quot;,required = true) String name)&#123; System.out.println(name);&#125; 2.9 自定义类型转换器 SpringMVC默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。 但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。 自定义类型转换器的开发步骤：①定义转换器类实现Converter接口②在配置文件中声明转换器③在中引用转换器 ①定义转换器类实现Converter接口 12345678910111213public class DateConverter implements Converter&lt;String,Date&gt;&#123; @Override public Date convert(String source) &#123; SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); try &#123; Date date = format.parse(source); return date; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; ②在配置文件中声明转换器 1234567&lt;bean id=&quot;converterService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;com.itheima.converter.DateConverter&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; ③在中引用转换器 &lt;mvc:annotation-driven conversion-service=&quot;converterService&quot;/&gt; 2.10 获得Servlet相关APISpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下： HttpServletRequest HttpServletResponse HttpSession 1234567@RequestMapping(&quot;/quick16&quot;)@ResponseBodypublic void quickMethod16(HttpServletRequest request,HttpServletResponse response,HttpSession session)&#123; System.out.println(request); System.out.println(response); System.out.println(session);&#125; 2.11 获得请求头1. @RequestHeader使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name) @RequestHeader注解的属性如下： value：请求头的名称 required：是否必须携带此请求头 12345@RequestMapping(&quot;/quick17&quot;)@ResponseBodypublic void quickMethod17(@RequestHeader(value = &quot;User-Agent&quot;,required = false) String headerValue)&#123; System.out.println(headerValue);&#125; 2. @CookieValue使用@CookieValue可以获得指定Cookie的值 @CookieValue注解的属性如下： value：指定cookie的名称 required：是否必须携带此cookie 12345@RequestMapping(&quot;/quick18&quot;)@ResponseBodypublic void quickMethod18(@CookieValue(value = &quot;JSESSIONID&quot;,required = false) String jsessionid)&#123; System.out.println(jsessionid);&#125; 2.12 文件上传1. 文件上传客户端三要素 表单项type=“file” 表单的提交方式是post 表单的enctype属性是多部分表单形式，及enctype=“multipart/form-data” 12345&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/quick20&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 名称：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 文件：&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt;&lt;/form&gt; 2. 文件上传原理 当form表单修改为多部分表单时，request.getParameter()将失效。 enctype=“application/x-www-form-urlencoded”时，form表单的正文内容格式是：key=value&amp;key=value&amp;key=value 当form表单的enctype取值为Mutilpart/form-data时，请求正文内容就变成多部分形式： 2.13 单文件上传步骤①导入fileupload和io坐标②配置文件上传解析器③编写文件上传代码 2.14 单文件上传实现①导入 fileupload 和 io 坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; ②配置文件上传解析器 123456789&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!--上传文件总大小--&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242800&quot;/&gt; &lt;!--上传单个文件的大小--&gt; &lt;property name=&quot;maxUploadSizePerFile&quot; value=&quot;5242800&quot;/&gt; &lt;!--上传文件的编码类型--&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;&lt;/bean&gt; ③编写文件上传代码 12345678@RequestMapping(&quot;/quick20&quot;)@ResponseBodypublic void quickMethod20(String name,MultipartFile uploadFile) throws IOException &#123; //获得文件名称 String originalFilename = uploadFile.getOriginalFilename(); //保存文件 uploadFile.transferTo(new File(&quot;C:\\\\upload\\\\&quot;+originalFilename));&#125; 2.15 多文件上传实现多文件上传，只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型修改为MultipartFile[]即可 123456789&lt;h1&gt;多文件上传测试&lt;/h1&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/quick21&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 名称：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 文件1：&lt;input type=&quot;file&quot; name=&quot;uploadFiles&quot;&gt;&lt;br&gt; 文件2：&lt;input type=&quot;file&quot; name=&quot;uploadFiles&quot;&gt;&lt;br&gt; 文件3：&lt;input type=&quot;file&quot; name=&quot;uploadFiles&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt;&lt;/form&gt; 12345678@RequestMapping(&quot;/quick21&quot;)@ResponseBodypublic void quickMethod21(String name,MultipartFile[] uploadFiles) throws IOException &#123; for (MultipartFile uploadFile : uploadFiles)&#123; String originalFilename = uploadFile.getOriginalFilename(); uploadFile.transferTo(new File(&quot;C:\\\\upload\\\\&quot;+originalFilename)); &#125;&#125;","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"03_MVC入门","slug":"黑马程序员/SSM框架/03_MVC入门","date":"2021-07-28T02:07:00.000Z","updated":"2021-07-28T02:43:09.791Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/03_MVC入门/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/03_MVC%E5%85%A5%E9%97%A8/","excerpt":"","text":"1. Spring集成web环境1.1 ApplicationContext应用上下文获取方式应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件) 方式获取的，但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件)，这样的弊端是配置文件加载多次，应用上下文对象创建多次。 在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。 1.2 Spring提供获取应用上下文的工具上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。 所以我们需要做的只有两件事： ①在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标）②使用WebApplicationContextUtils获得应用上下文对象ApplicationContext 1.3 导入Spring集成web的坐标12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 1.4 配置ContextLoaderListener监听器123456789101112&lt;!--web.xml中--&gt;&lt;!--全局参数--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--Spring的监听器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt; 1.5 通过工具获得应用上下文对象123ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(servletContext);Object obj = applicationContext.getBean(&quot;id&quot;); Spring集成web环境步骤 ①配置ContextLoaderListener监听器②使用WebApplicationContextUtils获得应用上下文 2. SpringMVC简介2.1 SpringMVC概述SpringMVC是一种基于Java 的实现MVC 设计模型的请求驱动类型的轻量级Web 框架，属于SpringFrameWork的后续产品，已经融合在Spring Web Flow 中。 SpringMVC已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越Struts2，成为最优秀的MVC 框架。它通过一套注解，让一个简单的Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful编程风格的请求。 2.2 SpringMVC快速入门需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。 开发步骤： ①导入SpringMVC相关坐标②配置SpringMVC核心控制器DispathcerServlet③创建Controller类和视图页面④使用注解配置Controller类中业务方法的映射地址⑤配置SpringMVC核心文件spring-mvc.xml⑥客户端发起请求测试 ①导入Spring和SpringMVC的坐标 123456789101112&lt;!--Spring坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--SpringMVC坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; ①导入Servlet和Jsp的坐标 123456789101112&lt;!--Servlet坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--Jsp坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId &gt;&lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; ②在web.xml配置SpringMVC的核心控制器 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ③创建Controller和业务方法 123456public class QuickController &#123; public String quickMethod()&#123; System.out.println(&quot;quickMethod running.....&quot;); return &quot;index&quot;; &#125;&#125; ③创建视图页面index.jsp 12345&lt;html&gt; &lt;body&gt; &lt;h2&gt;Hello SpringMVC!&lt;/h2&gt; &lt;/body&gt;&lt;/html&gt; ④配置注解 12345678@Controllerpublic class QuickController &#123;@RequestMapping(&quot;/quick&quot;) public String quickMethod()&#123; System.out.println(&quot;quickMethod running.....&quot;); return &quot;index&quot;; &#125;&#125; ⑤创建spring-mvc.xml 12345678910111213&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--配置注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;&lt;/beans&gt; ⑥访问测试地址 ![3bf85dedf23dc49ba1d0f13506927621.png](en-resource://database/1983:2) http://localhost:8080/itheima_springmvc1/quick 控制台打印 页面显示 2.3 SpringMVC流程图示 2.4 知识要点SpringMVC的开发步骤 ①导入SpringMVC相关坐标②配置SpringMVC核心控制器DispathcerServlet③创建Controller类和视图页面④使用注解配置Controller类中业务方法的映射地址⑤配置SpringMVC核心文件spring-mvc.xml⑥客户端发起请求测试 3. SpringMVC组件解析3.1 SpringMVC的执行流程 ①用户发送请求至前端控制器DispatcherServlet。②DispatcherServlet收到请求调用HandlerMapping处理器映射器。③处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。④DispatcherServlet调用HandlerAdapter处理器适配器。⑤HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。⑥Controller执行完成返回ModelAndView。⑦HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。⑧DispatcherServlet将ModelAndView传给ViewReslover视图解析器。⑨ViewReslover解析后返回具体View。⑩DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户。 3.2 SpringMVC组件解析 前端控制器：DispatcherServlet 用户请求到达前端控制器，它就相当于MVC 模式中的C，DispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性。 处理器映射器：HandlerMapping HandlerMapping负责根据用户请求找到Handler 即处理器，SpringMVC提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 处理器适配器：HandlerAdapter 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 处理器：Handler 它就是我们开发中要编写的具体业务控制器。由DispatcherServlet把用户请求转发到Handler。由Handler 对具体的用户请求进行处理。 视图解析器：View Resolver View Resolver 负责将处理结果生成View 视图，View Resolver 首先根据逻辑视图名解析成物理视名，即具体的页面地址，再生成View 视图对象，最后对View 进行渲染将处理结果通过页面展示给用户。 视图：View SpringMVC框架提供了很多的View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面 3.3 SpringMVC注解解析@RequestMapping 作用：用于建立请求URL 和处理请求方法之间的对应关系 位置： 类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录 方法上，请求URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径 属性： value：用于指定请求的URL。它和path属性的作用是一样的 method：用于指定请求的方式 params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样 例如： params= {“accountName”}，表示请求参数必须有accountName params= {“moeny!100”}，表示请求参数中money不能是100 mvc命名空间引入 命名空间：xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; 约束地址：http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd 组件扫描 SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用&lt;context:component-scanbase-package=“com.itheima.controller&quot;/&gt;进行组件扫描。 3.4 SpringMVC的XML配置解析 视图解析器 SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org/springframework/web/servlet/DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下： org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver 翻看该解析器源码，可以看到该解析器的默认设置，如下： 1234REDIRECT_URL_PREFIX = &quot;redirect:&quot; --重定向前缀FORWARD_URL_PREFIX = &quot;forward:&quot; --转发前缀（默认值）prefix = &quot;&quot;; --视图名称前缀suffix = &quot;&quot;; --视图名称后缀 我们可以通过属性注入的方式修改视图的的前后缀 123456&lt;!--配置内部资源视图解析器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 3.5 知识要点SpringMVC的相关组件 前端控制器：DispatcherServlet 处理器映射器：HandlerMapping 处理器适配器：HandlerAdapter 处理器：Handler 视图解析器：View Resolver 视图：View SpringMVC的注解和配置 请求映射注解：@RequestMapping 视图解析器配置： 1234REDIRECT_URL_PREFIX = &quot;redirect:&quot; FORWARD_URL_PREFIX = &quot;forward:&quot; prefix = &quot;&quot;; suffix = &quot;&quot;;","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"02_IoC和DI注解开发","slug":"黑马程序员/SSM框架/02_IoC和DI注解开发","date":"2021-07-28T02:03:43.000Z","updated":"2021-07-28T02:42:46.779Z","comments":true,"path":"2021/07/28/黑马程序员/SSM框架/02_IoC和DI注解开发/","link":"","permalink":"http://example.com/2021/07/28/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/02_IoC%E5%92%8CDI%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","excerpt":"","text":"1.Spring配置数据源1.1 数据源（连接池）的作用•数据源(连接池)是提高程序性能如出现的•事先实例化数据源，初始化部分连接资源•使用连接资源时从数据源中获取•使用完毕后将连接资源归还给数据源 常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等 数据源的开发步骤 ①导入数据源的坐标和数据库驱动坐标②创建数据源对象③设置数据源的基本连接数据④使用数据源获取连接资源和归还连接资源 1.2 数据源的手动创建①导入c3p0和druid的坐标 123456789101112&lt;!--C3P0连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--Druid连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; ①导入mysql数据库驱动坐标 123456&lt;!--mysql驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.39&lt;/version&gt;&lt;/dependency&gt; ②创建C3P0连接池 12345678910111213@Testpublic void testC3P0() throws Exception &#123; //创建数据源 ComboPooledDataSource dataSource = new ComboPooledDataSource(); //设置数据库连接参数 dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; ②创建Druid连接池 12345678910111213@Testpublic void testDruid() throws Exception &#123; //创建数据源 DruidDataSource dataSource = new DruidDataSource(); //设置数据库连接参数 dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; ③提取jdbc.properties配置文件 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=root ④读取jdbc.properties配置文件创建连接池 123456789101112@Testpublic void testC3P0ByProperties() throws Exception &#123; //加载类路径下的 jdbc.propertiesResourceBundle rb = ResourceBundle.getBundle(&quot;jdbc&quot;); ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(rb.getString(&quot;jdbc.driver&quot;)); dataSource.setJdbcUrl(rb.getString(&quot;jdbc.url&quot;)); dataSource.setUser(rb.getString(&quot;jdbc.username&quot;)); dataSource.setPassword(rb.getString(&quot;jdbc.password&quot;)); Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; 1.3 Spring配置数据源可以将DataSource的创建权交由Spring容器去完成 DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的 DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入 123456&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/bean&gt; 测试从容器当中获取数据源 1234ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);DataSource dataSource = (DataSource) applicationContext.getBean(&quot;dataSource&quot;);Connection connection = dataSource.getConnection();System.out.println(connection); 1.4 抽取jdbc配置文件applicationContext.xml加载jdbc.properties配置文件获得连接信息。 首先，需要引入context命名空间和约束路径： 命名空间：xmlns:context=”http://www.springframework.org/schema/context&quot; 约束路径：http://www.springframework.org/schema/context ` http://www.springframework.org/schema/context/spring-context.xsd` 1234567&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt; 1.5 知识要点Spring容器加载properties文件 12&lt;context:property-placeholder location=&quot;xx.properties&quot;/&gt;&lt;property name=&quot;&quot; value=&quot;$&#123;key&#125;&quot;/&gt; 2.Spring注解开发2.1 Spring原始注解Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。 Spring原始注解主要是替代的配置 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 注意： 使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。 12&lt;!--注解的组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt; 使用@Compont或@Repository标识UserDaoImpl需要Spring进行实例化。 12345678//@Component(&quot;userDao&quot;)@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(&quot;save running... ...&quot;); &#125;&#125; 使用@Compont或@Service标识UserServiceImpl需要Spring进行实例化 使用@Autowired或者@Autowired+@Qulifier或者@Resource进行userDao的注入 123456789101112//@Component(&quot;userService&quot;)@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService &#123; /*@Autowired @Qualifier(&quot;userDao&quot;)*/ @Resource(name=&quot;userDao&quot;) private UserDao userDao; @Override public void save() &#123; userDao.save(); &#125;&#125; 使用@Value进行字符串的注入 12345678910111213@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123; @Value(&quot;注入普通数据&quot;) private String str; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Override public void save() &#123; System.out.println(str); System.out.println(driver); System.out.println(&quot;save running... ...&quot;); &#125;&#125; 使用@Scope标注Bean的范围 //@Scope(“prototype”)@Scope(“singleton”)public class UserDaoImpl implements UserDao { //此处省略代码} 使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法 12345678@PostConstructpublic void init()&#123; System.out.println(&quot;初始化方法....&quot;);&#125;@PreDestroypublic void destroy()&#123; System.out.println(&quot;销毁方法.....&quot;);&#125; 2.2 Spring新注解使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下： 非自定义的Bean的配置：&lt;bean&gt; 加载properties文件的配置：&lt;context:property-placeholder&gt; 组件扫描的配置：&lt;context:component-scan&gt; 引入其他文件：&lt;import&gt; 注解 说明 @Configuration 用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解 @ComponentScan 用于指定 Spring 在初始化容器时要扫描的包。 作用和在 Spring 的 xml 配置文件中的 &lt;context:component-scan base-package=”com.itheima”/&gt;一样 @Bean 使用在方法上，标注将该方法的返回值存储到 Spring 容器中 @PropertySource 用于加载.properties 文件中的配置 @Import 用于导入其他配置类 @Configuration @ComponentScan @Import 12345@Configuration@ComponentScan(&quot;com.itheima&quot;)@Import(&#123;DataSourceConfiguration.class&#125;)public class SpringConfiguration &#123;&#125; @PropertySource @value 1234567891011@PropertySource(&quot;classpath:jdbc.properties&quot;)public class DataSourceConfiguration &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password;&#125; @Bean 123456789@Bean(name=&quot;dataSource&quot;)public DataSource getDataSource() throws PropertyVetoException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); return dataSource;&#125; 测试加载核心配置类创建Spring容器 123456789@Testpublic void testAnnoConfiguration() throws Exception &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfiguration.class); UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;); userService.save(); DataSource dataSource = (DataSource) applicationContext.getBean(&quot;dataSource&quot;); Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; 3. Spring集成Junit3.1 原始Junit测试Spring的问题在测试类中，每个测试方法都有以下两行代码： 12ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);IAccountService as = ac.getBean(&quot;accountService&quot;,IAccountService.class); 这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。 3.2 上述问题解决思路•让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它•将需要进行测试Bean直接在测试类中进行注入 3.3 Spring集成Junit步骤①导入spring集成Junit的坐标②使用@Runwith注解替换原来的运行期③使用@ContextConfiguration指定配置文件或配置类④使用@Autowired注入需要测试的对象⑤创建测试方法进行测试 3.4 Spring集成Junit代码实现①导入spring集成Junit的坐标 123456789101112&lt;!--此处需要注意的是，spring5 及以上版本要求junit 的版本必须是4.12 及以上--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; ②使用@Runwith注解替换原来的运行期 123@RunWith(SpringJUnit4ClassRunner.class)public class SpringJunitTest &#123;&#125; ③使用 @ContextConfiguration 指定配置文件或配置类 1234567@RunWith(SpringJUnit4ClassRunner.class)//加载spring核心配置文件//@ContextConfiguration(value = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)//加载spring核心配置类@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123;&#125; ④使用@Autowired注入需要测试的对象 123456@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123; @Autowired private UserService userService;&#125; ⑤创建测试方法进行测试 12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123; @Autowired private UserService userService; @Test public void testUserService()&#123; userService.save(); &#125;&#125; 3.5 知识要点Spring集成Junit步骤 ①导入spring集成Junit的坐标②使用@Runwith注解替换原来的运行期③使用@ContextConfiguration指定配置文件或配置类④使用@Autowired注入需要测试的对象⑤创建测试方法进行测试","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"01_IoC和DI","slug":"黑马程序员/SSM框架/01_IoC和DI","date":"2021-07-26T15:11:01.000Z","updated":"2021-07-28T02:42:17.545Z","comments":true,"path":"2021/07/26/黑马程序员/SSM框架/01_IoC和DI/","link":"","permalink":"http://example.com/2021/07/26/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/SSM%E6%A1%86%E6%9E%B6/01_IoC%E5%92%8CDI/","excerpt":"","text":"1. Spring简介1.1 Spring是什么Spring是分层的Java SE/EE应用full-stack 轻量级开源框架，以IoC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核。 提供了展现层SpringMVC和持久层Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。 1.2 Spring发展历程1997 年，IBM提出了EJB 的思想1998 年，SUN制定开发标准规范EJB1.01999 年，EJB1.1 发布2001 年，EJB2.0 发布2003 年，EJB2.1 发布2006 年，EJB3.0 发布 Rod Johnson （Spring 之父） Expert One-to-One J2EE Design and Development(2002)阐述了J2EE 使用EJB 开发设计的优点及解决方案 Expert One-to-One J2EE Development without EJB(2004)阐述了J2EE 开发不使用EJB的解决方式（Spring 雏形） 2017 年9 月份发布了Spring 的最新版本Spring5.0 通用版（GA） 1.3 Spring的优势1）方便解耦，简化开发通过Spring 提供的IoC容器，可以将对象间的依赖关系交由Spring 进行控制，避免硬编码所造成的过度耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 2）AOP 编程的支持通过Spring的AOP 功能，方便进行面向切面编程，许多不容易用传统OOP 实现的功能可以通过AOP 轻松实现。 3）声明式事务的支持可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务管理，提高开发效率和质量。 4）方便程序的测试可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。 5）方便集成各种优秀框架Spring对各种优秀框架（ Struts 、 Hibernate 、 Hessian 、 Quartz 等）的支持。 6）降低 JavaEE API 的使用难度Spring对 JavaEE API （如 JDBC 、 JavaMail 、远程调用等）进行了薄薄的封装层，使这些 API 的使用难度大为降低。 7）Java 源码是经典学习范例Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对 Java 设计模式灵活运用以及对 Java 技术的高深造诣。它的源代码无意是Java 技术的最佳实践的范例。 1.4 Spring的体系结构![223ba3738ce35e28651e751646b24899.png](01_IoC和DI/2031_1 (1).png) 2. Spring快速入门2.1 Spring程序开发步骤 ①导入Spring 开发的基本包坐标②编写Dao 接口和实现类③创建Spring 核心配置文件④在Spring 配置文件中配置UserDaoImpl⑤使用Spring 的API 获得Bean 实例 2.2 导入Spring开发的基本包坐标123456789101112&lt;properties&gt; &lt;spring.version&gt;5.0.5.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!--导入spring的context坐标，context依赖core、beans、expression--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.3编写 Dao 接口和实现类12345678910public interface UserDao &#123; public void save();&#125;public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 2.4 创建Spring核心配置文件在类路径下（resources）创建applicationContext.xml配置文件 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 2.5 在Spring配置文件中配置UserDaoImpl12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;/bean&gt;&lt;/beans&gt; 2.6 使用Spring的API获得Bean实例123456@Testpublic void test1()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save();&#125; 2.7 知识要点Spring的开发步骤 ①导入坐标②创建Bean③创建applicationContext.xml④在配置文件中进行配置⑤创建ApplicationContext对象getBean 3. Spring配置文件3.1 Bean标签基本配置用于配置对象交由Spring来创建。默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。 基本属性： id：Bean实例在Spring容器中的唯一标识 class：Bean的全限定名称 3.2 Bean标签范围配置scope：指对象的作用范围，取值如下： 取值范围 说明 singleton 默认值，单例的 prototype 多例的 request WEB项目中，Spring创建一个Bean的对象，将对象存入到request域中 session WEB项目中，Spring创建一个Bean的对象，将对象存入到session域中 global session WEB项目中，应用在Portlet环境，如果没有Portlet环境，那么global session相当于session 当scope的取值为singleton时 Bean的实例化个数：1个 Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例 Bean的生命周期： 对象创建：当应用加载，创建容器时，对象就被创建了 对象运行：只要容器在，对象一直活着 对象销毁：当应用卸载，销毁容器时，对象就被销毁了 2）当scope的取值为prototype时 Bean的实例化个数：多个 Bean的实例化时机：当调用getBean()方法时实例化Bean - 对象创建：当使用对象时，创建新的对象实例 - 对象运行：只要对象在使用中，就一直活着 - 对象销毁：当对象长时间不用时，被Java 的垃圾回收器回收了 3.3 Bean生命周期配置 init-method：指定类中的初始化方法名称 destroy-method：指定类中销毁方法名称 3.4 Bean实例化三种方式 无参构造方法实例化 工厂静态方法实例化 工厂实例方法实例化 1）使用无参构造方法实例化 它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; 2）工厂静态方法实例化 工厂的静态方法返回Bean实例 12345public class StaticFactoryBean &#123; public static UserDao createUserDao()&#123; return new UserDaoImpl(); &#125;&#125; 1&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.factory.StaticFactoryBean&quot; factory-method=&quot;createUserDao&quot; /&gt; 3）工厂实例方法实例化 工厂的非静态方法返回Bean实例 12345public class DynamicFactoryBean &#123; public UserDao createUserDao()&#123; return new UserDaoImpl(); &#125;&#125; 12&lt;bean id=&quot;factoryBean&quot; class=&quot;com.itheima.factory.DynamicFactoryBean&quot;/&gt;&lt;bean id=&quot;userDao&quot; factory-bean=&quot;factoryBean&quot; factory-method=&quot;createUserDao&quot;/&gt; 3.5 Bean的依赖注入入门①创建UserService，UserService 内部在调用UserDao的save() 方法 12345678public class UserServiceImpl implements UserService &#123; @Override public void save() &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); &#125;&#125; ②将UserServiceImpl 的创建权交给Spring &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;/&gt; ③从Spring 容器中获得UserService 进行操作 12ApplicationContext applicationContext= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);UserService userService= (UserService) applicationContext.getBean(&quot;userService&quot;);userService.save(); 3.6 Bean的依赖注入分析目前UserService实例和UserDao实例都存在与Spring容器中，当前的做法是在容器外部获得UserService实例和UserDao实例，然后在程序中进行结合。 ![2037_1 (1)](01_IoC和DI/2037_1 (1).png) 因为UserService和UserDao都在Spring容器中，而最终程序直接使用的是UserService，所以可以在Spring容器中，将UserDao设置到UserService内部。 3.7 Bean的依赖注入概念依赖注入（Dependency Injection）：它是Spring 框架核心IOC 的具体实现。 在编写程序时，通过控制反转，把对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况。IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。 那这种业务层和持久层的依赖关系，在使用Spring 之后，就让Spring 来维护了。简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。 怎么将UserDao怎样注入到UserService内部呢？ 构造方法 set方法 1）set方法注入 在UserServiceImpl中添加setUserDao方法 123456789public class UserServiceImplimplements UserService&#123; private UserDao userDao; public void setUserDao(UserDaouserDao) &#123; this.userDao= userDao; &#125; @Overridepublic void save() &#123; userDao.save(); &#125;&#125; 配置Spring容器调用set方法进行注入 12345&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt; P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下： 首先，需要引入P命名空间：xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 其次，需要修改注入方式 &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot; p:userDao-ref=&quot;userDao&quot;/&gt; 2）构造方法注入 创建有参构造 12345678public class UserServiceImpl implements UserService &#123; @Override public void save() &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); &#125;&#125; 配置Spring容器调用有参构造时进行注入 1234&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 3.8 Bean的依赖注入的数据类型上面的操作，都是注入的引用Bean，除了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。 注入数据的三种数据类型 普通数据类型 引用数据类型 集合数据类型 其中引用数据类型，此处就不再赘述了，之前的操作都是对UserDao对象的引用进行注入的，下面将以set方法注入为例，演示普通数据类型和集合数据类型的注入。 1）普通数据类型的注入 1234567891011121314public class UserDaoImpl implements UserDao &#123; private String company; private int age; public void setCompany(String company) &#123; this.company = company; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void save() &#123; System.out.println(company+&quot;===&quot;+age); System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 1234&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;company&quot; value=&quot;传智播客&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2）集合数据类型（List）的注入 12345678910public class UserDaoImpl implements UserDao &#123; private List&lt;String&gt; strList; public void setStrList(List&lt;String&gt; strList) &#123; this.strList = strList; &#125; public void save() &#123; System.out.println(strList); System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 123456789&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;strList&quot;&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 3）集合数据类型 List User&gt;）的注入 12345678910public class UserDaoImpl implements UserDao &#123; private List&lt;User&gt; userList; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125; public void save() &#123; System.out.println(userList); System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 123456789101112&lt;bean id=&quot;u1&quot; class=&quot;com.itheima.domain.User&quot;/&gt;&lt;bean id=&quot;u2&quot; class=&quot;com.itheima.domain.User&quot;/&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;userList&quot;&gt; &lt;list&gt; &lt;bean class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean class=&quot;com.itheima.domain.User&quot;/&gt; &lt;ref bean=&quot;u1&quot;/&gt; &lt;ref bean=&quot;u2&quot;/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 4）集合数据类型（Map&lt;String,User&gt;）的注入 12345678910public class UserDaoImpl implements UserDao &#123; private Map&lt;String,User&gt; userMap; public void setUserMap(Map&lt;String, User&gt; userMap) &#123; this.userMap = userMap; &#125; public void save() &#123; System.out.println(userMap); System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 12345678910&lt;bean id=&quot;u1&quot; class=&quot;com.itheima.domain.User&quot;/&gt;&lt;bean id=&quot;u2&quot; class=&quot;com.itheima.domain.User&quot;/&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;userMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;user1&quot; value-ref=&quot;u1&quot;/&gt; &lt;entry key=&quot;user2&quot; value-ref=&quot;u2&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 5）集合数据类型（Properties）的注入 12345678910public class UserDaoImpl implements UserDao &#123; private Properties properties; public void setProperties(Properties properties) &#123; this.properties = properties; &#125; public void save() &#123; System.out.println(properties); System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 123456789&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;p1&quot;&gt;aaa&lt;/prop&gt; &lt;prop key=&quot;p2&quot;&gt;bbb&lt;/prop&gt; &lt;prop key=&quot;p3&quot;&gt;ccc&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 3.9引入其他配置文件（分模块开发）实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载&lt;import resource=&quot;applicationContext-xxx.xml&quot;/&gt; 4. Spring相关API4.1 ApplicationContext的继承体系applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象 4.2 ApplicationContext的实现类1）ClassPathXmlApplicationContext它是从类的根路径下加载配置文件推荐使用这种 2）FileSystemXmlApplicationContext它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 3）AnnotationConfigApplicationContext当使用注解配置容器对象时，需要使用此类来创建spring 容器。它用来读取注解。 4.3 getBean()方法使用123456789public Object getBean(String name) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBean(name);&#125; public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException&#123; assertBeanFactoryActive(); return getBeanFactory().getBean(requiredType);&#125; 其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错。 123ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);UserService userService1 = (UserService) applicationContext.getBean(&quot;userService&quot;);UserService userService2 = applicationContext.getBean(UserService.class); 4.4 知识要点1234Spring的重点APIApplicationContext app = newClasspathXmlApplicationContext(&quot;xml文件&quot;)app.getBean(&quot;id&quot;)app.getBean(Class)","categories":[],"tags":[{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-07-26T13:22:00.116Z","updated":"2021-07-26T13:22:00.116Z","comments":true,"path":"2021/07/26/hello-world/","link":"","permalink":"http://example.com/2021/07/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"黑马程序员","slug":"黑马程序员","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"黑马程序员 springboot","slug":"黑马程序员-springboot","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot/"},{"name":"黑马程序员 SSM","slug":"黑马程序员-SSM","permalink":"http://example.com/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/"}]}