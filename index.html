<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>地主家的蜜罐</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="地主家的蜜罐">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="地主家的蜜罐">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="豫ICP备20021885号-1">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="地主家的蜜罐" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">地主家的蜜罐</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-黑马程序员/docker/docker入门" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/15/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/docker/docker%E5%85%A5%E9%97%A8/" class="article-date">
  <time class="dt-published" datetime="2021-08-15T08:34:35.000Z" itemprop="datePublished">2021-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/15/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/docker/docker%E5%85%A5%E9%97%A8/">docker入门</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="初识-Docker"><a href="#初识-Docker" class="headerlink" title="初识 Docker"></a>初识 Docker</h3><h4 id="docker-概念"><a href="#docker-概念" class="headerlink" title="docker 概念"></a>docker 概念</h4><p>我们写的代码会接触到好几个环境：开发环境、测试环境以及生产环境：(软件跨环境迁移的问题)</p>
<ul>
<li>Docker 是一个开源的应用容器引擎</li>
<li>诞生于 2013 年初，基于 Go 语言实现， dotCloud 公司出品（后改名为 Docker Inc）</li>
<li>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux 机器上。</li>
<li>容器是完全使用沙箱机制，相互隔离</li>
<li>容器性能开销极低。</li>
<li>Docker 从 17.03 版本之后分为 CE Community Edition: 社区版） 和 EE Enterprise Edition: 企业版）</li>
</ul>
<h4 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h4><p>Docker可以运行在 MAC 、 Windows 、 CentOS 、 UBUNTU 等操作系统上，本课程基于 CentOS 7 安装<br>Docker 。官网： <a target="_blank" rel="noopener" href="https://www.docker.com/">https://www.docker.com</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、yum 包更新到最新</span> </span><br><span class="line">yum update</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</span> </span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、 设置yum源</span></span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、 安装docker，出现输入的界面都按 y</span> </span><br><span class="line">yum install -y docker-ce</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、 查看docker版本，验证是否验证成功</span></span><br><span class="line">docker -v</span><br></pre></td></tr></table></figure>

<h4 id="docker-架构"><a href="#docker-架构" class="headerlink" title="docker 架构"></a>docker 架构</h4><ul>
<li>镜像（ Image Docker）镜像（ Image ），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li>容器（ Container ）：镜像 （Image ）和容器 （Container ）的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li>仓库（ Repository ）：仓库可看成一个代码控制中心用来保存镜像。</li>
</ul>
<p><img src="/2021/08/15/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/docker/docker%E5%85%A5%E9%97%A8/image-20210812162734535.png" alt="image-20210812162734535"></p>
<p><strong>配置Docker 镜像加速器</strong></p>
<p>默认情况下，将来从docker hub <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a> com/）上下载docker 镜像，太慢。一般都会配置镜像加速器：</p>
<ul>
<li>USTC ：中科大镜像加速器 <a target="_blank" rel="noopener" href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></li>
<li>阿里云(每个用户有各自的)</li>
<li>网易云</li>
<li>腾讯云</li>
</ul>
<h3 id="Docker-命令"><a href="#Docker-命令" class="headerlink" title="Docker 命令"></a>Docker 命令</h3><h4 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h4><ul>
<li><p>启动 docker 服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li>
<li><p>停止 docker 服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure></li>
<li><p>重启 docker 服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></li>
<li><p>查看 docker 服务状态</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure></li>
<li><p>开机启动 docker 服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h4><ul>
<li><p>查看镜像: 查看本地所有的镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker images -q # 查看所用镜像的 id</span><br></pre></td></tr></table></figure></li>
<li><p>搜索镜像: 从网络中查找需要的镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure></li>
<li><p>拉取镜像: 从 Docker 仓库下载镜像到本地，镜像名称格式为 名称 版本号，如果版本号不指定则是最新的版本。如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名称 # 默认版本</span><br><span class="line">docker pull redis:5.0 # 下载5.0版本的redis</span><br></pre></td></tr></table></figure></li>
<li><p>删除镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像id # 删除指定本地镜像</span><br><span class="line">docker rmi 镜像名称:版本 #删除指定的本地镜像</span><br><span class="line">docker rmi `docker images -q` # 删除所有本地镜像</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h4><ul>
<li><p>查看容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps #查看正在运行的容器</span><br><span class="line">docker ps -a # 查看所有容器</span><br></pre></td></tr></table></figure></li>
<li><p>创建并启动容器进入容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run 参数</span><br><span class="line">docker run -it --name=c1 centos:7 /bin/bash # 等号也可以换成空格 最后是进入容器的初始化指令</span><br><span class="line">docker run -id --name=c2 centos:7 </span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明：<ul>
<li>i ：保持容器运行。通常与 t 同时使用。加入 it 这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。</li>
<li>t ：为容器重新分配一个伪输入终端，通常与 i 同时使用。</li>
<li>d ：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用 docker exec 进入容器。退出后，容器不会关闭。</li>
<li>it 创建的容器一般称为交互式容器， id 创建的容器一般称为守护式容器</li>
<li>name ：为创建的容器命名。</li>
</ul>
</li>
</ul>
</li>
<li><p>进入容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec 参数 # 退出容器，容器不会关闭</span><br><span class="line">docker exec -it c2 /bin/bash # 进入c2容器</span><br><span class="line">exit # 退出容器</span><br></pre></td></tr></table></figure></li>
<li><p>停止容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名称</span><br></pre></td></tr></table></figure></li>
<li><p>启动容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名称</span><br></pre></td></tr></table></figure></li>
<li><p>删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名称</span><br><span class="line">docker rm `docker ps -aq` # 删除所有容器</span><br></pre></td></tr></table></figure></li>
<li><p>查看容器信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器名称</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Docker-容器数据卷"><a href="#Docker-容器数据卷" class="headerlink" title="Docker 容器数据卷"></a>Docker 容器数据卷</h3><h4 id="数据卷概念及作用"><a href="#数据卷概念及作用" class="headerlink" title="数据卷概念及作用"></a>数据卷概念及作用</h4><p>思考：</p>
<ul>
<li>Docker 容器删除后，在容器中产生的数据还在吗？</li>
<li>Docker 容器和外部机器可以直接交换文件吗？</li>
<li>容器之间想要进行数据交互？</li>
</ul>
<p><strong>数据卷</strong></p>
<ul>
<li>数据卷是宿主机中的一个目录或文件</li>
<li>当容器目录和数据卷目录绑定后，对方的修改会立即同步</li>
<li>一个数据卷可以被多个容器同时挂载</li>
<li>一个容器也可以被挂载多个数据卷</li>
</ul>
<p><strong>数据卷作用</strong></p>
<ul>
<li>容器数据持久化</li>
<li>外部机器和容器间接通信</li>
<li>容器之间数据交换</li>
</ul>
<p><img src="/2021/08/15/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/docker/docker%E5%85%A5%E9%97%A8/image-20210812164525560.png" alt="image-20210812164525560"></p>
<h4 id="配置数据卷"><a href="#配置数据卷" class="headerlink" title="配置数据卷"></a>配置数据卷</h4><ul>
<li><p>创建启动容器时，使用 v 参数 设置数据卷</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run ... -v 宿主机目录(文件):容器内目录(文件) ...</span><br><span class="line">docker run -it --name=c1 -v /root/data:/root/data_container centos:7 /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 多个-v参数挂载多个目录</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意事项：</p>
<ul>
<li>目录必须是绝对路径</li>
<li>如果目录不存在，会自动创建</li>
<li>可以挂载多个数据卷</li>
</ul>
</li>
</ul>
<p><strong>数据卷容器</strong></p>
<p>多容器进行数据交换</p>
<ol>
<li><p>多个容器挂载同一个数据卷</p>
</li>
<li><p>数据卷容器</p>
</li>
</ol>
<p><img src="/2021/08/15/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/docker/docker%E5%85%A5%E9%97%A8/image-20210812164943252.png" alt="image-20210812164943252"></p>
<h4 id="配置数据卷容器"><a href="#配置数据卷容器" class="headerlink" title="配置数据卷容器"></a>配置数据卷容器</h4><ol>
<li><p>创建启动 c3 数据卷容器，使用 v 参数 设置数据卷</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=c3 -v /volume centos:7 /bin/bash # 左边的目录如果省略会自动分配</span><br></pre></td></tr></table></figure></li>
<li><p>创建启动 c1 c2 容器，使用 volumes from 参数 设置数据卷</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=c1 --volumes-from c3 centos:7 /bin/bash</span><br><span class="line">docker run -it --name=c2 --volumes-from c3 centos:7 /bin/bash</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Docker-应用部署"><a href="#Docker-应用部署" class="headerlink" title="Docker 应用部署"></a>Docker 应用部署</h3><h4 id="MySQL-部署"><a href="#MySQL-部署" class="headerlink" title="MySQL 部署"></a>MySQL 部署</h4><p><strong>案例：需求</strong></p>
<p>在Docker 容器中部署 MySQL ，并通过外部 mysql 客户端操作 MySQL Server</p>
<p><strong>案例：实现步骤</strong></p>
<p>①搜索 mysql 镜像</p>
<p>②拉取 mysql 镜像</p>
<p>③创建容器</p>
<p>④操作容器中的 mysql</p>
<ul>
<li>容器内的网络服务和外部机器不能直接通信</li>
<li>外部机器和宿主机可以直接通信</li>
<li>宿主机和容器可以直接通信</li>
<li>当容器中的网络服务需要被外部机器访问时，可以将容器中提供服务的端口映射到宿主机的端口上。外部机器访问宿主机的该端口，从而间接访问容器的服务。</li>
<li>这种操作称为： 端口映射</li>
</ul>
<p><img src="/2021/08/15/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/docker/docker%E5%85%A5%E9%97%A8/image-20210812181909451.png" alt="image-20210812181909451"></p>
<ol>
<li>搜索mysql镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拉取mysql镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.6</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建容器，设置端口映射、目录映射</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在/root目录下创建mysql目录用于存储mysql数据信息</span></span><br><span class="line">mkdir ~/mysql</span><br><span class="line">cd ~/mysql</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">-p 3307:3306 \	#一般容器和宿主机都是3306 相同</span><br><span class="line">--name=c_mysql \</span><br><span class="line">-v $PWD/conf:/etc/mysql/conf.d \</span><br><span class="line">-v $PWD/logs:/logs \</span><br><span class="line">-v $PWD/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">mysql:5.6</span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明：<ul>
<li><strong>-p 3307:3306</strong>：将容器的 3306 端口映射到宿主机的 3307 端口。</li>
<li><strong>-v $PWD/conf:/etc/mysql/conf.d</strong>：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。配置目录</li>
<li><strong>-v $PWD/logs:/logs</strong>：将主机当前目录下的 logs 目录挂载到容器的 /logs。日志目录</li>
<li><strong>-v $PWD/data:/var/lib/mysql</strong> ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。数据目录</li>
<li><strong>-e MYSQL_ROOT_PASSWORD=123456：</strong>初始化 root 用户的密码。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>进入容器，操作mysql</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec –it c_mysql /bin/bash</span><br><span class="line">mysql -uroot -p123456	# 登录mysql</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用外部机器连接容器中的mysql</li>
</ol>
<p><img src="file://F:\BaiduNetdiskDownload%E8%B5%84%E6%96%99\imgs\1573636765632.png?lastModify=1628911819" alt="1573636765632"></p>
<h4 id="Tomcat-部署"><a href="#Tomcat-部署" class="headerlink" title="Tomcat 部署"></a>Tomcat 部署</h4><p><strong>案例：需求</strong></p>
<p>在Docker 容器中部署 Tomcat ，并通过外部机器访问 Tomcat 部署的项目。</p>
<p><strong>案例：实现步骤</strong></p>
<p>①搜索 tomcat 镜像</p>
<p>②拉取 tomcat 镜像</p>
<p>③创建容器</p>
<p>④部署项目</p>
<p>⑤测试访问</p>
<ol>
<li>搜索tomcat镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search tomcat</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拉取tomcat镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建容器，设置端口映射、目录映射</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在/root目录下创建tomcat目录用于存储tomcat数据信息</span></span><br><span class="line">mkdir ~/tomcat</span><br><span class="line">cd ~/tomcat</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name=c_tomcat \</span><br><span class="line">-p 8080:8080 \</span><br><span class="line">-v $PWD:/usr/local/tomcat/webapps \</span><br><span class="line">tomcat </span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明：<ul>
<li><p><strong>-p 8080:8080：</strong>将容器的8080端口映射到主机的8080端口</p>
<p><strong>-v $PWD:/usr/local/tomcat/webapps：</strong>将主机中当前目录挂载到容器的webapps</p>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li>使用外部机器访问tomcat</li>
</ol>
<p><img src="file://F:\BaiduNetdiskDownload%E8%B5%84%E6%96%99\imgs\1573649804623.png?lastModify=1628911923" alt="1573649804623"></p>
<h4 id="Nginx-部署"><a href="#Nginx-部署" class="headerlink" title="Nginx 部署"></a>Nginx 部署</h4><p><strong>案例：需求</strong></p>
<p>在Docker 容器中部署 Nginx ，并通过外部机器访问 Nginx 。</p>
<p><strong>案例：实现步骤</strong></p>
<p>①搜索 Nginx 镜像</p>
<p>②拉取 Nginx 镜像</p>
<p>③创建容器</p>
<p>④测试访问</p>
<ol>
<li>搜索nginx镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search nginx</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拉取nginx镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建容器，设置端口映射、目录映射</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在/root目录下创建nginx目录用于存储nginx数据信息</span></span><br><span class="line">mkdir ~/nginx</span><br><span class="line">cd ~/nginx</span><br><span class="line">mkdir conf</span><br><span class="line">cd conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容 官方提供的</span></span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name=c_nginx \</span><br><span class="line">-p 80:80 \</span><br><span class="line">-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \	# 该文件要提前准备好</span><br><span class="line">-v $PWD/logs:/var/log/nginx \</span><br><span class="line">-v $PWD/html:/usr/share/nginx/html \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明：<ul>
<li><strong>-p 80:80</strong>：将容器的 80端口映射到宿主机的 80 端口。</li>
<li><strong>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf</strong>：将主机当前目录下的 /conf/nginx.conf 挂载到容器的 :/etc/nginx/nginx.conf。配置目录</li>
<li><strong>-v $PWD/logs:/var/log/nginx</strong>：将主机当前目录下的 logs 目录挂载到容器的/var/log/nginx。日志目录</li>
</ul>
</li>
</ul>
<ol start="4">
<li>使用外部机器访问nginx</li>
</ol>
<p><img src="/2021/08/15/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/docker/docker%E5%85%A5%E9%97%A8/image-20210814134705269.png" alt="image-20210814134705269"></p>
<h4 id="Redis-部署"><a href="#Redis-部署" class="headerlink" title="Redis 部署"></a>Redis 部署</h4><p><strong>案例：需求</strong></p>
<p>在Docker 容器中部署 Redis ，并通过外部机器访问 Redis 。</p>
<p><strong>案例：实现步骤</strong></p>
<p>①搜索 Redis 镜像</p>
<p>②拉取 Redis 镜像</p>
<p>③创建容器</p>
<p>④测试访问</p>
<ol>
<li>搜索redis镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拉取redis镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:5.0</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建容器，设置端口映射</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name=c_redis -p 6379:6379 redis:5.0</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用外部机器连接redis</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli.exe -h 192.168.149.135 -p 6379</span><br></pre></td></tr></table></figure>


<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><h4 id="Docker-镜像原理"><a href="#Docker-镜像原理" class="headerlink" title="Docker 镜像原理"></a>Docker 镜像原理</h4><p>思考：</p>
<ul>
<li>Docker 镜像本质是什么？</li>
<li>Docker 中一个 centos 镜像为什么只有 200MB ，而一个centos 操作系统的 iso 文件要几个个 G</li>
<li>Docker 中一个 tomcat 镜像为什么有 500MB ，而一个tomcat 安装包只有 70 多 MB</li>
</ul>
<p>操作系统组成部分：</p>
<ul>
<li>进程调度子系统</li>
<li>进程通信子系统</li>
<li>内存管理子系统</li>
<li>设备管理子系统</li>
<li>文件管理子系统</li>
<li>网络通信子系统</li>
<li>作业控制子系统</li>
</ul>
<p>Linux文件系统由 bootfs 和 rootfs 两部分组成</p>
<ul>
<li>bootfs ：包含 bootloader （引导加载程序）和 kernel （内核）</li>
<li>rootfs：root 文件系统， 包含的就是典型 Linux 系统中的 /dev，/proc ，/bin ，/etc 等标准目录和文件</li>
<li>不同的 linux 发行版， bootfs 基本一样，而 rootfs 不同，如 ubuntu，centos 等</li>
</ul>
<p><img src="/2021/08/15/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/docker/docker%E5%85%A5%E9%97%A8/image-20210812182545903.png" alt="image-20210812182545903"></p>
<ul>
<li>Docker 镜像是由特殊的文件系统叠加而成</li>
<li>最底端是 bootfs ，并使用宿主机的 bootfs</li>
<li>第二层是 root 文件系统 rootfs, 称为 base image</li>
<li>然后再往上可以叠加其他的镜像文件</li>
<li>统一文件系统（ Union File System ）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。</li>
<li>一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像成为基础镜像。</li>
<li>当从一个镜像启动容器时， Docker 会在最顶层加载一个读写文件系统作为容器</li>
</ul>
<img src="/2021/08/15/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/docker/docker%E5%85%A5%E9%97%A8/image-20210814142719437.png" alt="image-20210814142719437" style="zoom:50%;">

<p>思考：</p>
<ol>
<li><p>Docker 镜像本质是什么？</p>
<ol>
<li>是一个分层文件系统</li>
</ol>
</li>
<li><p>Docker 中一个 centos 镜像为什么只有 200MB ，而一个 centos 操作系统的 iso 文件要几个个 G</p>
<ol>
<li>Centos 的 iso 镜像文件包含 bootfs 和 rootfs ，而 docker 的 centos 镜像复用操作系统的 bootfs ，只有 rootfs 和其他镜像层</li>
</ol>
</li>
<li><p>Docker 中一个 tomcat 镜像为什么有 500MB ，而一个 tomcat 安装包只有 70 多 MB</p>
<ol>
<li>由于 docker 中镜像是分层的， tomcat 虽然只有 70 多 MB ，但他需要依赖于父镜像和基础镜像，所有整个对外暴露的tomcat 镜像大小 500 多 MB</li>
</ol>
</li>
</ol>
<p><strong>镜像制作</strong></p>
<p>Docker镜像如何制作？</p>
<ol>
<li><p>容器转为镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker commit 容器id 镜像名称:版本号	# id可以只输入部分，只要能识别即可 </span><br><span class="line"><span class="meta">#</span><span class="bash">目录挂载内容不会被写入镜像</span></span><br><span class="line">docker save o 压缩文件名称 镜像名称:版本号</span><br><span class="line">docker load i 压缩文件名称</span><br></pre></td></tr></table></figure></li>
<li><p>dockerfile</p>
</li>
</ol>
<p><img src="/2021/08/15/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/docker/docker%E5%85%A5%E9%97%A8/image-20210812183038233.png" alt="image-20210812183038233"></p>
<h4 id="Dockerfile-概念及作用"><a href="#Dockerfile-概念及作用" class="headerlink" title="Dockerfile 概念及作用"></a>Dockerfile 概念及作用</h4><p>Dockerfile概念</p>
<ul>
<li>Dockerfile 是一个文本文件</li>
<li>包含了一条条的指令</li>
<li>每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像</li>
<li>对于开发人员：可以为开发团队提供一个完全一致的开发环境</li>
<li>对于测试人员：可以直接拿开发时所构建的镜像或者通过 Dockerfile 文件构建一个新的镜像开始工作了</li>
<li>对于运维人员：在部署时，可以实现应用的无缝移植</li>
</ul>
<p><img src="/2021/08/15/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/docker/docker%E5%85%A5%E9%97%A8/image-20210812183137798.png" alt="image-20210812183137798"></p>
<p>Dochub网址： <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a></p>
<h4 id="Dockerfile-关键字"><a href="#Dockerfile-关键字" class="headerlink" title="Dockerfile 关键字"></a>Dockerfile 关键字</h4><table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>指定父镜像</td>
<td>指定dockerfile基于那个image构建</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>作者信息</td>
<td>用来标明这个dockerfile谁写的</td>
</tr>
<tr>
<td>LABEL</td>
<td>标签</td>
<td>用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看</td>
</tr>
<tr>
<td>RUN</td>
<td>执行命令</td>
<td>执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”]</td>
</tr>
<tr>
<td>CMD</td>
<td>容器启动命令</td>
<td>提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”]</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>入口</td>
<td>一般在制作一些执行就关闭的容器中会使用</td>
</tr>
<tr>
<td>COPY</td>
<td>复制文件</td>
<td>build的时候复制文件到image中</td>
</tr>
<tr>
<td>ADD</td>
<td>添加文件</td>
<td>build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务</td>
</tr>
<tr>
<td>ENV</td>
<td>环境变量</td>
<td>指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value</td>
</tr>
<tr>
<td>ARG</td>
<td>构建参数</td>
<td>构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数</td>
</tr>
<tr>
<td>VOLUME</td>
<td>定义外部可以挂载的数据卷</td>
<td>指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”]</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>暴露端口</td>
<td>定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>工作目录</td>
<td>指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径</td>
</tr>
<tr>
<td>USER</td>
<td>指定执行用户</td>
<td>指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户</td>
</tr>
<tr>
<td>HEALTHCHECK</td>
<td>健康检查</td>
<td>指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>触发器</td>
<td>当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大</td>
</tr>
<tr>
<td>STOPSIGNAL</td>
<td>发送信号量到宿主机</td>
<td>该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。</td>
</tr>
<tr>
<td>SHELL</td>
<td>指定执行脚本的shell</td>
<td>指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell</td>
</tr>
</tbody></table>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p><strong>案例：需求</strong></p>
<p>自定义centos7 镜像。要求：</p>
<ol>
<li><p>默认登录路径为 /usr</p>
</li>
<li><p>可以使用 vim</p>
</li>
</ol>
<p><strong>案例：实现步骤</strong></p>
<p>①定义父镜像：<code>FROM centos:7</code></p>
<p>②定义作者信息： <code>MAINTAINER itheima &lt;itheima@126.com&gt;</code></p>
<p>③执行安装 vim 命令： <code>RUN yum install -y vim</code></p>
<p>④定义默认的工作目录：<code> WORKDIR /usr</code></p>
<p>⑤定义容器启动执行的命令： <code>CMD /bin/bash</code></p>
<p>⑥通过 dockerfile 构建镜像： <code>docker bulid -f dockerfile文件路径 -t 镜像名称:版本 .</code>(版本省略则是latest)</p>
<p><strong>案例：需求</strong></p>
<p>定义dockerfile ，发布 springboot 项目</p>
<p><strong>案例：实现步骤</strong></p>
<p>①定义父镜像： <code>FROM java:8</code></p>
<p>②定义作者信息： <code>MAINTAINER itheima &lt;itheima@126.com&gt;</code></p>
<p>③将 jar 包添加到容器： <code>ADD springboot.jar app.jar</code></p>
<p>④定义容器启动执行的命令： <code>CMD java -jar app.jar</code></p>
<p>⑤通过 dockerfile 构建镜像： <code>docker bulid -f dockerfile文件路径 -t 镜像名称:版本 .</code> (1-4为dockerfile内容)</p>
<h3 id="Docker-服务编排"><a href="#Docker-服务编排" class="headerlink" title="Docker 服务编排"></a>Docker 服务编排</h3><h4 id="服务编排概念"><a href="#服务编排概念" class="headerlink" title="服务编排概念"></a>服务编排概念</h4><p>微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，维护的工作量会很大。</p>
<ul>
<li>要从 <code>Dockerfile build image</code> 或者去 dockerhub 拉取 image</li>
<li>要创建多个 container</li>
<li>要管理这些 container （启动停止删除）</li>
</ul>
<p>服务编排：按照一定的业务规则批量管理容器</p>
<h4 id="Docker-Compose-概述"><a href="#Docker-Compose-概述" class="headerlink" title="Docker Compose 概述"></a>Docker Compose 概述</h4><p>Docker Compose是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建，启动和停止。使用步骤：</p>
<ol>
<li><p>利用 Dockerfile 定义运行环境镜像</p>
</li>
<li><p>使用 docker-compose.yml 定义组成应用的各服务</p>
</li>
<li><p>运行 docker-compose up 启动应用</p>
</li>
</ol>
<p><img src="/2021/08/15/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/docker/docker%E5%85%A5%E9%97%A8/image-20210812183752387.png" alt="image-20210812183752387"></p>
<p><strong>Docker Compose安装使用</strong></p>
<p>一、安装Docker Compose</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我 们以编译好的二进制包方式安装在Linux系统中。</span> </span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置文件可执行权限</span> </span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本信息</span> </span><br><span class="line">docker-compose -version</span><br></pre></td></tr></table></figure>

<p><strong>二、卸载Docker Compose</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 二进制包方式安装的，删除二进制文件即可</span></span><br><span class="line">rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p><strong>三、 使用docker compose编nginx+springboot项目</strong></p>
<ol>
<li>创建docker-compose目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/docker-compose</span><br><span class="line">cd ~/docker-compose</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写 docker-compose.yml 文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">   image: nginx</span><br><span class="line">   ports:</span><br><span class="line">    - 80:80</span><br><span class="line">   links:</span><br><span class="line">    - app</span><br><span class="line">   volumes:</span><br><span class="line">    - ./nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">  app:</span><br><span class="line">    image: app</span><br><span class="line">    expose:</span><br><span class="line">      - &quot;8080&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建./nginx/conf.d目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ./nginx/conf.d</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在./nginx/conf.d目录下 编写itheima.conf文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    access_log off;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://app:8080;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在~/docker-compose 目录下 使用docker-compose 启动容器</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>测试访问</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.149.135/hello</span><br></pre></td></tr></table></figure>

<h3 id="Docker-私有仓库"><a href="#Docker-私有仓库" class="headerlink" title="Docker 私有仓库"></a>Docker 私有仓库</h3><h4 id="搭建私有仓库"><a href="#搭建私有仓库" class="headerlink" title="搭建私有仓库"></a>搭建私有仓库</h4><p>Docker官方的 Docker hub <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> ）是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像到本地，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法访问互联网，或者你不希望将自己的镜像放到公网当中，那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、拉取私有仓库镜像</span> </span><br><span class="line">docker pull registry</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、启动私有仓库容器</span> </span><br><span class="line">docker run -id --name=registry -p 5000:5000 registry</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到&#123;<span class="string">&quot;repositories&quot;</span>:[]&#125; 表示私有仓库 搭建成功</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、修改daemon.json</span>   </span><br><span class="line">vim /etc/docker/daemon.json    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 在上述文件中添加一个key，用逗号分割，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自己私有仓库服务器真实ip</span> </span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;私有仓库服务器ip:5000&quot;]&#125; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、重启docker 服务</span> </span><br><span class="line">systemctl restart docker</span><br><span class="line">docker start registry</span><br></pre></td></tr></table></figure>

<h4 id="上传镜像到私有仓库"><a href="#上传镜像到私有仓库" class="headerlink" title="上传镜像到私有仓库"></a>上传镜像到私有仓库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、标记镜像为私有仓库的镜像</span>     </span><br><span class="line">docker tag centos:7 私有仓库服务器IP:5000/centos:7</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、上传标记的镜像</span>     </span><br><span class="line">docker push 私有仓库服务器IP:5000/centos:7</span><br></pre></td></tr></table></figure>

<h4 id="从私有仓库拉取镜像"><a href="#从私有仓库拉取镜像" class="headerlink" title="从私有仓库拉取镜像"></a>从私有仓库拉取镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">拉取镜像</span> </span><br><span class="line">docker pull 私有仓库服务器ip:5000/centos:7</span><br></pre></td></tr></table></figure>

<h3 id="Docker-相关概念"><a href="#Docker-相关概念" class="headerlink" title="Docker 相关概念"></a>Docker 相关概念</h3><h4 id="docker-容器虚拟化-与-传统虚拟机比较"><a href="#docker-容器虚拟化-与-传统虚拟机比较" class="headerlink" title="docker 容器虚拟化 与 传统虚拟机比较"></a>docker 容器虚拟化 与 传统虚拟机比较</h4><p>容器就是将软件打包成标准化单元，以用于开发、交付和部署。</p>
<ul>
<li>容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li>
<li>容器化软件在任何环境中都能够始终如一地运行。</li>
<li>容器赋予了软件独立性，使其免受外在环境差异的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li>
</ul>
<p><img src="/2021/08/15/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/docker/docker%E5%85%A5%E9%97%A8/image-20210812183956126.png" alt="image-20210812183956126"></p>
<p>相同：</p>
<ul>
<li>容器和虚拟机具有相似的资源隔离和分配优势</li>
</ul>
<p>不同：</p>
<ul>
<li>容器虚拟化的是操作系统，虚拟机虚拟化的是硬件。</li>
<li>传统虚拟机可以运行不同的操作系统，容器只能运行同一类型操作系统</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>一般为MB</td>
<td>一般为GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody></table>
<p><img src="/2021/08/15/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/docker/docker%E5%85%A5%E9%97%A8/image-20210812184203343.png" alt="image-20210812184203343"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/15/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/docker/docker%E5%85%A5%E9%97%A8/" data-id="ckvndazyd0011qsuy899h6pfy" data-title="docker入门" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/14_企业级解决方案" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/14_%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="article-date">
  <time class="dt-published" datetime="2021-08-14T07:56:53.000Z" itemprop="datePublished">2021-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/14_%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">14_企业级解决方案</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><h4 id="“宕机”"><a href="#“宕机”" class="headerlink" title="“宕机”"></a>“宕机”</h4><p>服务器启动后迅速宕机</p>
<p>问题排查</p>
<ol>
<li><p>请求数量较高</p>
</li>
<li><p>主从之间数据吞吐量较大，数据同步操作频度较高</p>
</li>
</ol>
<p>解决方案</p>
<p>前置准备工作：</p>
<ol>
<li>日常例行统计数据访问记录，统计访问频度较高的热点数据</li>
<li>利用LRU数据删除策略，构建数据留存队列 （例如：storm与kafka配合 ）</li>
</ol>
<p>准备工作：</p>
<ol>
<li><p>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</p>
</li>
<li><p>利用分布式多服务器同时进行数据读取，提速数据加载过程</p>
</li>
<li><p>热点数据主从同时预热 </p>
</li>
</ol>
<p>实施：</p>
<ol>
<li><p>使用脚本程序固定触发数据预热过程</p>
</li>
<li><p>如果条件允许，使用了CDN（内容分发网络），效果会更好</p>
</li>
</ol>
<p>总结</p>
<p>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h4 id="数据库服务器崩溃（1）"><a href="#数据库服务器崩溃（1）" class="headerlink" title="数据库服务器崩溃（1）"></a>数据库服务器崩溃（1）</h4><ol>
<li><p>系统平稳运行过程中，忽然数据库连接量激增</p>
</li>
<li><p>应用服务器无法及时处理请求</p>
</li>
<li><p>大量408，500错误页面出现</p>
</li>
<li><p>客户反复刷新页面获取数据</p>
</li>
<li><p>数据库崩溃</p>
</li>
<li><p>应用服务器崩溃</p>
</li>
<li><p>重启应用服务器无效</p>
</li>
<li><p>Redis服务器崩溃</p>
</li>
<li><p>Redis集群崩溃</p>
</li>
<li><p>重启数据库后再次被瞬间流量放倒</p>
</li>
</ol>
<p>问题排查</p>
<ol>
<li>在一个较短的时间内，缓存中较多的key集中过期</li>
<li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</li>
<li>数据库同时接收到大量的请求无法及时处理</li>
<li>Redis大量请求被积压，开始出现超时现象</li>
<li>数据库流量激增，数据库崩溃</li>
<li>重启后仍然面对缓存中无数据可用</li>
<li>Redis服务器资源被严重占用，Redis服务器崩溃</li>
<li>Redis集群呈现崩塌，集群瓦解</li>
<li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li>
<li>应用服务器，redis，数据库全部重启，效果不理想</li>
</ol>
<p>问题分析</p>
<ul>
<li>短时间范围内</li>
<li>大量key集中过期</li>
</ul>
<p>解决方案（道）</p>
<ol>
<li>更多的页面静态化处理</li>
<li>构建多级缓存架构 <ol>
<li>Nginx缓存+redis缓存+ehcache缓存</li>
</ol>
</li>
<li>检测Mysql严重耗时业务进行优化 <ol>
<li>对数据库的瓶颈排查：例如超时查询、耗时较高事务等</li>
</ol>
</li>
<li>灾难预警机制 监控redis服务器性能指标<ol>
<li>CPU占用、CPU使用率</li>
<li>内存容量</li>
<li>查询平均响应时间</li>
<li>线程数</li>
</ol>
</li>
<li>限流、降级 <ol>
<li>短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li>
</ol>
</li>
</ol>
<p>解决方案（术）</p>
<ol>
<li><p>LRU与LFU切换</p>
</li>
<li><p>数据有效期策略调整</p>
<ol>
<li>根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟</li>
<li>过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量</li>
</ol>
</li>
<li><p>超热数据使用永久key</p>
</li>
<li><p>定期维护（自动+人工） </p>
<ol>
<li>对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</li>
</ol>
</li>
<li><p>加锁 </p>
<ol>
<li>慎用！</li>
</ol>
</li>
</ol>
<p>总结</p>
<p>缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现（约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p>
<p><img src="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/14_%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20210811230048399.png" alt="image-20210811230048399"></p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><h4 id="数据库服务器崩溃（2）"><a href="#数据库服务器崩溃（2）" class="headerlink" title="数据库服务器崩溃（2）"></a>数据库服务器崩溃（2）</h4><ol>
<li><p>系统平稳运行过程中</p>
</li>
<li><p>数据库连接量瞬间激增</p>
</li>
<li><p>Redis服务器无大量key过期</p>
</li>
<li><p>Redis内存平稳，无波动</p>
</li>
<li><p>Redis服务器CPU正常</p>
</li>
<li><p>数据库崩溃</p>
</li>
</ol>
<p>问题排查</p>
<ol>
<li><p>Redis中某个key过期，该key访问量巨大</p>
</li>
<li><p>多个数据请求从服务器直接压到Redis后，均未命中</p>
</li>
<li><p>Redis在短时间内发起了大量对数据库中同一数据的访问</p>
</li>
</ol>
<p>问题分析</p>
<ul>
<li>单个key高热数据</li>
<li>key过期</li>
</ul>
<p>解决方案（术）</p>
<ol>
<li><p>预先设定 以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长 注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p>
</li>
<li><p>现场调整 监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</p>
</li>
<li><p>后台刷新数据 启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</p>
</li>
<li><p>二级缓存 设置不同的失效时间，保障不会被同时淘汰就行</p>
</li>
<li><p>加锁 分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！</p>
</li>
</ol>
<p>总结</p>
<p>缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h4 id="数据库服务器崩溃（3）"><a href="#数据库服务器崩溃（3）" class="headerlink" title="数据库服务器崩溃（3）"></a>数据库服务器崩溃（3）</h4><ol>
<li><p>系统平稳运行过程中</p>
</li>
<li><p>应用服务器流量随时间增量较大</p>
</li>
<li><p>Redis服务器命中率随时间逐步降低</p>
</li>
<li><p>Redis内存平稳，内存无压力</p>
</li>
<li><p>Redis服务器CPU占用激增</p>
</li>
<li><p>数据库服务器压力激增</p>
</li>
<li><p>数据库崩溃</p>
</li>
</ol>
<p>问题排查</p>
<ol>
<li><p>Redis中大面积出现未命中</p>
</li>
<li><p>出现非正常URL访问</p>
</li>
</ol>
<p>问题分析</p>
<ul>
<li><p>获取的数据在数据库中也不存在，数据库查询未得到对应数据</p>
</li>
<li><p>Redis获取到null数据未进行持久化，直接返回</p>
</li>
<li><p>下次此类数据到达重复上述过程</p>
</li>
<li><p>出现黑客攻击服务器</p>
</li>
</ul>
<p>解决方案（术）</p>
<ol>
<li><p>缓存null 对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟</p>
</li>
<li><p>白名单策略</p>
<ol>
<li>提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放行，加载异常数据时直接拦截（效率偏低）</li>
<li>使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）</li>
</ol>
</li>
<li><p>实施监控 </p>
<ol>
<li>实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比<ol>
<li>非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象</li>
<li>活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象 </li>
</ol>
</li>
<li>根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</li>
</ol>
</li>
<li><p>key加密 问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验 例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</p>
</li>
</ol>
<p>总结</p>
<p>缓存击穿访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。<br>无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</p>
<h3 id="性能指标监控"><a href="#性能指标监控" class="headerlink" title="性能指标监控"></a>性能指标监控</h3><p>监控指标</p>
<ul>
<li>性能指标：Performance</li>
</ul>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>latency</td>
<td>Redis相应一个请求的时间</td>
</tr>
<tr>
<td>instantaneous_ops_per_sec</td>
<td>平均每秒处理请求总数</td>
</tr>
<tr>
<td>hit rate(calculated)</td>
<td>缓存命中率（计算出来的）</td>
</tr>
</tbody></table>
<ul>
<li>内存指标：Memory</li>
</ul>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>used_memory</td>
<td>已使用内存</td>
</tr>
<tr>
<td>mem_fragmentation_ratio</td>
<td>内存碎片率</td>
</tr>
<tr>
<td>evicted_keys</td>
<td>由于最大内存限制被移除的key的数量</td>
</tr>
<tr>
<td>blocked_clients</td>
<td>由于BLPOP, BRPOP, or BRPOPLPUSH而被阻塞的客户端</td>
</tr>
</tbody></table>
<ul>
<li>基本活动指标：Basic activity</li>
</ul>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>connected_clients</td>
<td>客户端连接数</td>
</tr>
<tr>
<td>connected_slaves</td>
<td>Slave数量</td>
</tr>
<tr>
<td>master_last_io_second_ago</td>
<td>最近一次主从交互之后的秒数</td>
</tr>
<tr>
<td>keyspace</td>
<td>数据库中的key值总数</td>
</tr>
</tbody></table>
<ul>
<li>持久性指标：Persistence</li>
</ul>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>rdb_last_save_time</td>
<td>最后一次持久化保存到磁盘的时间戳</td>
</tr>
<tr>
<td>rdb_changes_since_last_save</td>
<td>自最后一次持久化以来数据库的更改数</td>
</tr>
</tbody></table>
<ul>
<li>错误指标：Error</li>
</ul>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>rejected_connections</td>
<td>由于达到maxclient限制而被拒绝的连接数</td>
</tr>
<tr>
<td>keyspace_misses</td>
<td>Key值查找失败（没有命中）次数</td>
</tr>
<tr>
<td>master_link_down_since_seconds</td>
<td>主从断开的持续时间（以秒为单位）</td>
</tr>
</tbody></table>
<h4 id="监控方式"><a href="#监控方式" class="headerlink" title="监控方式"></a>监控方式</h4><ul>
<li>工具<ul>
<li>Cloud Insight Redis</li>
<li>Prometheus</li>
<li>Redis-stat</li>
<li>Redis-faina</li>
<li>RedisLive</li>
<li>zabbix</li>
</ul>
</li>
<li>命令<ul>
<li>benchmark</li>
<li>redis cli<ul>
<li>monitor</li>
<li>showlog</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h4><ul>
<li>命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark [-h ] [-p ] [-c ] [-n &lt;requests]&gt; [-k ]</span><br></pre></td></tr></table></figure>

<ul>
<li>范例1 说明：50个连接，10000次请求对应的性能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark</span><br></pre></td></tr></table></figure>

<ul>
<li>范例2 说明：100个连接，5000次请求对应的性能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -c 100 -n 5000</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/14_%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20210811232302733.png" alt="image-20210811232302733"></p>
<h4 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h4><ul>
<li>命令  打印服务器调试信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitor</span><br></pre></td></tr></table></figure>

<h4 id="showlong"><a href="#showlong" class="headerlink" title="showlong"></a>showlong</h4><ul>
<li><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showlong [operator]</span><br></pre></td></tr></table></figure>

<ul>
<li>get ：获取慢查询日志</li>
<li>len ：获取慢查询日志条目数</li>
<li>reset ：重置慢查询日志</li>
</ul>
</li>
<li><p>相关配置</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slowlog-log-slower-than 1000 #设置慢查询的时间下线，单位：微妙 </span><br><span class="line">slowlog-max-len 100 #设置慢查询命令对应的日志显示长度，单位：命令数</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/14_%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" data-id="ckvndazyu001vqsuy86z46vh2" data-title="14_企业级解决方案" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/13_cluster" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/13_cluster/" class="article-date">
  <time class="dt-published" datetime="2021-08-14T07:56:23.000Z" itemprop="datePublished">2021-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/13_cluster/">13_cluster</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="集群简介"><a href="#集群简介" class="headerlink" title="集群简介"></a>集群简介</h3><h4 id="现状问题"><a href="#现状问题" class="headerlink" title="现状问题"></a>现状问题</h4><p>业务发展过程中遇到的峰值瓶颈</p>
<ul>
<li>redis提供的服务OPS可以达到10万/秒，当前业务OPS已经达到10万/秒</li>
<li>内存单机容量达到256G，当前业务需求内存容量1T</li>
<li>使用集群的方式可以快速解决上述问题</li>
</ul>
<h4 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h4><ul>
<li>集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果</li>
</ul>
<p><img src="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/13_cluster/image-20210811194159866.png" alt="image-20210811194159866"></p>
<h4 id="集群作用"><a href="#集群作用" class="headerlink" title="集群作用"></a>集群作用</h4><ul>
<li>分散单台服务器的访问压力，实现负载均衡</li>
<li>分散单台服务器的存储压力，实现可扩展性</li>
<li>降低单台服务器宕机带来的业务灾难</li>
</ul>
<p><img src="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/13_cluster/image-20210811194230583.png" alt="image-20210811194230583"></p>
<h3 id="Redis集群结构设计"><a href="#Redis集群结构设计" class="headerlink" title="Redis集群结构设计"></a>Redis集群结构设计</h3><h4 id="数据存储设计"><a href="#数据存储设计" class="headerlink" title="数据存储设计"></a>数据存储设计</h4><ul>
<li>通过算法设计，计算出key应该保存的位置</li>
<li>将所有的存储空间计划切割成16384份，每台主机保存一部分 <ul>
<li>每份代表的是一个存储空间，不是一个key的保存空间</li>
</ul>
</li>
<li>将key按照计算出的结果放到对应的存储空间</li>
</ul>
<img src="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/13_cluster/image-20210811194452995.png" alt="image-20210811194452995" style="zoom:80%;">

<ul>
<li>增强可扩展性</li>
</ul>
<img src="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/13_cluster/image-20210812092258054.png" alt="image-20210812092258054" style="zoom:50%;">

<h4 id="集群内部通讯设计"><a href="#集群内部通讯设计" class="headerlink" title="集群内部通讯设计"></a>集群内部通讯设计</h4><ul>
<li>各个数据库相互通信，保存各个库中槽的编号数据</li>
<li>一次命中，直接返回</li>
<li>一次未命中，告知具体位置</li>
</ul>
<p><img src="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/13_cluster/image-20210811213351770.png" alt="image-20210811213351770"></p>
<h3 id="cluster集群结构搭建-没认真看"><a href="#cluster集群结构搭建-没认真看" class="headerlink" title="cluster集群结构搭建(没认真看)"></a>cluster集群结构搭建(没认真看)</h3><h4 id="搭建方式"><a href="#搭建方式" class="headerlink" title="搭建方式"></a>搭建方式</h4><ul>
<li>原生安装（单条命令）<ul>
<li>配置服务器（3主3从）</li>
<li>建立通信（Meet）</li>
<li>分槽（Slot）</li>
<li>搭建主从（master-slave）</li>
</ul>
</li>
<li>工具安装（批处理）</li>
</ul>
<h4 id="Cluster配置"><a href="#Cluster配置" class="headerlink" title="Cluster配置"></a>Cluster配置</h4><ul>
<li><p>添加节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-enabled yes|no</span><br></pre></td></tr></table></figure></li>
<li><p>cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster-config-file &lt;filename&gt;</span><br><span class="line">#cluster-config-file node-6379.conf</span><br></pre></td></tr></table></figure></li>
<li><p>节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-node-timeout &lt;milliseconds&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>master连接的slave最小数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-migration-barrier &lt;count&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Cluster节点操作命令"><a href="#Cluster节点操作命令" class="headerlink" title="Cluster节点操作命令"></a>Cluster节点操作命令</h4><ul>
<li><p>查看集群节点信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure></li>
<li><p>进入一个从节点 redis，切换其主节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster replicate &lt;master-id&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>发现一个新节点，新增主节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster meet ip:port</span><br></pre></td></tr></table></figure></li>
<li><p>忽略一个没有solt的节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster forget &lt;id&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>手动故障转移</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster failover</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="redis-trib命令"><a href="#redis-trib命令" class="headerlink" title="redis-trib命令"></a>redis-trib命令</h4><ul>
<li><p>添加节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb add-node</span><br></pre></td></tr></table></figure></li>
<li><p>删除节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb del-node  </span><br></pre></td></tr></table></figure></li>
<li><p>重新分片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb reshard</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/13_cluster/" data-id="ckvndazyt001sqsuy8bl4bsln" data-title="13_cluster" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/12_哨兵模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/12_%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2021-08-14T07:56:04.000Z" itemprop="datePublished">2021-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/12_%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/">12_哨兵模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="哨兵简介"><a href="#哨兵简介" class="headerlink" title="哨兵简介"></a>哨兵简介</h3><h4 id="主机“宕机”"><a href="#主机“宕机”" class="headerlink" title="主机“宕机”"></a>主机“宕机”</h4><p><img src="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/12_%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/image-20210810231753901.png" alt="image-20210810231753901"></p>
<ul>
<li>关闭master和所有slave</li>
<li>找一个slave作为master</li>
<li>修改其他slave的配置，连接新的主</li>
<li>启动新的master与slave</li>
<li>全量复制<em>N+部分复制</em>N</li>
<li>关闭期间的数据服务谁来承接？</li>
<li>找一个主？怎么找法？</li>
<li>修改配置后，原始的主恢复了怎么办？</li>
</ul>
<h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><p>哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有slave连接到新的master。</p>
<p><img src="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/12_%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/image-20210810231836936.png" alt="image-20210810231836936"></p>
<h4 id="哨兵的作用"><a href="#哨兵的作用" class="headerlink" title="哨兵的作用"></a>哨兵的作用</h4><ul>
<li>监控 <ul>
<li>不断的检查master和slave是否正常运行。 </li>
<li>master存活检测、master与slave运行情况检测</li>
</ul>
</li>
<li>通知（提醒） <ul>
<li>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。</li>
</ul>
</li>
<li>自动故障转移 <ul>
<li>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址 </li>
</ul>
</li>
</ul>
<blockquote>
<p>注意： 哨兵也是一台redis服务器，只是不提供数据服务 通常哨兵配置数量为单数</p>
</blockquote>
<h3 id="启用哨兵模式"><a href="#启用哨兵模式" class="headerlink" title="启用哨兵模式"></a>启用哨兵模式</h3><h4 id="配置哨兵"><a href="#配置哨兵" class="headerlink" title="配置哨兵"></a>配置哨兵</h4><ul>
<li><p>配置一拖二的主从结构</p>
</li>
<li><p>配置三个哨兵（配置相同，端口不同）</p>
<ul>
<li> 参看sentinel.conf</li>
</ul>
</li>
<li><p>启动哨兵</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel sentinel-端口号.conf</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>配置项</th>
<th>范例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sentinel auth-pass &lt;服务器名称&gt; <password></password></td>
<td>sentinel auth-pass mymaster itcast</td>
<td>连接服务器口令</td>
</tr>
<tr>
<td>sentinel down-after-milliseconds &lt;自定义服务名称&gt;&lt;主机地址&gt;&lt;端口&gt;&lt;主从服务器总量&gt;</td>
<td>sentinel monitor mymaster 192.168.194.131 6381 1</td>
<td>设置哨兵监听的主服务器信息，最后的参数决定了最终参与选举的服务器数量（-1）</td>
</tr>
<tr>
<td>sentinel down-after-milliseconds&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td>
<td>sentinel down-after-milliseconds mymaster 3000</td>
<td>指定哨兵在监控Redis服务时，判定服务器挂掉的时间周期，默认30秒（30000），也是主从切换的启动条件之一</td>
</tr>
<tr>
<td>sentinel parallel-syncs&lt;服务名称&gt;&lt;服务器数（整数）&gt;</td>
<td>sentinel parallel-syncs mymaster 1</td>
<td>指定同时进行主从的slave数量，数值越大，要求网络资源越高，要求约小，同步时间约长</td>
</tr>
<tr>
<td>sentinel failover-timeout&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td>
<td>sentinel failover-timeout mymaster 9000</td>
<td>指定出现故障后，故障切换的最大超时时间，超过该值，认定切换失败，默认3分钟</td>
</tr>
<tr>
<td>sentinel notification-script&lt;服务名称&gt;&lt;脚本路径&gt;</td>
<td></td>
<td>服务器无法正常联通时，设定的执行脚本，通常调试使用。</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="哨兵工作原理"><a href="#哨兵工作原理" class="headerlink" title="哨兵工作原理"></a>哨兵工作原理</h3><h4 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h4><ul>
<li>哨兵在进行主从切换过程中经历三个阶段<ul>
<li>监控</li>
<li>通知</li>
<li>故障转移</li>
</ul>
</li>
</ul>
<h4 id="阶段一：监控阶段"><a href="#阶段一：监控阶段" class="headerlink" title="阶段一：监控阶段"></a>阶段一：监控阶段</h4><ul>
<li>用于同步各个节点的状态信息<ul>
<li>获取各个sentinel的状态（是否在线）</li>
<li>获取master的状态<ul>
<li>master属性<ul>
<li>runid</li>
<li>role：master</li>
</ul>
</li>
<li>各个slave的详细信息</li>
</ul>
</li>
<li>获取所有slave的状态（根据master中的slave信息）<ul>
<li>slave属性<ul>
<li>runid</li>
<li>role：slave</li>
<li>master_host、master_port</li>
<li>offset</li>
<li>……</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/12_%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/image-20210810232400771.png" alt="image-20210810232400771"></p>
<p><img src="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/12_%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/image-20210810232533492.png" alt="image-20210810232533492"></p>
<h4 id="阶段二：通知阶段"><a href="#阶段二：通知阶段" class="headerlink" title="阶段二：通知阶段"></a>阶段二：通知阶段</h4><p><img src="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/12_%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/image-20210810232609739.png" alt="image-20210810232609739"></p>
<h4 id="阶段三：故障转移阶段"><a href="#阶段三：故障转移阶段" class="headerlink" title="阶段三：故障转移阶段"></a>阶段三：故障转移阶段</h4><p><img src="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/12_%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/image-20210810232629953.png" alt="image-20210810232629953"></p>
<p><img src="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/12_%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/image-20210810232649354.png" alt="image-20210810232649354"></p>
<ul>
<li>服务器列表中挑选备选master<ul>
<li>在线的</li>
<li>响应慢的（pass）</li>
<li>与原master断开时间久的（pass）</li>
<li>优先原则<ul>
<li>优先级</li>
<li>offset</li>
<li>runid</li>
</ul>
</li>
</ul>
</li>
<li>发送指令（ sentinel ）<ul>
<li>向新的master发送slaveof no one</li>
<li>向其他slave发送slaveof 新masterIP端口</li>
</ul>
</li>
</ul>
<h4 id="主从切换总结"><a href="#主从切换总结" class="headerlink" title="主从切换总结"></a>主从切换总结</h4><ul>
<li>服务器列表中挑选备选master</li>
<li>在线的</li>
<li>响应慢的</li>
<li>与原master断开时间久的</li>
<li>优先原则<ul>
<li>优先级</li>
<li>offset</li>
<li>runid</li>
</ul>
</li>
</ul>
<h4 id="阶段三：故障转移阶段-1"><a href="#阶段三：故障转移阶段-1" class="headerlink" title="阶段三：故障转移阶段"></a>阶段三：故障转移阶段</h4><ul>
<li>监控<ul>
<li>同步信息</li>
</ul>
</li>
<li>通知<ul>
<li>保持联通</li>
</ul>
</li>
<li>故障转移<ul>
<li>发现问题</li>
<li>竞选负责人</li>
<li>优选新master</li>
<li>新master上任，其他slave切换master，原master作为slave故障回复后连接</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/12_%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/" data-id="ckvndazys001qqsuybi3b25fb" data-title="12_哨兵模式" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/11_主从复制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T10:07:30.000Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">11_主从复制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="主从复制简介"><a href="#主从复制简介" class="headerlink" title="主从复制简介"></a>主从复制简介</h3><h4 id="互联网“三高”架构"><a href="#互联网“三高”架构" class="headerlink" title="互联网“三高”架构"></a>互联网“三高”架构</h4><ul>
<li>高并发</li>
<li>高性能</li>
<li>高可用</li>
</ul>
<h4 id="你的“Redis”是否高可用"><a href="#你的“Redis”是否高可用" class="headerlink" title="你的“Redis”是否高可用"></a>你的“Redis”是否高可用</h4><p>单机redis的风险与问题</p>
<ul>
<li>问题1.机器故障<ul>
<li>现象：硬盘故障、系统崩溃</li>
<li>本质：数据丢失，很可能对业务造成灾难性打击</li>
<li>结论：基本上会放弃使用redis.</li>
</ul>
</li>
<li>问题2.容量瓶颈<ul>
<li>现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存</li>
<li>本质：穷，硬件条件跟不上</li>
<li>结论：放弃使用redis</li>
</ul>
</li>
<li>结论： <ul>
<li>为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据冗余备份。</li>
</ul>
</li>
</ul>
<h4 id="多台服务器连接方案"><a href="#多台服务器连接方案" class="headerlink" title="多台服务器连接方案"></a>多台服务器连接方案</h4><ul>
<li>提供数据方：master <ul>
<li>主服务器，主节点，主库 </li>
<li>主客户端</li>
</ul>
</li>
<li>接收数据方：slave <ul>
<li>从服务器，从节点，从库 </li>
<li>从客户端</li>
</ul>
</li>
<li>需要解决的问题： <ul>
<li>数据同步</li>
</ul>
</li>
<li>核心工作： <ul>
<li>master的数据复制到slave中</li>
</ul>
</li>
</ul>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210803234445926.png" alt="image-20210803234445926"></p>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>主从复制即将master中的数据即时、有效的复制到slave中 </p>
<p>特征：一个master可以拥有多个slave，一个slave只对应一个master</p>
<p> 职责：</p>
<ul>
<li>master:<ul>
<li>写数据</li>
<li>执行写操作时，将出现变化的数据自动同步到slave</li>
<li>读数据（可忽略）</li>
</ul>
</li>
<li>slave:<ul>
<li>读数据</li>
<li>写数据（禁止）</li>
</ul>
</li>
</ul>
<h4 id="高可用集群"><a href="#高可用集群" class="headerlink" title="高可用集群"></a>高可用集群</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210803234553228.png" alt="image-20210803234553228"></p>
<h4 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h4><ul>
<li>读写分离：master写、slave读，提高服务器的读写负载能力</li>
<li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li>
<li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li>
<li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li>
<li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li>
</ul>
<h3 id="主从复制工作流程"><a href="#主从复制工作流程" class="headerlink" title="主从复制工作流程"></a>主从复制工作流程</h3><h4 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h4><ul>
<li>主从复制过程大体可以分为3个阶段</li>
<li>建立连接阶段（即准备阶段）</li>
<li>数据同步阶段</li>
<li>命令传播阶段</li>
</ul>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210803234638928.png" alt="image-20210803234638928"></p>
<h4 id="阶段一：建立连接阶段"><a href="#阶段一：建立连接阶段" class="headerlink" title="阶段一：建立连接阶段"></a>阶段一：建立连接阶段</h4><ul>
<li>建立slave到master的连接，使master能够识别slave，并保存slave端口号</li>
</ul>
<h4 id="建立连接阶段工作流程"><a href="#建立连接阶段工作流程" class="headerlink" title="建立连接阶段工作流程"></a>建立连接阶段工作流程</h4><p>步骤1：设置master的地址和端口，保存master信息</p>
<p>步骤2：建立socket连接</p>
<p>步骤3：发送ping命令（定时器任务）</p>
<p>步骤4：身份验证</p>
<p>步骤5：发送slave端口信息</p>
<p>至此，主从连接成功！</p>
<p>状态：</p>
<p>slave：</p>
<p>​    保存master的地址与端口</p>
<p>master：</p>
<p>​    保存slave的端口</p>
<p>总体：</p>
<p>​    之间创建了连接的socket</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210804094954296.png" alt="image-20210804094954296"></p>
<h4 id="主从连接（slave连接master）"><a href="#主从连接（slave连接master）" class="headerlink" title="主从连接（slave连接master）"></a>主从连接（slave连接master）</h4><ul>
<li><p>方式一：客户端发送命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>方式二：启动服务器参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>方式三：服务器配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>slave系统信息</p>
<ul>
<li>master_link_down_since_seconds</li>
<li>masterhost</li>
<li>masterport</li>
</ul>
</li>
<li><p>master系统信息</p>
<ul>
<li>slave_listening_port(多个)</li>
</ul>
</li>
</ul>
<h4 id="主从断开连接"><a href="#主从断开连接" class="headerlink" title="主从断开连接"></a>主从断开连接</h4><ul>
<li><p>客户端发送命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure></li>
<li><p>说明：</p>
<ul>
<li> slave断开连接后，不会删除已有数据，只是不再接受master发送的数据</li>
</ul>
</li>
</ul>
<h4 id="授权访问"><a href="#授权访问" class="headerlink" title="授权访问"></a>授权访问</h4><ul>
<li><p>master客户端发送命令设置密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass &lt;password&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>master配置文件设置密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config set requirepass &lt;password&gt; </span><br><span class="line">config get requirepass</span><br></pre></td></tr></table></figure></li>
<li><p>slave客户端发送命令设置密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth &lt;password&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>slave配置文件设置密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>slave启动服务器设置密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server –a &lt;password&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="阶段二：数据同步阶段工作流程"><a href="#阶段二：数据同步阶段工作流程" class="headerlink" title="阶段二：数据同步阶段工作流程"></a>阶段二：数据同步阶段工作流程</h4><ul>
<li>在slave初次连接master后，复制master中的所有数据到slave</li>
<li>将slave的数据库状态更新成master当前的数据库状态</li>
</ul>
<h4 id="数据同步阶段工作流程"><a href="#数据同步阶段工作流程" class="headerlink" title="数据同步阶段工作流程"></a>数据同步阶段工作流程</h4><p>步骤1：请求同步数据 </p>
<p>步骤2：创建RDB同步数据 </p>
<p>步骤3：恢复RDB同步数据 </p>
<p>步骤4：请求部分同步数据 </p>
<p>步骤5：恢复部分同步数据 至此，数据同步工作完成！ </p>
<p>状态： </p>
<p>slave： </p>
<p>​    具有master端全部数据，包含RDB过程接收的数据 </p>
<p>master： </p>
<p>​    保存slave当前数据同步的位置 </p>
<p>总体： 之间完成了数据克隆</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210804100004054.png" alt="image-20210804100004054"></p>
<h4 id="数据同步阶段master说明"><a href="#数据同步阶段master说明" class="headerlink" title="数据同步阶段master说明"></a>数据同步阶段master说明</h4><ol>
<li><p>如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行</p>
</li>
<li><p>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size 1mb</span><br></pre></td></tr></table></figure></li>
<li><p>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210804100121497.png" alt="image-20210804100121497"></p>
</li>
</ol>
<h4 id="数据同步阶段slave说明"><a href="#数据同步阶段slave说明" class="headerlink" title="数据同步阶段slave说明"></a>数据同步阶段slave说明</h4><ol>
<li><p>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave-serve-stale-data yes|no</span><br></pre></td></tr></table></figure></li>
<li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</p>
</li>
<li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰</p>
</li>
<li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，数据一致性变差，应谨慎选择</p>
</li>
</ol>
<h4 id="阶段三：命令传播阶段"><a href="#阶段三：命令传播阶段" class="headerlink" title="阶段三：命令传播阶段"></a>阶段三：命令传播阶段</h4><ul>
<li>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，同步的动作称为命令传播</li>
<li>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</li>
<li>主从复制过程大体可以分为3个阶段<ul>
<li>建立连接阶段（即准备阶段）</li>
<li>数据同步阶段</li>
<li>命令传播阶段</li>
</ul>
</li>
</ul>
<h4 id="命令传播阶段的部分复制"><a href="#命令传播阶段的部分复制" class="headerlink" title="命令传播阶段的部分复制"></a>命令传播阶段的部分复制</h4><ul>
<li>命令传播阶段出现了断网现象<ul>
<li>网络闪断闪连          忽略</li>
<li>短时间网络中断      部分复制</li>
<li>长时间网络中断      全量复制</li>
</ul>
</li>
<li>部分复制的三个核心要素<ul>
<li>服务器的运行 id（run id）</li>
<li>主服务器的复制积压缓冲区</li>
<li>主从服务器的复制偏移量</li>
</ul>
</li>
</ul>
<h4 id="服务器运行ID（runid）"><a href="#服务器运行ID（runid）" class="headerlink" title="服务器运行ID（runid）"></a>服务器运行ID（runid）</h4><ul>
<li>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</li>
<li>组成：运行id由40位字符组成，是一个随机的十六进制字符<ul>
<li>例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce</li>
</ul>
</li>
<li>作用：运行id被用于在服务器间进行传输，识别身份 <ul>
<li>如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</li>
</ul>
</li>
<li>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid</li>
</ul>
<h4 id="复制缓冲区"><a href="#复制缓冲区" class="headerlink" title="复制缓冲区"></a>复制缓冲区</h4><ul>
<li>概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</li>
</ul>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210804100510720.png" alt="image-20210804100510720"></p>
<h4 id="复制缓冲区内部工作原理"><a href="#复制缓冲区内部工作原理" class="headerlink" title="复制缓冲区内部工作原理"></a>复制缓冲区内部工作原理</h4><ul>
<li>组成<ul>
<li>偏移量</li>
<li>字节值</li>
</ul>
</li>
<li>工作原理<ul>
<li>通过offset区分不同的slave当前数据传播的差异</li>
<li>master记录已发送的信息对应的offset</li>
<li>slave记录已接收的信息对应的offset</li>
</ul>
</li>
</ul>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210804100811798.png" alt="复制缓冲区/复制积压缓冲区"></p>
<h4 id="复制缓冲区-1"><a href="#复制缓冲区-1" class="headerlink" title="复制缓冲区"></a>复制缓冲区</h4><ul>
<li>概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区<ul>
<li>复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列</li>
</ul>
</li>
<li>由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区</li>
<li>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select）</li>
<li>数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中</li>
</ul>
<p>主从服务器复制偏移量（offset）</p>
<ul>
<li>概念：一个数字，描述复制缓冲区中的指令字节位置</li>
<li>分类：<ul>
<li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li>
<li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）</li>
</ul>
</li>
<li>数据来源： <ul>
<li>master端：发送一次记录一次 </li>
<li>slave端：接收一次记录一次</li>
</ul>
</li>
<li>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用</li>
</ul>
<h4 id="数据同步-命令传播阶段工作流程"><a href="#数据同步-命令传播阶段工作流程" class="headerlink" title="数据同步+命令传播阶段工作流程"></a>数据同步+命令传播阶段工作流程</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210804101026777.png" alt="image-20210804101026777"></p>
<h4 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h4><ul>
<li>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</li>
<li>master心跳：<ul>
<li>指令：PING</li>
<li>周期：由repl-ping-slave-period决定，默认10秒</li>
<li>作用：判断slave是否在线</li>
<li>查询：INFO replication                获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li>
</ul>
</li>
<li>slave心跳任务<ul>
<li>指令：REPLCONF ACK {offset}</li>
<li>周期：1秒</li>
<li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li>
<li>作用2：判断master是否在线</li>
</ul>
</li>
</ul>
<h4 id="心跳阶段注意事项"><a href="#心跳阶段注意事项" class="headerlink" title="心跳阶段注意事项"></a>心跳阶段注意事项</h4><ul>
<li><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 2 </span><br><span class="line">min-slaves-max-lag 8</span><br></pre></td></tr></table></figure>

<ul>
<li>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步</li>
</ul>
</li>
<li><p>slave数量由slave发送REPLCONF ACK命令做确认</p>
</li>
<li><p>slave延迟由slave发送REPLCONF ACK命令做确认</p>
</li>
</ul>
<h4 id="主从复制工作流程（完整）"><a href="#主从复制工作流程（完整）" class="headerlink" title="主从复制工作流程（完整）"></a>主从复制工作流程（完整）</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210804101308938.png" alt="image-20210804101308938"></p>
<h3 id="主从复制常见问题"><a href="#主从复制常见问题" class="headerlink" title="主从复制常见问题"></a>主从复制常见问题</h3><h4 id="频繁的全量复制（1）"><a href="#频繁的全量复制（1）" class="headerlink" title="频繁的全量复制（1）"></a>频繁的全量复制（1）</h4><p>伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的全量复制操作 内部优化调整方案：</p>
<ol>
<li><p>master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave</p>
</li>
<li><p>在master关闭时执行命令 shutdown save，进行RDB持久化,将runid与offset保存到RDB文件中</p>
<ul>
<li>repl-id repl-offset</li>
<li>通过redis-check-rdb命令可以查看该信息</li>
</ul>
</li>
<li><p>master重启后加载RDB文件，恢复数据 重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中</p>
<ul>
<li>master_repl_id = repl master_repl_offset = repl-offset</li>
<li>通过info命令可以查看该信息 </li>
</ul>
</li>
</ol>
<p>作用： 本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master</p>
<h4 id="频繁的全量复制（2）"><a href="#频繁的全量复制（2）" class="headerlink" title="频繁的全量复制（2）"></a>频繁的全量复制（2）</h4><ul>
<li><p>问题现象</p>
<ul>
<li>网络环境不佳，出现网络中断，slave不提供服务</li>
</ul>
</li>
<li><p>问题原因</p>
<ul>
<li>复制缓冲区过小，断网后slave的offset越界，触发全量复制</li>
</ul>
</li>
<li><p>最终结果</p>
<ul>
<li>slave反复进行全量复制</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>修改复制缓冲区大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>建议设置如下：</p>
<ol>
<li>测算从master到slave的重连平均时长second</li>
<li>获取master平均每秒产生写命令数据总量write_size_per_second</li>
<li>最优复制缓冲区空间 = 2 * second * write_size_per_second</li>
</ol>
</li>
</ul>
<h4 id="频繁的网络中断（1）"><a href="#频繁的网络中断（1）" class="headerlink" title="频繁的网络中断（1）"></a>频繁的网络中断（1）</h4><ul>
<li><p>问题现象</p>
<ul>
<li>master的CPU占用过高 或 slave频繁断开连接</li>
</ul>
</li>
<li><p>问题原因</p>
<ul>
<li>slave每1秒发送REPLCONF ACK命令到master</li>
<li>当slave接到了慢查询时（keys * ，hgetall等），会大量占用CPU性能</li>
<li>master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应</li>
</ul>
</li>
<li><p>最终结果</p>
<ul>
<li>master各种资源（输出缓冲区、带宽、连接等）被严重占用</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>通过设置合理的超时时间，确认是否释放slave </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-timeout</span><br></pre></td></tr></table></figure></li>
<li><p>该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave</p>
</li>
</ul>
</li>
</ul>
<h4 id="频繁的网络中断（2）"><a href="#频繁的网络中断（2）" class="headerlink" title="频繁的网络中断（2）"></a>频繁的网络中断（2）</h4><ul>
<li><p>问题现象</p>
<ul>
<li>slave与master连接断开</li>
</ul>
</li>
<li><p>问题原因</p>
<ul>
<li>master发送ping指令频度较低</li>
<li>master设定超时时间较短</li>
<li>ping指令在网络中存在丢包</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>提高ping指令发送的频度 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-ping-slave-period</span><br></pre></td></tr></table></figure></li>
<li><p>超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时</p>
</li>
</ul>
</li>
</ul>
<h4 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h4><ul>
<li><p>问题现象</p>
<ul>
<li>多个slave获取相同数据不同步</li>
</ul>
</li>
<li><p>问题原因</p>
<ul>
<li>网络信息不同步，数据发送有延迟</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象</p>
</li>
<li><p>监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave-serve-stale-data yes|no</span><br></pre></td></tr></table></figure></li>
<li><p>开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高）</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" data-id="ckvndazyr001nqsuy43gxfeo1" data-title="11_主从复制" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/10_高级数据类型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T10:07:15.000Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">10_高级数据类型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>公司的年度总结会</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210802233202695.png" alt="image-20210802233202695"></p>
<p>公司的年度总结会第二天</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210802233219570.png" alt="image-20210802233219570"></p>
<h4 id="存储需求"><a href="#存储需求" class="headerlink" title="存储需求"></a>存储需求</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210802233232505.png" alt="image-20210802233232505"></p>
<h4 id="Bitmaps类型的基础操作"><a href="#Bitmaps类型的基础操作" class="headerlink" title="Bitmaps类型的基础操作"></a>Bitmaps类型的基础操作</h4><ul>
<li><p>获取指定key对应偏移量上的bit值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br></pre></td></tr></table></figure></li>
<li><p>设置指定key对应偏移量上的bit值，value只能是1或0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Bitmaps类型的扩展操作"><a href="#Bitmaps类型的扩展操作" class="headerlink" title="Bitmaps类型的扩展操作"></a>Bitmaps类型的扩展操作</h4><p><strong>业务场景</strong></p>
<p>电影网站</p>
<ul>
<li>统计每天某一部电影是否被点播</li>
<li>统计每天有多少部电影被点播</li>
<li>统计每周/月/年有多少部电影被点播</li>
<li>统计年度哪部电影没有被点播</li>
</ul>
<p><strong>业务分析</strong></p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210802233457545.png" alt="image-20210802233457545"></p>
<ul>
<li><p>对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitop op destKey key1 [key2...]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>and：交</p>
</li>
<li><p>or：并</p>
</li>
<li><p>not：非</p>
</li>
<li><p>xor：异或</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>统计指定key中1的数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start end]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Tips 21：</p>
<ul>
<li>redis 应用于信息状态统计</li>
</ul>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><h4 id="统计独立UV"><a href="#统计独立UV" class="headerlink" title="统计独立UV"></a>统计独立UV</h4><ul>
<li>原始方案：set<ul>
<li>存储每个用户的id（字符串）</li>
</ul>
</li>
<li>改进方案：Bitmaps<ul>
<li>存储每个用户状态（bit）</li>
</ul>
</li>
<li>全新的方案：Hyperloglog</li>
</ul>
<h4 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h4><ul>
<li>基数是数据集去重后元素个数</li>
<li>HyperLogLog 是用来做基数统计的，运用了LogLog的算法</li>
</ul>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210802233916785.png" alt="image-20210802233916785"></p>
<h4 id="LogLog算法"><a href="#LogLog算法" class="headerlink" title="LogLog算法"></a>LogLog算法</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210802233931775.png" alt="image-20210802233931775"></p>
<h4 id="HyperLogLog类型的基本操作"><a href="#HyperLogLog类型的基本操作" class="headerlink" title="HyperLogLog类型的基本操作"></a>HyperLogLog类型的基本操作</h4><ul>
<li><p>添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element [element ...]</span><br></pre></td></tr></table></figure></li>
<li><p>统计数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfcount key [key ...]</span><br></pre></td></tr></table></figure></li>
<li><p>合并数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfmerge destkey sourcekey [sourcekey...]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Tips 22：</p>
<ul>
<li>redis 应用于独立信息统计</li>
</ul>
<h4 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h4><ul>
<li>用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据</li>
<li>核心是基数估算算法，最终数值存在一定误差</li>
<li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li>
<li>耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数</li>
<li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大</li>
<li>Pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多少</li>
</ul>
<h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><h4 id="火热的生活服务类软件"><a href="#火热的生活服务类软件" class="headerlink" title="火热的生活服务类软件"></a>火热的生活服务类软件</h4><ul>
<li>微信 / 陌陌</li>
<li>美团 / 饿了么</li>
<li>携程 / 马蜂窝</li>
<li>高德 / 百度</li>
<li>……</li>
</ul>
<h4 id="GEO类型的基本操作"><a href="#GEO类型的基本操作" class="headerlink" title="GEO类型的基本操作"></a>GEO类型的基本操作</h4><ul>
<li><p>添加坐标点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude member [longitude latitude member ...]</span><br></pre></td></tr></table></figure></li>
<li><p>获取坐标点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopos key member [member ...]</span><br></pre></td></tr></table></figure></li>
<li><p>计算坐标点距离</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geodist key member1 member2 [unit]</span><br></pre></td></tr></table></figure></li>
<li><p>添加坐标点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure></li>
<li><p>获取坐标点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure></li>
<li><p>计算经纬度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geohash key member [member ...]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Tips 23：</p>
<ul>
<li>redis 应用于地理位置计算</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" data-id="ckvndazyq001mqsuy875l5lrj" data-title="10_高级数据类型" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/09_redis服务器配置" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/09_redis%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T10:07:01.000Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/09_redis%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/">09_redis服务器配置</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="服务器基础配置"><a href="#服务器基础配置" class="headerlink" title="服务器基础配置"></a>服务器基础配置</h3><h4 id="服务器端设定"><a href="#服务器端设定" class="headerlink" title="服务器端设定"></a>服务器端设定</h4><ul>
<li><p>设置服务器以守护进程的方式运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes|no</span><br></pre></td></tr></table></figure></li>
<li><p>绑定主机地址（只能通过该ip访问）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br></pre></td></tr></table></figure></li>
<li><p>设置服务器端口号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br></pre></td></tr></table></figure></li>
<li><p>设置数据库数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h4><ul>
<li><p>设置服务器以指定日志记录级别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loglevel debug|verbose|notice|warning</span><br></pre></td></tr></table></figure></li>
<li><p>日志记录文件名 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logfile 端口号.log</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频度</p>
<h4 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h4><ul>
<li><p>设置同一时间最大客户端连接数，默认无限制。当客户端连接到达上限，Redis会关闭新的连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxclients 0</span><br></pre></td></tr></table></figure></li>
<li><p>客户端闲置等待最大时长，达到最大值后关闭连接。如需关闭该功能，设置为 0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout 300</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="多服务器快捷配置"><a href="#多服务器快捷配置" class="headerlink" title="多服务器快捷配置"></a>多服务器快捷配置</h4><ul>
<li><p>导入并加载指定配置文件信息，用于快速创建redis公共配置较多的redis实例配置文件，便于维护</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include /path/server-端口号.conf</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/09_redis%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/" data-id="ckvndazyo001jqsuy1txmf33n" data-title="09_redis服务器配置" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/08_删除策略" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T10:06:41.000Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/">08_删除策略</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="过期数据"><a href="#过期数据" class="headerlink" title="过期数据"></a>过期数据</h3><h4 id="Redis中的数据特征"><a href="#Redis中的数据特征" class="headerlink" title="Redis中的数据特征"></a>Redis中的数据特征</h4><ul>
<li>Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态<ul>
<li>XX ：具有时效性的数据</li>
<li>-1 ：永久有效的数据</li>
<li>-2 ：已经过期的数据 或 被删除的数据 或 未定义的数据</li>
</ul>
</li>
</ul>
<p>过期的数据真的删除了吗？</p>
<h4 id="Redis中的数据特征-1"><a href="#Redis中的数据特征-1" class="headerlink" title="Redis中的数据特征"></a>Redis中的数据特征</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/image-20210801232952082.png" alt="image-20210801232952082"></p>
<h4 id="数据删除策略"><a href="#数据删除策略" class="headerlink" title="数据删除策略"></a>数据删除策略</h4><ol>
<li><p>定时删除</p>
</li>
<li><p>惰性删除</p>
</li>
<li><p>定期删除</p>
</li>
</ol>
<h3 id="数据删除策略-1"><a href="#数据删除策略-1" class="headerlink" title="数据删除策略"></a>数据删除策略</h3><h4 id="时效性数据的存储结构"><a href="#时效性数据的存储结构" class="headerlink" title="时效性数据的存储结构"></a>时效性数据的存储结构</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/image-20210801233041559.png" alt="image-20210801233041559"></p>
<h4 id="数据删除策略的目标"><a href="#数据删除策略的目标" class="headerlink" title="数据删除策略的目标"></a>数据删除策略的目标</h4><p>在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露</p>
<h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><ul>
<li><p>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作</p>
</li>
<li><p>优点：节约内存，到时就删除，快速释放掉不必要的内存占用</p>
</li>
<li><p>缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</p>
</li>
<li><p>总结：用处理器性能换取存储空间（拿时间换空间）</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/image-20210801233333017.png" alt="image-20210801233333017"></p>
</li>
</ul>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><ul>
<li>数据到达过期时间，不做处理。等下次访问该数据时<ul>
<li>如果未过期，返回数据</li>
<li>发现已过期，删除，返回不存在</li>
</ul>
</li>
<li>优点：节约CPU性能，发现必须删除的时候才删除</li>
<li>缺点：内存压力很大，出现长期占用内存的数据</li>
<li>总结：用存储空间换取处理器性能（拿时间换空间）</li>
<li><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/image-20210801233425793.png" alt="image-20210801233425793"></li>
</ul>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p><strong>两种方案都走极端，有没有折中方案？</strong></p>
<ul>
<li><p>Redis启动服务器初始化时，读取配置server.hz的值，默认为10</p>
</li>
<li><p>每秒钟执行server.hz次serverCron()–&gt;(databasesCron()–&gt;(activeExpireCycle()))</p>
</li>
<li><p>activeExpireCycle()对每个expires[*]逐一进行检测，每次执行250ms/server.hz</p>
</li>
<li><p>对某个expires[<em>]检测时，随机挑选W个key检测</em></p>
<ul>
<li>如果key超时，删除key</li>
<li>如果一轮中删除的key的数量&gt;W*25%，循环该过程*</li>
<li>如果一轮中删除的key的数量≤W*25%，检查下一个expires[*]，0-15循环</li>
<li>W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值</li>
</ul>
</li>
<li><p>参数current_db用于记录activeExpireCycle() 进入哪个expires[*] 执行</p>
</li>
<li><p>如果activeExpireCycle()执行时间到期，下次从current_db继续向下执行</p>
</li>
<li><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/image-20210801233559062.png" alt="image-20210801233559062"></p>
</li>
<li><p>周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度</p>
</li>
<li><p>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</p>
</li>
<li><p>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</p>
</li>
<li><p>总结：周期性抽查存储空间（随机抽查，重点抽查）</p>
</li>
</ul>
<h4 id="删除策略比对"><a href="#删除策略比对" class="headerlink" title="删除策略比对"></a>删除策略比对</h4><ol>
<li>定时删除<ol>
<li>节约内存，无占用</li>
<li>不分时段占用CPU资源，频度高</li>
<li>拿时间换空间</li>
</ol>
</li>
<li>惰性删除<ol>
<li>内存占用严重</li>
<li>延时执行，CPU利用率高</li>
<li>拿空间换时间</li>
</ol>
</li>
<li>定期删除<ol>
<li>内存定期随机清理</li>
<li>每秒花费固定的CPU资源维护内存</li>
<li>随机抽查，重点抽查</li>
</ol>
</li>
</ol>
<h3 id="逐出算法"><a href="#逐出算法" class="headerlink" title="逐出算法"></a>逐出算法</h3><h4 id="新数据进入检测"><a href="#新数据进入检测" class="headerlink" title="新数据进入检测"></a>新数据进入检测</h4><p><strong>当新数据进入redis时，如果内存不足怎么办？</strong></p>
<ul>
<li><p>Redis使用内存存储数据，在执行每一个命令前，会调用freeMemoryIfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。</p>
</li>
<li><p>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(error) OOM command not allowed when used memory &gt;&#x27;maxmemory&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="影响数据逐出的相关配置"><a href="#影响数据逐出的相关配置" class="headerlink" title="影响数据逐出的相关配置"></a>影响数据逐出的相关配置</h4><ul>
<li><p>最大可使用内存 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory</span><br></pre></td></tr></table></figure>

<ul>
<li>占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。</li>
</ul>
</li>
<li><p>每次选取待删除数据的个数 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-samples</span><br></pre></td></tr></table></figure>

<ul>
<li>选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据</li>
</ul>
</li>
<li><p>删除策略 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy</span><br></pre></td></tr></table></figure>

<ul>
<li>达到最大内存后的，对被挑选出来的数据进行删除的策略</li>
</ul>
</li>
<li><p>检测易失数据（可能会过期的数据集server.db[i].expires ）</p>
<ul>
<li>① volatile-lru：挑选最近最长时间没有使用的数据淘汰    Least Recently Used</li>
<li>② volatile-lfu：挑选最近使用次数最少的数据淘汰    Least Frequently Used</li>
<li>③ volatile-ttl：挑选将要过期的数据淘汰</li>
<li>④ volatile-random：任意选择数据淘汰</li>
</ul>
</li>
<li><p>检测全库数据（所有数据集server.db[i].dict ）</p>
<ul>
<li>⑤ allkeys-lru：挑选最近最少使用的数据淘汰</li>
<li>⑥ allkeys-lfu：挑选最近使用次数最少的数据淘汰</li>
<li>⑦ allkeys-random：任意选择数据淘汰</li>
</ul>
</li>
<li><p>放弃数据驱逐</p>
<ul>
<li><p>⑧ no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="数据逐出策略配置依据"><a href="#数据逐出策略配置依据" class="headerlink" title="数据逐出策略配置依据"></a>数据逐出策略配置依据</h4><ul>
<li>使用INFO命令输出监控信息，查询缓存 hit 和 miss 的次数，根据业务需求调优Redis配置</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/" data-id="ckvndazyl001fqsuy6wax45es" data-title="08_删除策略" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/07_redis事务" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/07_redis%E4%BA%8B%E5%8A%A1/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T10:06:24.169Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><h3 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h3><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><p><strong>Redis执行指令过程中，多条连续执行的指令被干扰，打断，插队</strong></p>
<p>redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性按照添加顺序依次执行，中间不会被打断或者干扰。</p>
<p>一个队列中，一次性、顺序性、排他性的执行一系列命令</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/07_redis%E4%BA%8B%E5%8A%A1/image-20210801000414947.png" alt="image-20210801000414947"></p>
<h3 id="事务基本操作"><a href="#事务基本操作" class="headerlink" title="事务基本操作"></a>事务基本操作</h3><h4 id="事务的边界"><a href="#事务的边界" class="headerlink" title="事务的边界"></a>事务的边界</h4><h4 id="事务的基本操作"><a href="#事务的基本操作" class="headerlink" title="事务的基本操作"></a>事务的基本操作</h4><ul>
<li><p>开启事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi</span><br></pre></td></tr></table></figure></li>
<li><p>作用 </p>
<ul>
<li>设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</li>
</ul>
</li>
<li><p>执行事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec</span><br></pre></td></tr></table></figure></li>
<li><p>作用 </p>
<ul>
<li>设定事务的结束位置，同时执行事务。与multi成对出现，成对使用 </li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行</p>
</blockquote>
<p><strong>事务定义过程中发现出了问题，怎么办？</strong></p>
<ul>
<li><p>取消事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discard</span><br></pre></td></tr></table></figure></li>
<li><p>作用</p>
<ul>
<li> 终止当前事务的定义，发生在multi之后，exec之前</li>
</ul>
</li>
</ul>
<h4 id="事务的工作流程"><a href="#事务的工作流程" class="headerlink" title="事务的工作流程"></a>事务的工作流程</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/07_redis%E4%BA%8B%E5%8A%A1/image-20210801000649399.png" alt="image-20210801000649399"></p>
<h4 id="事务的注意事项"><a href="#事务的注意事项" class="headerlink" title="事务的注意事项"></a>事务的注意事项</h4><p><strong>定义事务的过程中，命令格式输入错误怎么办？</strong></p>
<ul>
<li>语法错误 <ul>
<li>指命令书写格式有误</li>
</ul>
</li>
<li>处理结果 <ul>
<li>如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行。包括那些语法正确的命令。</li>
</ul>
</li>
</ul>
<p><strong>定义事务的过程中，命令执行出现错误怎么办？</strong></p>
<ul>
<li>运行错误 <ul>
<li>指命令格式正确，但是无法正确的执行。例如对list进行incr操作</li>
</ul>
</li>
<li>处理结果 <ul>
<li>能够正确运行的命令会执行，运行错误的命令不会被执行</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。</p>
</blockquote>
<h3 id="手动进行事务回滚"><a href="#手动进行事务回滚" class="headerlink" title="手动进行事务回滚"></a>手动进行事务回滚</h3><ul>
<li>记录操作过程中被影响的数据之前的状态<ul>
<li>单数据：string</li>
<li>多数据：hash、list、set、zset</li>
</ul>
</li>
<li>设置指令恢复所有的被修改的项<ul>
<li>单数据：直接set（注意周边属性，例如时效）</li>
<li>多数据：修改对应值或整体克隆复制</li>
</ul>
</li>
</ul>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="基于特定条件的事务执行"><a href="#基于特定条件的事务执行" class="headerlink" title="基于特定条件的事务执行"></a>基于特定条件的事务执行</h4><p><strong>业务场景</strong></p>
<p>天猫双11热卖过程中，对已经售罄的货物追加补货，4个业务员都有权限进行补货。补货的操作可能是一系列的操作，牵扯到多个连续操作，如何保障不会重复操作？</p>
<p><strong>业务分析</strong></p>
<ul>
<li>多个客户端有可能同时操作同一组数据，并且该数据一旦被操作修改后，将不适用于继续操作</li>
<li>在操作之前锁定要操作的数据，一旦发生变化，终止当前操作</li>
</ul>
<h4 id="基于特定条件的事务执行——锁"><a href="#基于特定条件的事务执行——锁" class="headerlink" title="基于特定条件的事务执行——锁"></a>基于特定条件的事务执行——锁</h4><p><strong>解决方案</strong></p>
<ul>
<li><p>对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch key1 [key2……]</span><br></pre></td></tr></table></figure></li>
<li><p>取消对所有 key 的监视</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unwatch</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Tips 18：</p>
<ul>
<li>redis 应用基于状态控制的批量任务执行</li>
</ul>
<h4 id="基于特定条件的事务执行-1"><a href="#基于特定条件的事务执行-1" class="headerlink" title="基于特定条件的事务执行"></a>基于特定条件的事务执行</h4><p><strong>业务场景</strong></p>
<p>天猫双11热卖过程中，对已经售罄的货物追加补货，且补货完成。客户购买热情高涨，3秒内将所有商品购买完毕。本次补货已经将库存全部清空，如何避免最后一件商品不被多人同时购买？【超卖问题】</p>
<p><strong>业务分析</strong></p>
<ul>
<li>使用watch监控一个key有没有改变已经不能解决问题，此处要监控的是具体数据</li>
<li>虽然redis是单线程的，但是多个客户端对同一数据同时进行操作时，如何避免不被同时修改？</li>
</ul>
<h4 id="基于特定条件的事务执行——分布式锁"><a href="#基于特定条件的事务执行——分布式锁" class="headerlink" title="基于特定条件的事务执行——分布式锁"></a>基于特定条件的事务执行——分布式锁</h4><p><strong>解决方案</strong></p>
<ul>
<li><p>使用 setnx 设置一个公共锁 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx lock-key value</span><br></pre></td></tr></table></figure></li>
<li><p>利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功</p>
<ul>
<li>对于返回设置成功的，拥有控制权，进行下一步的具体业务操作</li>
<li>对于返回设置失败的，不具有控制权，排队或等待 </li>
</ul>
</li>
<li><p>操作完毕通过del操作释放锁</p>
</li>
</ul>
<blockquote>
<p> 注意：上述解决方案是一种设计概念，依赖规范保障，具有风险性</p>
</blockquote>
<p>Tips 19：</p>
<ul>
<li>redis 应用基于分布式锁对应的场景控制</li>
</ul>
<h4 id="基于特定条件的事务执行-2"><a href="#基于特定条件的事务执行-2" class="headerlink" title="基于特定条件的事务执行"></a>基于特定条件的事务执行</h4><p>业务场景</p>
<p>依赖分布式锁的机制，某个用户操作时对应客户端宕机，且此时已经获取到锁。如何解决？</p>
<p><strong>业务分析</strong></p>
<ul>
<li>由于锁操作由用户控制加锁解锁，必定会存在加锁后未解锁的风险</li>
<li>需要解锁操作不能仅依赖用户控制，系统级别要给出对应的保底处理方案</li>
</ul>
<h4 id="基于特定条件的事务执行——分布式锁改良"><a href="#基于特定条件的事务执行——分布式锁改良" class="headerlink" title="基于特定条件的事务执行——分布式锁改良"></a>基于特定条件的事务执行——分布式锁改良</h4><p><strong>解决方案</strong></p>
<ul>
<li><p>使用 expire 为锁key添加时间限定，到时不释放，放弃锁 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expire lock-key second </span><br><span class="line">pexpire lock-key milliseconds</span><br></pre></td></tr></table></figure></li>
</ul>
<p>由于操作通常都是微秒或毫秒级，因此该锁定时间不宜设置过大。具体时间需要业务测试后确认。</p>
<ul>
<li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。</li>
<li>测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时</li>
<li>锁时间设定推荐：最大耗时<em>120%+平均网络延迟</em>110%</li>
<li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</li>
</ul>
<h3 id="redssion"><a href="#redssion" class="headerlink" title="redssion"></a>redssion</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/07_redis%E4%BA%8B%E5%8A%A1/" data-id="ckvndazyn001hqsuycuylauy9" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/06_redis持久化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T10:05:49.000Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/">06_redis持久化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="持久化简介"><a href="#持久化简介" class="headerlink" title="持久化简介"></a>持久化简介</h3><p>意外的断电</p>
<img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731232609724.png" alt="image-20210731232609724" style="zoom:50%;">

<p>“自动备份”</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731232852088.png" alt="image-20210731232852088"></p>
<h4 id="什么是持久化"><a href="#什么是持久化" class="headerlink" title="什么是持久化"></a>什么是持久化</h4><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p>
<h4 id="为什么要进行持久化"><a href="#为什么要进行持久化" class="headerlink" title="为什么要进行持久化"></a>为什么要进行持久化</h4><p>防止数据的意外丢失，确保数据安全性</p>
<h4 id="持久化过程保存什么"><a href="#持久化过程保存什么" class="headerlink" title="持久化过程保存什么"></a>持久化过程保存什么</h4><ul>
<li><p>将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据</p>
</li>
<li><p>将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程</p>
<img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731232947852.png" alt="image-20210731232947852" style="zoom:80%;"></li>
</ul>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="RDB启动方式"><a href="#RDB启动方式" class="headerlink" title="RDB启动方式"></a>RDB启动方式</h4><p><strong>谁，什么时间，干什么事情</strong></p>
<p>命令执行</p>
<ul>
<li>谁：redis操作者（用户）</li>
<li>什么时间：即时（随时进行）</li>
<li>干什么事情：保存数据</li>
</ul>
<p>RDB启动方式 —— save指令</p>
<ul>
<li><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save</span><br></pre></td></tr></table></figure></li>
<li><p>作用</p>
<p>​     手动执行一次保存操作</p>
</li>
</ul>
<h4 id="RDB启动方式-——-save指令相关配置-写在conf文件中"><a href="#RDB启动方式-——-save指令相关配置-写在conf文件中" class="headerlink" title="RDB启动方式 —— save指令相关配置(写在conf文件中)"></a>RDB启动方式 —— save指令相关配置(写在conf文件中)</h4><ul>
<li><code>dbfilename dump.rdb </code><ul>
<li>说明：设置本地数据库文件名，默认值为 dump.rdb </li>
<li>经验：通常设置为dump-端口号.rdb</li>
</ul>
</li>
<li><code>dir </code><ul>
<li>说明：设置存储.rdb文件的路径 </li>
<li>经验：通常设置成存储空间较大的目录中，目录名称data</li>
</ul>
</li>
<li><code>rdbcompression yes </code><ul>
<li>说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩 </li>
<li>经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）</li>
</ul>
</li>
<li><code>rdbchecksum yes </code><ul>
<li>说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行 </li>
<li>经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险</li>
</ul>
</li>
</ul>
<blockquote>
<p>redis在启动时会自动恢复。</p>
</blockquote>
<h4 id="RDB启动方式-——-save指令工作原理"><a href="#RDB启动方式-——-save指令工作原理" class="headerlink" title="RDB启动方式 —— save指令工作原理"></a>RDB启动方式 —— save指令工作原理</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731233318766.png" alt="image-20210731233318766"></p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731233335513.png" alt="image-20210731233335513"></p>
<p><strong>数据量过大，单线程执行方式造成效率过低如何处理？</strong></p>
<p>后台执行</p>
<ul>
<li>谁：redis操作者（用户）发起指令；redis服务器控制指令执行</li>
<li>什么时间：即时（发起）；合理的时间（执行）</li>
<li>干什么事情：保存数据</li>
</ul>
<h4 id="RDB启动方式-——-bgsave指令"><a href="#RDB启动方式-——-bgsave指令" class="headerlink" title="RDB启动方式 —— bgsave指令"></a>RDB启动方式 —— bgsave指令</h4><ul>
<li><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgsave</span><br></pre></td></tr></table></figure></li>
<li><p>作用 </p>
<p>​    手动启动后台保存操作，但不是立即执行</p>
</li>
</ul>
<h4 id="RDB启动方式-——-bgsave指令工作原理"><a href="#RDB启动方式-——-bgsave指令工作原理" class="headerlink" title="RDB启动方式 —— bgsave指令工作原理"></a>RDB启动方式 —— bgsave指令工作原理</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731233619390.png" alt="image-20210731233619390"></p>
<blockquote>
<p>注意： bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用。</p>
</blockquote>
<h4 id="RDB启动方式-——-bgsave指令相关配置"><a href="#RDB启动方式-——-bgsave指令相关配置" class="headerlink" title="RDB启动方式 —— bgsave指令相关配置"></a>RDB启动方式 —— bgsave指令相关配置</h4><ul>
<li><p>dbfilename dump.rdb</p>
</li>
<li><p>dir</p>
</li>
<li><p>rdbcompression yes</p>
</li>
<li><p>rdbchecksum yes</p>
</li>
<li><p>stop-writes-on-bgsave-error yes </p>
<p>​    说明：后台存储过程中如果出现错误现象，是否停止保存操作<br>​    经验：通常默认为开启状态</p>
</li>
</ul>
<p><strong>反复执行保存指令，忘记了怎么办？不知道数据产生了多少变化，何时保存？</strong></p>
<p>自动执行</p>
<ul>
<li><p>谁：redis服务器发起指令（基于条件）</p>
</li>
<li><p>什么时间：满足条件</p>
</li>
<li><p>干什么事情：保存数据</p>
</li>
</ul>
<h4 id="RDB启动方式-——save配置"><a href="#RDB启动方式-——save配置" class="headerlink" title="RDB启动方式 ——save配置"></a>RDB启动方式 ——save配置</h4><ul>
<li><p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save second changes</span><br></pre></td></tr></table></figure></li>
<li><p>作用 </p>
<ul>
<li>满足限定时间范围内key的变化数量达到指定数量即进行持久化</li>
</ul>
</li>
<li><p>参数 </p>
<ul>
<li>second：监控时间范围 </li>
<li>changes：监控key的变化量</li>
</ul>
</li>
<li><p>位置 </p>
<ul>
<li>在conf文件中进行配置</li>
</ul>
</li>
<li><p>范例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 </span><br><span class="line">save 300 10 </span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="RDB启动方式-——save配置原理"><a href="#RDB启动方式-——save配置原理" class="headerlink" title="RDB启动方式 ——save配置原理"></a>RDB启动方式 ——save配置原理</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731234043375.png" alt="image-20210731234043375"></p>
<p>注意： </p>
<ul>
<li>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的 </li>
<li>save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系 </li>
<li>save配置启动后执行的是bgsave操作</li>
</ul>
<h4 id="save配置相关配置"><a href="#save配置相关配置" class="headerlink" title="save配置相关配置"></a>save配置相关配置</h4><ul>
<li><code>dbfilename dump.rdb</code></li>
<li><code>dir</code></li>
<li><code>rdbcompression yes</code></li>
<li><code>rdbchecksum yes</code></li>
</ul>
<h4 id="RDB三种启动方式对比"><a href="#RDB三种启动方式对比" class="headerlink" title="RDB三种启动方式对比"></a>RDB三种启动方式对比</h4><table>
<thead>
<tr>
<th><strong>方式</strong></th>
<th><strong>save指令</strong></th>
<th><strong>bgsave指令</strong></th>
</tr>
</thead>
<tbody><tr>
<td>读写</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>阻塞客户端指令</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>额外内存消耗</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>启动新进程</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="rdb特殊启动形式"><a href="#rdb特殊启动形式" class="headerlink" title="rdb特殊启动形式"></a>rdb特殊启动形式</h4><ul>
<li><p>全量复制 </p>
<ul>
<li>在主从复制中详细讲解</li>
</ul>
</li>
<li><p>服务器运行过程中重启</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug reload</span><br></pre></td></tr></table></figure></li>
<li><p>关闭服务器时指定保存数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown save</span><br></pre></td></tr></table></figure></li>
</ul>
<p>默认情况下执行shutdown命令时，自动执行bgsave(如果没有开启AOF持久化功能)</p>
<h4 id="RDB优点"><a href="#RDB优点" class="headerlink" title="RDB优点"></a>RDB优点</h4><ul>
<li>RDB是一个紧凑压缩的二进制文件，存储效率较高</li>
<li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景</li>
<li>RDB恢复数据的速度要比AOF快很多</li>
<li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</li>
</ul>
<h4 id="Rdb缺点"><a href="#Rdb缺点" class="headerlink" title="Rdb缺点"></a>Rdb缺点</h4><ul>
<li>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据</li>
<li>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能</li>
<li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>RDB存储的弊端</p>
<ul>
<li>存储数据量较大，效率较低 <ul>
<li>基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低</li>
</ul>
</li>
<li>大数据量下的IO性能较低</li>
<li>基于fork创建子进程，内存产生额外消耗</li>
<li>宕机带来的数据丢失风险</li>
</ul>
<p>解决思路</p>
<ul>
<li>不写全数据，仅记录部分数据</li>
<li>降低区分数据是否改变的难度，改记录数据为记录操作过程</li>
<li>对所有操作均进行记录，排除丢失数据的风险</li>
</ul>
<h4 id="AOF概念"><a href="#AOF概念" class="headerlink" title="AOF概念"></a>AOF概念</h4><ul>
<li>AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程</li>
<li>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</li>
</ul>
<h4 id="AOF写数据过程"><a href="#AOF写数据过程" class="headerlink" title="AOF写数据过程"></a>AOF写数据过程</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731234655307.png" alt="image-20210731234655307"></p>
<h4 id="AOF写数据三种策略-appendfsync"><a href="#AOF写数据三种策略-appendfsync" class="headerlink" title="AOF写数据三种策略(appendfsync)"></a>AOF写数据三种策略(appendfsync)</h4><ul>
<li>always(每次） <ul>
<li>每次写入操作均同步到AOF文件中，数据零误差，性能较低，不建议使用。</li>
</ul>
</li>
<li>everysec（每秒） <ul>
<li>每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，性能较高 ，建议使用，也是默认配置</li>
<li>在系统突然宕机的情况下丢失1秒内的数据</li>
</ul>
</li>
<li>no（系统控制） <ul>
<li>由操作系统控制每次同步到AOF文件的周期，整体过程不可控</li>
</ul>
</li>
</ul>
<h4 id="AOF功能开启"><a href="#AOF功能开启" class="headerlink" title="AOF功能开启"></a>AOF功能开启</h4><ul>
<li><p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes|no</span><br></pre></td></tr></table></figure></li>
<li><p>作用 </p>
<ul>
<li>是否开启AOF持久化功能，默认为不开启状态</li>
</ul>
</li>
<li><p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always|everysec|no</span><br></pre></td></tr></table></figure></li>
<li><p>作用 </p>
<ul>
<li>AOF写数据策略</li>
</ul>
</li>
</ul>
<h4 id="AOF相关配置"><a href="#AOF相关配置" class="headerlink" title="AOF相关配置"></a>AOF相关配置</h4><ul>
<li><p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfilename filename</span><br></pre></td></tr></table></figure></li>
<li><p>作用 </p>
<ul>
<li>AOF持久化文件名，默认文件名未appendonly.aof，建议配置为appendonly-端口号.aof</li>
</ul>
</li>
<li><p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure></li>
<li><p>作用</p>
<ul>
<li> AOF持久化文件保存路径，与RDB持久化文件保持一致即可</li>
</ul>
</li>
</ul>
<h4 id="AOF写数据遇到的问题"><a href="#AOF写数据遇到的问题" class="headerlink" title="AOF写数据遇到的问题"></a>AOF写数据遇到的问题</h4><p><strong>如果连续执行如下指令该如何处理</strong></p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731235011802.png" alt="image-20210731235011802"></p>
<h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令进行记录。</p>
<h4 id="AOF重写作用"><a href="#AOF重写作用" class="headerlink" title="AOF重写作用"></a>AOF重写作用</h4><ul>
<li>降低磁盘占用量，提高磁盘利用率</li>
<li>提高持久化效率，降低持久化写时间，提高IO性能</li>
<li>降低数据恢复用时，提高数据恢复效率</li>
</ul>
<h4 id="AOF重写规则"><a href="#AOF重写规则" class="headerlink" title="AOF重写规则"></a>AOF重写规则</h4><ul>
<li>进程内已超时的数据不再写入文件</li>
<li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令 <ul>
<li>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等</li>
</ul>
</li>
<li>对同一数据的多条写命令合并为一条命令 <ul>
<li>如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c。 </li>
<li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</li>
</ul>
</li>
</ul>
<h4 id="AOF重写方式"><a href="#AOF重写方式" class="headerlink" title="AOF重写方式"></a>AOF重写方式</h4><ul>
<li><p>手动重写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgrewriteaof</span><br></pre></td></tr></table></figure></li>
<li><p>自动重写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size size</span><br><span class="line">auto-aof-rewrite-percentage percentage</span><br></pre></td></tr></table></figure></li>
</ul>
<p>RDB启动方式 —— bgsave指令工作原理</p>
<p>AOF手动重写 —— bgrewriteaof指令工作原理</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731235246708.png" alt="image-20210731235246708"></p>
<h4 id="AOF自动重写方式"><a href="#AOF自动重写方式" class="headerlink" title="AOF自动重写方式"></a>AOF自动重写方式</h4><ul>
<li><p>自动重写触发条件设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size size </span><br><span class="line">auto-aof-rewrite-percentage percent</span><br></pre></td></tr></table></figure></li>
<li><p>自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aof_current_size </span><br><span class="line">aof_base_size</span><br></pre></td></tr></table></figure></li>
<li><p>自动重写触发条件</p>
<ul>
<li><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731235412031.png" alt="image-20210731235412031"></li>
</ul>
</li>
</ul>
<blockquote>
<p>可以使用info命令查看redis的各种运行信息。</p>
</blockquote>
<h4 id="AOF工作流程"><a href="#AOF工作流程" class="headerlink" title="AOF工作流程"></a>AOF工作流程</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731235524842.png" alt="image-20210731235524842"></p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731235634342.png" alt="image-20210731235634342"></p>
<p>AOF缓冲区同步文件策略，由参数appendfsync控制 </p>
<p>系统调用write和fsync说明：</p>
<ul>
<li>write操作会触发延迟写（delayed write）机制，Linux在内核提供页缓冲区用来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步硬盘操作依赖于系统调度机制，列如：缓冲区页空间写满或达到特定时间周期。同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。</li>
<li>fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞知道写入硬盘完成后返回，保证了数据持久化。 </li>
<li>除了write、fsync、Linx还提供了sync、fdatasync操作，具体API说明参见：</li>
</ul>
<h3 id="RDB与AOF区别"><a href="#RDB与AOF区别" class="headerlink" title="RDB与AOF区别"></a>RDB与AOF区别</h3><h4 id="RDB-VS-AOF"><a href="#RDB-VS-AOF" class="headerlink" title="RDB VS AOF"></a>RDB VS AOF</h4><table>
<thead>
<tr>
<th><strong>持久化方式</strong></th>
<th><strong>RDB</strong></th>
<th><strong>AOF</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>占用存储空间</strong></td>
<td>小（数据级：压缩）</td>
<td>大（指令级：重写）</td>
</tr>
<tr>
<td><strong>存储速度</strong></td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td><strong>恢复速度</strong></td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td><strong>数据安全性</strong></td>
<td>会丢失数据</td>
<td>依据策略决定</td>
</tr>
<tr>
<td><strong>资源消耗</strong></td>
<td>高/重量级</td>
<td>低/轻量级</td>
</tr>
<tr>
<td><strong>启动优先级</strong></td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h4 id="RDB与AOF的选择之惑"><a href="#RDB与AOF的选择之惑" class="headerlink" title="RDB与AOF的选择之惑"></a>RDB与AOF的选择之惑</h4><ul>
<li>对数据非常敏感，建议使用默认的AOF持久化方案<ul>
<li>AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。</li>
<li>注意：由于AOF文件存储体积较大，且恢复速度较慢</li>
</ul>
</li>
<li>数据呈现阶段有效性，建议使用RDB持久化方案<ul>
<li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段点数据恢复通常采用RDB方案</li>
<li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结：</li>
</ul>
</li>
<li>综合比对<ul>
<li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li>
<li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF</li>
<li>如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB</li>
<li>灾难恢复选用RDB</li>
<li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量</li>
</ul>
</li>
</ul>
<h3 id="持久化应用场景"><a href="#持久化应用场景" class="headerlink" title="持久化应用场景"></a>持久化应用场景</h3><ul>
<li>Tips 1：<del>redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性</del></li>
<li>Tips 3：<del>redis应用于各种结构型和非结构型高热度数据访问加速</del></li>
<li>Tips 4：<del>redis 应用于购物车数据存储设计</del></li>
<li>Tips 5：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计</li>
<li>Tips 6：redis 应用于具有操作先后顺序的数据控制</li>
<li>Tips 7：redis 应用于最新消息展示</li>
<li>Tips 9：<del>redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</del></li>
<li>Tips 12：redis 应用于基于黑名单与白名单设定的服务控制</li>
<li>Tips 13：redis 应用于计数器组合排序功能对应的排名</li>
<li>Tips 15：<del>redis 应用于即时任务/消息队列执行管理</del></li>
<li>Tips 16：<del>redis 应用于按次结算的服务控制</del></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/" data-id="ckvndazyk001eqsuy4dcedhhx" data-title="06_redis持久化" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/" rel="tag">黑马程序员 SSM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot/" rel="tag">黑马程序员 springboot</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" style="font-size: 17.5px;">黑马程序员</a> <a href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/" style="font-size: 20px;">黑马程序员 SSM</a> <a href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot/" style="font-size: 12.5px;">黑马程序员 springboot</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/15/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/docker/docker%E5%85%A5%E9%97%A8/">docker入门</a>
          </li>
        
          <li>
            <a href="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/14_%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">14_企业级解决方案</a>
          </li>
        
          <li>
            <a href="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/13_cluster/">13_cluster</a>
          </li>
        
          <li>
            <a href="/2021/08/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/12_%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/">12_哨兵模式</a>
          </li>
        
          <li>
            <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">11_主从复制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
       2021 豫ICP备20021885号-1<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>