<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-黑马程序员/redis/11_主从复制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T10:07:30.000Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">11_主从复制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="主从复制简介"><a href="#主从复制简介" class="headerlink" title="主从复制简介"></a>主从复制简介</h3><h4 id="互联网“三高”架构"><a href="#互联网“三高”架构" class="headerlink" title="互联网“三高”架构"></a>互联网“三高”架构</h4><ul>
<li>高并发</li>
<li>高性能</li>
<li>高可用</li>
</ul>
<h4 id="你的“Redis”是否高可用"><a href="#你的“Redis”是否高可用" class="headerlink" title="你的“Redis”是否高可用"></a>你的“Redis”是否高可用</h4><p>单机redis的风险与问题</p>
<ul>
<li>问题1.机器故障<ul>
<li>现象：硬盘故障、系统崩溃</li>
<li>本质：数据丢失，很可能对业务造成灾难性打击</li>
<li>结论：基本上会放弃使用redis.</li>
</ul>
</li>
<li>问题2.容量瓶颈<ul>
<li>现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存</li>
<li>本质：穷，硬件条件跟不上</li>
<li>结论：放弃使用redis</li>
</ul>
</li>
<li>结论： <ul>
<li>为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据冗余备份。</li>
</ul>
</li>
</ul>
<h4 id="多台服务器连接方案"><a href="#多台服务器连接方案" class="headerlink" title="多台服务器连接方案"></a>多台服务器连接方案</h4><ul>
<li>提供数据方：master <ul>
<li>主服务器，主节点，主库 </li>
<li>主客户端</li>
</ul>
</li>
<li>接收数据方：slave <ul>
<li>从服务器，从节点，从库 </li>
<li>从客户端</li>
</ul>
</li>
<li>需要解决的问题： <ul>
<li>数据同步</li>
</ul>
</li>
<li>核心工作： <ul>
<li>master的数据复制到slave中</li>
</ul>
</li>
</ul>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210803234445926.png" alt="image-20210803234445926"></p>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>主从复制即将master中的数据即时、有效的复制到slave中 </p>
<p>特征：一个master可以拥有多个slave，一个slave只对应一个master</p>
<p> 职责：</p>
<ul>
<li>master:<ul>
<li>写数据</li>
<li>执行写操作时，将出现变化的数据自动同步到slave</li>
<li>读数据（可忽略）</li>
</ul>
</li>
<li>slave:<ul>
<li>读数据</li>
<li>写数据（禁止）</li>
</ul>
</li>
</ul>
<h4 id="高可用集群"><a href="#高可用集群" class="headerlink" title="高可用集群"></a>高可用集群</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210803234553228.png" alt="image-20210803234553228"></p>
<h4 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h4><ul>
<li>读写分离：master写、slave读，提高服务器的读写负载能力</li>
<li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li>
<li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li>
<li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li>
<li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li>
</ul>
<h3 id="主从复制工作流程"><a href="#主从复制工作流程" class="headerlink" title="主从复制工作流程"></a>主从复制工作流程</h3><h4 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h4><ul>
<li>主从复制过程大体可以分为3个阶段</li>
<li>建立连接阶段（即准备阶段）</li>
<li>数据同步阶段</li>
<li>命令传播阶段</li>
</ul>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210803234638928.png" alt="image-20210803234638928"></p>
<h4 id="阶段一：建立连接阶段"><a href="#阶段一：建立连接阶段" class="headerlink" title="阶段一：建立连接阶段"></a>阶段一：建立连接阶段</h4><ul>
<li>建立slave到master的连接，使master能够识别slave，并保存slave端口号</li>
</ul>
<h4 id="建立连接阶段工作流程"><a href="#建立连接阶段工作流程" class="headerlink" title="建立连接阶段工作流程"></a>建立连接阶段工作流程</h4><p>步骤1：设置master的地址和端口，保存master信息</p>
<p>步骤2：建立socket连接</p>
<p>步骤3：发送ping命令（定时器任务）</p>
<p>步骤4：身份验证</p>
<p>步骤5：发送slave端口信息</p>
<p>至此，主从连接成功！</p>
<p>状态：</p>
<p>slave：</p>
<p>​    保存master的地址与端口</p>
<p>master：</p>
<p>​    保存slave的端口</p>
<p>总体：</p>
<p>​    之间创建了连接的socket</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210804094954296.png" alt="image-20210804094954296"></p>
<h4 id="主从连接（slave连接master）"><a href="#主从连接（slave连接master）" class="headerlink" title="主从连接（slave连接master）"></a>主从连接（slave连接master）</h4><ul>
<li><p>方式一：客户端发送命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>方式二：启动服务器参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>方式三：服务器配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>slave系统信息</p>
<ul>
<li>master_link_down_since_seconds</li>
<li>masterhost</li>
<li>masterport</li>
</ul>
</li>
<li><p>master系统信息</p>
<ul>
<li>slave_listening_port(多个)</li>
</ul>
</li>
</ul>
<h4 id="主从断开连接"><a href="#主从断开连接" class="headerlink" title="主从断开连接"></a>主从断开连接</h4><ul>
<li><p>客户端发送命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure></li>
<li><p>说明：</p>
<ul>
<li> slave断开连接后，不会删除已有数据，只是不再接受master发送的数据</li>
</ul>
</li>
</ul>
<h4 id="授权访问"><a href="#授权访问" class="headerlink" title="授权访问"></a>授权访问</h4><ul>
<li><p>master客户端发送命令设置密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass &lt;password&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>master配置文件设置密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config set requirepass &lt;password&gt; </span><br><span class="line">config get requirepass</span><br></pre></td></tr></table></figure></li>
<li><p>slave客户端发送命令设置密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth &lt;password&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>slave配置文件设置密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>slave启动服务器设置密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server –a &lt;password&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="阶段二：数据同步阶段工作流程"><a href="#阶段二：数据同步阶段工作流程" class="headerlink" title="阶段二：数据同步阶段工作流程"></a>阶段二：数据同步阶段工作流程</h4><ul>
<li>在slave初次连接master后，复制master中的所有数据到slave</li>
<li>将slave的数据库状态更新成master当前的数据库状态</li>
</ul>
<h4 id="数据同步阶段工作流程"><a href="#数据同步阶段工作流程" class="headerlink" title="数据同步阶段工作流程"></a>数据同步阶段工作流程</h4><p>步骤1：请求同步数据 </p>
<p>步骤2：创建RDB同步数据 </p>
<p>步骤3：恢复RDB同步数据 </p>
<p>步骤4：请求部分同步数据 </p>
<p>步骤5：恢复部分同步数据 至此，数据同步工作完成！ </p>
<p>状态： </p>
<p>slave： </p>
<p>​    具有master端全部数据，包含RDB过程接收的数据 </p>
<p>master： </p>
<p>​    保存slave当前数据同步的位置 </p>
<p>总体： 之间完成了数据克隆</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210804100004054.png" alt="image-20210804100004054"></p>
<h4 id="数据同步阶段master说明"><a href="#数据同步阶段master说明" class="headerlink" title="数据同步阶段master说明"></a>数据同步阶段master说明</h4><ol>
<li><p>如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行</p>
</li>
<li><p>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size 1mb</span><br></pre></td></tr></table></figure></li>
<li><p>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210804100121497.png" alt="image-20210804100121497"></p>
</li>
</ol>
<h4 id="数据同步阶段slave说明"><a href="#数据同步阶段slave说明" class="headerlink" title="数据同步阶段slave说明"></a>数据同步阶段slave说明</h4><ol>
<li><p>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave-serve-stale-data yes|no</span><br></pre></td></tr></table></figure></li>
<li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</p>
</li>
<li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰</p>
</li>
<li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，数据一致性变差，应谨慎选择</p>
</li>
</ol>
<h4 id="阶段三：命令传播阶段"><a href="#阶段三：命令传播阶段" class="headerlink" title="阶段三：命令传播阶段"></a>阶段三：命令传播阶段</h4><ul>
<li>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，同步的动作称为命令传播</li>
<li>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</li>
<li>主从复制过程大体可以分为3个阶段<ul>
<li>建立连接阶段（即准备阶段）</li>
<li>数据同步阶段</li>
<li>命令传播阶段</li>
</ul>
</li>
</ul>
<h4 id="命令传播阶段的部分复制"><a href="#命令传播阶段的部分复制" class="headerlink" title="命令传播阶段的部分复制"></a>命令传播阶段的部分复制</h4><ul>
<li>命令传播阶段出现了断网现象<ul>
<li>网络闪断闪连          忽略</li>
<li>短时间网络中断      部分复制</li>
<li>长时间网络中断      全量复制</li>
</ul>
</li>
<li>部分复制的三个核心要素<ul>
<li>服务器的运行 id（run id）</li>
<li>主服务器的复制积压缓冲区</li>
<li>主从服务器的复制偏移量</li>
</ul>
</li>
</ul>
<h4 id="服务器运行ID（runid）"><a href="#服务器运行ID（runid）" class="headerlink" title="服务器运行ID（runid）"></a>服务器运行ID（runid）</h4><ul>
<li>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</li>
<li>组成：运行id由40位字符组成，是一个随机的十六进制字符<ul>
<li>例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce</li>
</ul>
</li>
<li>作用：运行id被用于在服务器间进行传输，识别身份 <ul>
<li>如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</li>
</ul>
</li>
<li>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid</li>
</ul>
<h4 id="复制缓冲区"><a href="#复制缓冲区" class="headerlink" title="复制缓冲区"></a>复制缓冲区</h4><ul>
<li>概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</li>
</ul>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210804100510720.png" alt="image-20210804100510720"></p>
<h4 id="复制缓冲区内部工作原理"><a href="#复制缓冲区内部工作原理" class="headerlink" title="复制缓冲区内部工作原理"></a>复制缓冲区内部工作原理</h4><ul>
<li>组成<ul>
<li>偏移量</li>
<li>字节值</li>
</ul>
</li>
<li>工作原理<ul>
<li>通过offset区分不同的slave当前数据传播的差异</li>
<li>master记录已发送的信息对应的offset</li>
<li>slave记录已接收的信息对应的offset</li>
</ul>
</li>
</ul>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210804100811798.png" alt="复制缓冲区/复制积压缓冲区"></p>
<h4 id="复制缓冲区-1"><a href="#复制缓冲区-1" class="headerlink" title="复制缓冲区"></a>复制缓冲区</h4><ul>
<li>概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区<ul>
<li>复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列</li>
</ul>
</li>
<li>由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区</li>
<li>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select）</li>
<li>数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中</li>
</ul>
<p>主从服务器复制偏移量（offset）</p>
<ul>
<li>概念：一个数字，描述复制缓冲区中的指令字节位置</li>
<li>分类：<ul>
<li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li>
<li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）</li>
</ul>
</li>
<li>数据来源： <ul>
<li>master端：发送一次记录一次 </li>
<li>slave端：接收一次记录一次</li>
</ul>
</li>
<li>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用</li>
</ul>
<h4 id="数据同步-命令传播阶段工作流程"><a href="#数据同步-命令传播阶段工作流程" class="headerlink" title="数据同步+命令传播阶段工作流程"></a>数据同步+命令传播阶段工作流程</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210804101026777.png" alt="image-20210804101026777"></p>
<h4 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h4><ul>
<li>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</li>
<li>master心跳：<ul>
<li>指令：PING</li>
<li>周期：由repl-ping-slave-period决定，默认10秒</li>
<li>作用：判断slave是否在线</li>
<li>查询：INFO replication                获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li>
</ul>
</li>
<li>slave心跳任务<ul>
<li>指令：REPLCONF ACK {offset}</li>
<li>周期：1秒</li>
<li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li>
<li>作用2：判断master是否在线</li>
</ul>
</li>
</ul>
<h4 id="心跳阶段注意事项"><a href="#心跳阶段注意事项" class="headerlink" title="心跳阶段注意事项"></a>心跳阶段注意事项</h4><ul>
<li><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 2 </span><br><span class="line">min-slaves-max-lag 8</span><br></pre></td></tr></table></figure>

<ul>
<li>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步</li>
</ul>
</li>
<li><p>slave数量由slave发送REPLCONF ACK命令做确认</p>
</li>
<li><p>slave延迟由slave发送REPLCONF ACK命令做确认</p>
</li>
</ul>
<h4 id="主从复制工作流程（完整）"><a href="#主从复制工作流程（完整）" class="headerlink" title="主从复制工作流程（完整）"></a>主从复制工作流程（完整）</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210804101308938.png" alt="image-20210804101308938"></p>
<h3 id="主从复制常见问题"><a href="#主从复制常见问题" class="headerlink" title="主从复制常见问题"></a>主从复制常见问题</h3><h4 id="频繁的全量复制（1）"><a href="#频繁的全量复制（1）" class="headerlink" title="频繁的全量复制（1）"></a>频繁的全量复制（1）</h4><p>伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的全量复制操作 内部优化调整方案：</p>
<ol>
<li><p>master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave</p>
</li>
<li><p>在master关闭时执行命令 shutdown save，进行RDB持久化,将runid与offset保存到RDB文件中</p>
<ul>
<li>repl-id repl-offset</li>
<li>通过redis-check-rdb命令可以查看该信息</li>
</ul>
</li>
<li><p>master重启后加载RDB文件，恢复数据 重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中</p>
<ul>
<li>master_repl_id = repl master_repl_offset = repl-offset</li>
<li>通过info命令可以查看该信息 </li>
</ul>
</li>
</ol>
<p>作用： 本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master</p>
<h4 id="频繁的全量复制（2）"><a href="#频繁的全量复制（2）" class="headerlink" title="频繁的全量复制（2）"></a>频繁的全量复制（2）</h4><ul>
<li><p>问题现象</p>
<ul>
<li>网络环境不佳，出现网络中断，slave不提供服务</li>
</ul>
</li>
<li><p>问题原因</p>
<ul>
<li>复制缓冲区过小，断网后slave的offset越界，触发全量复制</li>
</ul>
</li>
<li><p>最终结果</p>
<ul>
<li>slave反复进行全量复制</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>修改复制缓冲区大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>建议设置如下：</p>
<ol>
<li>测算从master到slave的重连平均时长second</li>
<li>获取master平均每秒产生写命令数据总量write_size_per_second</li>
<li>最优复制缓冲区空间 = 2 * second * write_size_per_second</li>
</ol>
</li>
</ul>
<p>频繁的网络中断（1）</p>
<ul>
<li><p>问题现象</p>
<ul>
<li>master的CPU占用过高 或 slave频繁断开连接</li>
</ul>
</li>
<li><p>问题原因</p>
<ul>
<li>slave每1秒发送REPLCONF ACK命令到master</li>
<li>当slave接到了慢查询时（keys * ，hgetall等），会大量占用CPU性能</li>
<li>master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应</li>
</ul>
</li>
<li><p>最终结果</p>
<ul>
<li>master各种资源（输出缓冲区、带宽、连接等）被严重占用</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>通过设置合理的超时时间，确认是否释放slave </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-timeout</span><br></pre></td></tr></table></figure></li>
<li><p>该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave</p>
</li>
</ul>
</li>
</ul>
<h4 id="频繁的网络中断（2）"><a href="#频繁的网络中断（2）" class="headerlink" title="频繁的网络中断（2）"></a>频繁的网络中断（2）</h4><ul>
<li><p>问题现象</p>
<ul>
<li>slave与master连接断开</li>
</ul>
</li>
<li><p>问题原因</p>
<ul>
<li>master发送ping指令频度较低</li>
<li>master设定超时时间较短</li>
<li>ping指令在网络中存在丢包</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>提高ping指令发送的频度 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-ping-slave-period</span><br></pre></td></tr></table></figure></li>
<li><p>超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时</p>
</li>
</ul>
</li>
</ul>
<h4 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h4><ul>
<li><p>问题现象</p>
<ul>
<li>多个slave获取相同数据不同步</li>
</ul>
</li>
<li><p>问题原因</p>
<ul>
<li>网络信息不同步，数据发送有延迟</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象</p>
</li>
<li><p>监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave-serve-stale-data yes|no</span><br></pre></td></tr></table></figure></li>
<li><p>开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高）</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" data-id="ckrxceg6d000z8cuye16u0wvq" data-title="11_主从复制" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/10_高级数据类型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T10:07:15.000Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">10_高级数据类型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>公司的年度总结会</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210802233202695.png" alt="image-20210802233202695"></p>
<p>公司的年度总结会第二天</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210802233219570.png" alt="image-20210802233219570"></p>
<h4 id="存储需求"><a href="#存储需求" class="headerlink" title="存储需求"></a>存储需求</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210802233232505.png" alt="image-20210802233232505"></p>
<h4 id="Bitmaps类型的基础操作"><a href="#Bitmaps类型的基础操作" class="headerlink" title="Bitmaps类型的基础操作"></a>Bitmaps类型的基础操作</h4><ul>
<li><p>获取指定key对应偏移量上的bit值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br></pre></td></tr></table></figure></li>
<li><p>设置指定key对应偏移量上的bit值，value只能是1或0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Bitmaps类型的扩展操作"><a href="#Bitmaps类型的扩展操作" class="headerlink" title="Bitmaps类型的扩展操作"></a>Bitmaps类型的扩展操作</h4><p>**业务场景</p>
<p>电影网站</p>
<ul>
<li>统计每天某一部电影是否被点播</li>
<li>统计每天有多少部电影被点播</li>
<li>统计每周/月/年有多少部电影被点播</li>
<li>统计年度哪部电影没有被点播</li>
</ul>
<p><strong>业务分析</strong></p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210802233457545.png" alt="image-20210802233457545"></p>
<ul>
<li><p>对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitop op destKey key1 [key2...]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>and：交</p>
</li>
<li><p>or：并</p>
</li>
<li><p>not：非</p>
</li>
<li><p>xor：异或</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>统计指定key中1的数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start end]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Tips 21：</p>
<ul>
<li>redis 应用于信息状态统计</li>
</ul>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><h4 id="统计独立UV"><a href="#统计独立UV" class="headerlink" title="统计独立UV"></a>统计独立UV</h4><ul>
<li>原始方案：set<ul>
<li>存储每个用户的id（字符串）</li>
</ul>
</li>
<li>改进方案：Bitmaps<ul>
<li>存储每个用户状态（bit）</li>
</ul>
</li>
<li>全新的方案：Hyperloglog</li>
</ul>
<h4 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h4><ul>
<li>基数是数据集去重后元素个数</li>
<li>HyperLogLog 是用来做基数统计的，运用了LogLog的算法</li>
</ul>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210802233916785.png" alt="image-20210802233916785"></p>
<h4 id="LogLog算法"><a href="#LogLog算法" class="headerlink" title="LogLog算法"></a>LogLog算法</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210802233931775.png" alt="image-20210802233931775"></p>
<h4 id="HyperLogLog类型的基本操作"><a href="#HyperLogLog类型的基本操作" class="headerlink" title="HyperLogLog类型的基本操作"></a>HyperLogLog类型的基本操作</h4><ul>
<li><p>添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element [element ...]</span><br></pre></td></tr></table></figure></li>
<li><p>统计数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfcount key [key ...]</span><br></pre></td></tr></table></figure></li>
<li><p>合并数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfmerge destkey sourcekey [sourcekey...]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Tips 22：</p>
<ul>
<li>redis 应用于独立信息统计</li>
</ul>
<h4 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h4><ul>
<li>用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据</li>
<li>核心是基数估算算法，最终数值存在一定误差</li>
<li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li>
<li>耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数</li>
<li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大</li>
<li>Pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多少</li>
</ul>
<h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><h4 id="火热的生活服务类软件"><a href="#火热的生活服务类软件" class="headerlink" title="火热的生活服务类软件"></a>火热的生活服务类软件</h4><ul>
<li>微信 / 陌陌</li>
<li>美团 / 饿了么</li>
<li>携程 / 马蜂窝</li>
<li>高德 / 百度</li>
<li>……</li>
</ul>
<h4 id="GEO类型的基本操作"><a href="#GEO类型的基本操作" class="headerlink" title="GEO类型的基本操作"></a>GEO类型的基本操作</h4><ul>
<li><p>添加坐标点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude member [longitude latitude member ...]</span><br></pre></td></tr></table></figure></li>
<li><p>获取坐标点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopos key member [member ...]</span><br></pre></td></tr></table></figure></li>
<li><p>计算坐标点距离</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geodist key member1 member2 [unit]</span><br></pre></td></tr></table></figure></li>
<li><p>添加坐标点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure></li>
<li><p>获取坐标点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure></li>
<li><p>计算经纬度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geohash key member [member ...]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Tips 23：</p>
<ul>
<li>redis 应用于地理位置计算</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" data-id="ckrxceg68000g8cuy0gq9a0kg" data-title="10_高级数据类型" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/09_redis服务器配置" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/09_redis%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T10:07:01.000Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/09_redis%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/">09_redis服务器配置</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="服务器基础配置"><a href="#服务器基础配置" class="headerlink" title="服务器基础配置"></a>服务器基础配置</h3><h4 id="服务器端设定"><a href="#服务器端设定" class="headerlink" title="服务器端设定"></a>服务器端设定</h4><ul>
<li><p>设置服务器以守护进程的方式运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes|no</span><br></pre></td></tr></table></figure></li>
<li><p>绑定主机地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br></pre></td></tr></table></figure></li>
<li><p>设置服务器端口号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br></pre></td></tr></table></figure></li>
<li><p>设置数据库数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h4><ul>
<li><p>设置服务器以指定日志记录级别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loglevel debug|verbose|notice|warning</span><br></pre></td></tr></table></figure></li>
<li><p>日志记录文件名 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logfile 端口号.log</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频度</p>
<h4 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h4><ul>
<li><p>设置同一时间最大客户端连接数，默认无限制。当客户端连接到达上限，Redis会关闭新的连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxclients 0</span><br></pre></td></tr></table></figure></li>
<li><p>客户端闲置等待最大时长，达到最大值后关闭连接。如需关闭该功能，设置为 0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout 300</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="多服务器快捷配置"><a href="#多服务器快捷配置" class="headerlink" title="多服务器快捷配置"></a>多服务器快捷配置</h4><ul>
<li><p>导入并加载指定配置文件信息，用于快速创建redis公共配置较多的redis实例配置文件，便于维护</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include /path/server-端口号.conf</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/09_redis%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/" data-id="ckrxceg67000e8cuy7rm4diiq" data-title="09_redis服务器配置" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/08_删除策略" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T10:06:41.000Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/">08_删除策略</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="过期数据"><a href="#过期数据" class="headerlink" title="过期数据"></a>过期数据</h3><h4 id="Redis中的数据特征"><a href="#Redis中的数据特征" class="headerlink" title="Redis中的数据特征"></a>Redis中的数据特征</h4><ul>
<li>Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态<ul>
<li>XX ：具有时效性的数据</li>
<li>-1 ：永久有效的数据</li>
<li>-2 ：已经过期的数据 或 被删除的数据 或 未定义的数据</li>
</ul>
</li>
</ul>
<p>过期的数据真的删除了吗？</p>
<h4 id="Redis中的数据特征-1"><a href="#Redis中的数据特征-1" class="headerlink" title="Redis中的数据特征"></a>Redis中的数据特征</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/image-20210801232952082.png" alt="image-20210801232952082"></p>
<h4 id="数据删除策略"><a href="#数据删除策略" class="headerlink" title="数据删除策略"></a>数据删除策略</h4><ol>
<li><p>定时删除</p>
</li>
<li><p>惰性删除</p>
</li>
<li><p>定期删除</p>
</li>
</ol>
<h3 id="数据删除策略-1"><a href="#数据删除策略-1" class="headerlink" title="数据删除策略"></a>数据删除策略</h3><h4 id="时效性数据的存储结构"><a href="#时效性数据的存储结构" class="headerlink" title="时效性数据的存储结构"></a>时效性数据的存储结构</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/image-20210801233041559.png" alt="image-20210801233041559"></p>
<h4 id="数据删除策略的目标"><a href="#数据删除策略的目标" class="headerlink" title="数据删除策略的目标"></a>数据删除策略的目标</h4><p>在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露</p>
<h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><ul>
<li><p>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作</p>
</li>
<li><p>优点：节约内存，到时就删除，快速释放掉不必要的内存占用</p>
</li>
<li><p>缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</p>
</li>
<li><p>总结：用处理器性能换取存储空间（拿时间换空间）</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/image-20210801233333017.png" alt="image-20210801233333017"></p>
</li>
</ul>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><ul>
<li>数据到达过期时间，不做处理。等下次访问该数据时<ul>
<li>如果未过期，返回数据</li>
<li>发现已过期，删除，返回不存在</li>
</ul>
</li>
<li>优点：节约CPU性能，发现必须删除的时候才删除</li>
<li>缺点：内存压力很大，出现长期占用内存的数据</li>
<li>总结：用存储空间换取处理器性能（拿时间换空间）</li>
<li><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/image-20210801233425793.png" alt="image-20210801233425793"></li>
</ul>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p><strong>两种方案都走极端，有没有折中方案？</strong></p>
<ul>
<li><p>Redis启动服务器初始化时，读取配置server.hz的值，默认为10</p>
</li>
<li><p>每秒钟执行server.hz次serverCron()–&gt;(databasesCron()–&gt;(activeExpireCycle()))</p>
</li>
<li><p>activeExpireCycle()对每个expires[*]逐一进行检测，每次执行250ms/server.hz</p>
</li>
<li><p>对某个expires[<em>]检测时，随机挑选W个key检测</em></p>
<ul>
<li>如果key超时，删除key</li>
<li>如果一轮中删除的key的数量&gt;W<em>25%，循环该过程</em></li>
<li>如果一轮中删除的key的数量≤W<em>25%，检查下一个expires[</em>]，0-15循环*</li>
<li>W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值</li>
</ul>
</li>
<li><p>参数current_db用于记录activeExpireCycle() 进入哪个expires[*] 执行</p>
</li>
<li><p>如果activeExpireCycle()执行时间到期，下次从current_db继续向下执行</p>
</li>
<li><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/image-20210801233559062.png" alt="image-20210801233559062"></p>
</li>
<li><p>周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度</p>
</li>
<li><p>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</p>
</li>
<li><p>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</p>
</li>
<li><p>总结：周期性抽查存储空间（随机抽查，重点抽查）</p>
</li>
</ul>
<h4 id="删除策略比对"><a href="#删除策略比对" class="headerlink" title="删除策略比对"></a>删除策略比对</h4><ol>
<li>定时删除<ol>
<li>节约内存，无占用</li>
<li>不分时段占用CPU资源，频度高</li>
<li>拿时间换空间</li>
</ol>
</li>
<li>惰性删除<ol>
<li>内存占用严重</li>
<li>延时执行，CPU利用率高</li>
<li>拿空间换时间</li>
</ol>
</li>
<li>定期删除<ol>
<li>内存定期随机清理</li>
<li>每秒花费固定的CPU资源维护内存</li>
<li>随机抽查，重点抽查</li>
</ol>
</li>
</ol>
<h3 id="逐出算法"><a href="#逐出算法" class="headerlink" title="逐出算法"></a>逐出算法</h3><h4 id="新数据进入检测"><a href="#新数据进入检测" class="headerlink" title="新数据进入检测"></a>新数据进入检测</h4><p><strong>当新数据进入redis时，如果内存不足怎么办？</strong></p>
<ul>
<li><p>Redis使用内存存储数据，在执行每一个命令前，会调用freeMemoryIfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。</p>
</li>
<li><p>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(error) OOM command not allowed when used memory &gt;&#x27;maxmemory&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="影响数据逐出的相关配置"><a href="#影响数据逐出的相关配置" class="headerlink" title="影响数据逐出的相关配置"></a>影响数据逐出的相关配置</h4><ul>
<li><p>最大可使用内存 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory</span><br></pre></td></tr></table></figure>

<ul>
<li>占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。</li>
</ul>
</li>
<li><p>每次选取待删除数据的个数 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-samples</span><br></pre></td></tr></table></figure>

<ul>
<li>选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据</li>
</ul>
</li>
<li><p>删除策略 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy</span><br></pre></td></tr></table></figure>

<ul>
<li>达到最大内存后的，对被挑选出来的数据进行删除的策略</li>
</ul>
</li>
<li><p>检测易失数据（可能会过期的数据集server.db[i].expires ）</p>
<ul>
<li>① volatile-lru：挑选最近最少使用的数据淘汰</li>
<li>② volatile-lfu：挑选最近使用次数最少的数据淘汰</li>
<li>③ volatile-ttl：挑选将要过期的数据淘汰</li>
<li>④ volatile-random：任意选择数据淘汰</li>
</ul>
</li>
<li><p>检测全库数据（所有数据集server.db[i].dict ）</p>
<ul>
<li>⑤ allkeys-lru：挑选最近最少使用的数据淘汰</li>
<li>⑥ allkeys-lfu：挑选最近使用次数最少的数据淘汰</li>
<li>⑦ allkeys-random：任意选择数据淘汰</li>
</ul>
</li>
<li><p>放弃数据驱逐</p>
<ul>
<li>⑧ no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）</li>
</ul>
</li>
</ul>
<h4 id="数据逐出策略配置依据"><a href="#数据逐出策略配置依据" class="headerlink" title="数据逐出策略配置依据"></a>数据逐出策略配置依据</h4><ul>
<li>使用INFO命令输出监控信息，查询缓存 hit 和 miss 的次数，根据业务需求调优Redis配置</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/" data-id="ckrxceg66000b8cuy2nux0a48" data-title="08_删除策略" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/07_redis事务" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/07_redis%E4%BA%8B%E5%8A%A1/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T10:06:24.169Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><h3 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h3><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><p><strong>Redis执行指令过程中，多条连续执行的指令被干扰，打断，插队</strong></p>
<p>redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性按照添加顺序依次执行，中间不会被打断或者干扰。</p>
<p>一个队列中，一次性、顺序性、排他性的执行一系列命令</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/07_redis%E4%BA%8B%E5%8A%A1/image-20210801000414947.png" alt="image-20210801000414947"></p>
<h3 id="事务基本操作"><a href="#事务基本操作" class="headerlink" title="事务基本操作"></a>事务基本操作</h3><h4 id="事务的边界"><a href="#事务的边界" class="headerlink" title="事务的边界"></a>事务的边界</h4><h4 id="事务的基本操作"><a href="#事务的基本操作" class="headerlink" title="事务的基本操作"></a>事务的基本操作</h4><ul>
<li><p>开启事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi</span><br></pre></td></tr></table></figure></li>
<li><p>作用 </p>
<ul>
<li>设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</li>
</ul>
</li>
<li><p>执行事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec</span><br></pre></td></tr></table></figure></li>
<li><p>作用 </p>
<ul>
<li>设定事务的结束位置，同时执行事务。与multi成对出现，成对使用 </li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行</p>
</blockquote>
<p><strong>事务定义过程中发现出了问题，怎么办？</strong></p>
<ul>
<li><p>取消事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discard</span><br></pre></td></tr></table></figure></li>
<li><p>作用</p>
<ul>
<li> 终止当前事务的定义，发生在multi之后，exec之前</li>
</ul>
</li>
</ul>
<h4 id="事务的工作流程"><a href="#事务的工作流程" class="headerlink" title="事务的工作流程"></a>事务的工作流程</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/07_redis%E4%BA%8B%E5%8A%A1/image-20210801000649399.png" alt="image-20210801000649399"></p>
<h4 id="事务的注意事项"><a href="#事务的注意事项" class="headerlink" title="事务的注意事项"></a>事务的注意事项</h4><p><strong>定义事务的过程中，命令格式输入错误怎么办？</strong></p>
<ul>
<li>语法错误 <ul>
<li>指命令书写格式有误</li>
</ul>
</li>
<li>处理结果 <ul>
<li>如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行。包括那些语法正确的命令。</li>
</ul>
</li>
</ul>
<p><strong>定义事务的过程中，命令执行出现错误怎么办？</strong></p>
<ul>
<li>运行错误 <ul>
<li>指命令格式正确，但是无法正确的执行。例如对list进行incr操作</li>
</ul>
</li>
<li>处理结果 <ul>
<li>能够正确运行的命令会执行，运行错误的命令不会被执行</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。</p>
</blockquote>
<h3 id="手动进行事务回滚"><a href="#手动进行事务回滚" class="headerlink" title="手动进行事务回滚"></a>手动进行事务回滚</h3><ul>
<li>记录操作过程中被影响的数据之前的状态<ul>
<li>单数据：string</li>
<li>多数据：hash、list、set、zset</li>
</ul>
</li>
<li>设置指令恢复所有的被修改的项<ul>
<li>单数据：直接set（注意周边属性，例如时效）</li>
<li>多数据：修改对应值或整体克隆复制</li>
</ul>
</li>
</ul>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="基于特定条件的事务执行"><a href="#基于特定条件的事务执行" class="headerlink" title="基于特定条件的事务执行"></a>基于特定条件的事务执行</h4><p><strong>业务场景</strong></p>
<p>天猫双11热卖过程中，对已经售罄的货物追加补货，4个业务员都有权限进行补货。补货的操作可能是一系列的操作，牵扯到多个连续操作，如何保障不会重复操作？</p>
<p><strong>业务分析</strong></p>
<ul>
<li>多个客户端有可能同时操作同一组数据，并且该数据一旦被操作修改后，将不适用于继续操作</li>
<li>在操作之前锁定要操作的数据，一旦发生变化，终止当前操作</li>
</ul>
<h4 id="基于特定条件的事务执行——锁"><a href="#基于特定条件的事务执行——锁" class="headerlink" title="基于特定条件的事务执行——锁"></a>基于特定条件的事务执行——锁</h4><p><strong>解决方案</strong></p>
<ul>
<li><p>对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch key1 [key2……]</span><br></pre></td></tr></table></figure></li>
<li><p>取消对所有 key 的监视</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unwatch</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Tips 18：</p>
<ul>
<li>redis 应用基于状态控制的批量任务执行</li>
</ul>
<h4 id="基于特定条件的事务执行-1"><a href="#基于特定条件的事务执行-1" class="headerlink" title="基于特定条件的事务执行"></a>基于特定条件的事务执行</h4><p><strong>业务场景</strong></p>
<p>天猫双11热卖过程中，对已经售罄的货物追加补货，且补货完成。客户购买热情高涨，3秒内将所有商品购买完毕。本次补货已经将库存全部清空，如何避免最后一件商品不被多人同时购买？【超卖问题】</p>
<p><strong>业务分析</strong></p>
<ul>
<li>使用watch监控一个key有没有改变已经不能解决问题，此处要监控的是具体数据</li>
<li>虽然redis是单线程的，但是多个客户端对同一数据同时进行操作时，如何避免不被同时修改？</li>
</ul>
<h4 id="基于特定条件的事务执行——分布式锁"><a href="#基于特定条件的事务执行——分布式锁" class="headerlink" title="基于特定条件的事务执行——分布式锁"></a>基于特定条件的事务执行——分布式锁</h4><p><strong>解决方案</strong></p>
<ul>
<li><p>使用 setnx 设置一个公共锁 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx lock-key value</span><br></pre></td></tr></table></figure></li>
<li><p>利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功</p>
<ul>
<li>对于返回设置成功的，拥有控制权，进行下一步的具体业务操作</li>
<li>对于返回设置失败的，不具有控制权，排队或等待 </li>
</ul>
</li>
<li><p>操作完毕通过del操作释放锁</p>
</li>
</ul>
<blockquote>
<p> 注意：上述解决方案是一种设计概念，依赖规范保障，具有风险性</p>
</blockquote>
<p>Tips 19：</p>
<ul>
<li>redis 应用基于分布式锁对应的场景控制</li>
</ul>
<h4 id="基于特定条件的事务执行-2"><a href="#基于特定条件的事务执行-2" class="headerlink" title="基于特定条件的事务执行"></a>基于特定条件的事务执行</h4><p>业务场景</p>
<p>依赖分布式锁的机制，某个用户操作时对应客户端宕机，且此时已经获取到锁。如何解决？</p>
<p><strong>业务分析</strong></p>
<ul>
<li>由于锁操作由用户控制加锁解锁，必定会存在加锁后未解锁的风险</li>
<li>需要解锁操作不能仅依赖用户控制，系统级别要给出对应的保底处理方案</li>
</ul>
<h4 id="基于特定条件的事务执行——分布式锁改良"><a href="#基于特定条件的事务执行——分布式锁改良" class="headerlink" title="基于特定条件的事务执行——分布式锁改良"></a>基于特定条件的事务执行——分布式锁改良</h4><p><strong>解决方案</strong></p>
<ul>
<li><p>使用 expire 为锁key添加时间限定，到时不释放，放弃锁 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expire lock-key second </span><br><span class="line">pexpire lock-key milliseconds</span><br></pre></td></tr></table></figure></li>
</ul>
<p>由于操作通常都是微秒或毫秒级，因此该锁定时间不宜设置过大。具体时间需要业务测试后确认。</p>
<ul>
<li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。</li>
<li>测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时</li>
<li>锁时间设定推荐：最大耗时<em>120%+平均网络延迟</em>110%</li>
<li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</li>
</ul>
<h3 id="redssion"><a href="#redssion" class="headerlink" title="redssion"></a>redssion</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/07_redis%E4%BA%8B%E5%8A%A1/" data-id="ckrxceg6500098cuyhp9wdpxu" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/06_redis持久化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T10:05:49.000Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/">06_redis持久化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="持久化简介"><a href="#持久化简介" class="headerlink" title="持久化简介"></a>持久化简介</h3><p>意外的断电</p>
<img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731232609724.png" alt="image-20210731232609724" style="zoom:50%;">

<p>“自动备份”</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731232852088.png" alt="image-20210731232852088"></p>
<h4 id="什么是持久化"><a href="#什么是持久化" class="headerlink" title="什么是持久化"></a>什么是持久化</h4><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p>
<h4 id="为什么要进行持久化"><a href="#为什么要进行持久化" class="headerlink" title="为什么要进行持久化"></a>为什么要进行持久化</h4><p>防止数据的意外丢失，确保数据安全性</p>
<h4 id="持久化过程保存什么"><a href="#持久化过程保存什么" class="headerlink" title="持久化过程保存什么"></a>持久化过程保存什么</h4><ul>
<li><p>将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据</p>
</li>
<li><p>将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程</p>
<img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731232947852.png" alt="image-20210731232947852" style="zoom:80%;"></li>
</ul>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="RDB启动方式"><a href="#RDB启动方式" class="headerlink" title="RDB启动方式"></a>RDB启动方式</h4><p><strong>谁，什么时间，干什么事情</strong></p>
<p>命令执行</p>
<ul>
<li>谁：redis操作者（用户）</li>
<li>什么时间：即时（随时进行）</li>
<li>干什么事情：保存数据</li>
</ul>
<p>RDB启动方式 —— save指令</p>
<ul>
<li><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save</span><br></pre></td></tr></table></figure></li>
<li><p>作用</p>
<p>​     手动执行一次保存操作</p>
</li>
</ul>
<h4 id="RDB启动方式-——-save指令相关配置-写在conf文件中"><a href="#RDB启动方式-——-save指令相关配置-写在conf文件中" class="headerlink" title="RDB启动方式 —— save指令相关配置(写在conf文件中)"></a>RDB启动方式 —— save指令相关配置(写在conf文件中)</h4><ul>
<li><code>dbfilename dump.rdb </code><ul>
<li>说明：设置本地数据库文件名，默认值为 dump.rdb </li>
<li>经验：通常设置为dump-端口号.rdb</li>
</ul>
</li>
<li><code>dir </code><ul>
<li>说明：设置存储.rdb文件的路径 </li>
<li>经验：通常设置成存储空间较大的目录中，目录名称data</li>
</ul>
</li>
<li><code>rdbcompression yes </code><ul>
<li>说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩 </li>
<li>经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）</li>
</ul>
</li>
<li><code>rdbchecksum yes </code><ul>
<li>说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行 </li>
<li>经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险</li>
</ul>
</li>
</ul>
<blockquote>
<p>redis在启动时会自动恢复。</p>
</blockquote>
<h4 id="RDB启动方式-——-save指令工作原理"><a href="#RDB启动方式-——-save指令工作原理" class="headerlink" title="RDB启动方式 —— save指令工作原理"></a>RDB启动方式 —— save指令工作原理</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731233318766.png" alt="image-20210731233318766"></p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731233335513.png" alt="image-20210731233335513"></p>
<p><strong>数据量过大，单线程执行方式造成效率过低如何处理？</strong></p>
<p>后台执行</p>
<ul>
<li>谁：redis操作者（用户）发起指令；redis服务器控制指令执行</li>
<li>什么时间：即时（发起）；合理的时间（执行）</li>
<li>干什么事情：保存数据</li>
</ul>
<h4 id="RDB启动方式-——-bgsave指令"><a href="#RDB启动方式-——-bgsave指令" class="headerlink" title="RDB启动方式 —— bgsave指令"></a>RDB启动方式 —— bgsave指令</h4><ul>
<li><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgsave</span><br></pre></td></tr></table></figure></li>
<li><p>作用 </p>
<p>​    手动启动后台保存操作，但不是立即执行</p>
</li>
</ul>
<h4 id="RDB启动方式-——-bgsave指令工作原理"><a href="#RDB启动方式-——-bgsave指令工作原理" class="headerlink" title="RDB启动方式 —— bgsave指令工作原理"></a>RDB启动方式 —— bgsave指令工作原理</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731233619390.png" alt="image-20210731233619390"></p>
<blockquote>
<p>注意： bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用。</p>
</blockquote>
<h4 id="RDB启动方式-——-bgsave指令相关配置"><a href="#RDB启动方式-——-bgsave指令相关配置" class="headerlink" title="RDB启动方式 —— bgsave指令相关配置"></a>RDB启动方式 —— bgsave指令相关配置</h4><ul>
<li><p>dbfilename dump.rdb</p>
</li>
<li><p>dir</p>
</li>
<li><p>rdbcompression yes</p>
</li>
<li><p>rdbchecksum yes</p>
</li>
<li><p>stop-writes-on-bgsave-error yes </p>
<p>​    说明：后台存储过程中如果出现错误现象，是否停止保存操作<br>​    经验：通常默认为开启状态</p>
</li>
</ul>
<p><strong>反复执行保存指令，忘记了怎么办？不知道数据产生了多少变化，何时保存？</strong></p>
<p>自动执行</p>
<ul>
<li><p>谁：redis服务器发起指令（基于条件）</p>
</li>
<li><p>什么时间：满足条件</p>
</li>
<li><p>干什么事情：保存数据</p>
</li>
</ul>
<h4 id="RDB启动方式-——save配置"><a href="#RDB启动方式-——save配置" class="headerlink" title="RDB启动方式 ——save配置"></a>RDB启动方式 ——save配置</h4><ul>
<li><p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save second changes</span><br></pre></td></tr></table></figure></li>
<li><p>作用 </p>
<ul>
<li>满足限定时间范围内key的变化数量达到指定数量即进行持久化</li>
</ul>
</li>
<li><p>参数 </p>
<ul>
<li>second：监控时间范围 </li>
<li>changes：监控key的变化量</li>
</ul>
</li>
<li><p>位置 </p>
<ul>
<li>在conf文件中进行配置</li>
</ul>
</li>
<li><p>范例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 </span><br><span class="line">save 300 10 </span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="RDB启动方式-——save配置原理"><a href="#RDB启动方式-——save配置原理" class="headerlink" title="RDB启动方式 ——save配置原理"></a>RDB启动方式 ——save配置原理</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731234043375.png" alt="image-20210731234043375"></p>
<p>注意： </p>
<ul>
<li>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的 </li>
<li>save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系 </li>
<li>save配置启动后执行的是bgsave操作</li>
</ul>
<h4 id="save配置相关配置"><a href="#save配置相关配置" class="headerlink" title="save配置相关配置"></a>save配置相关配置</h4><ul>
<li><code>dbfilename dump.rdb</code></li>
<li><code>dir</code></li>
<li><code>rdbcompression yes</code></li>
<li><code>rdbchecksum yes</code></li>
</ul>
<h4 id="RDB三种启动方式对比"><a href="#RDB三种启动方式对比" class="headerlink" title="RDB三种启动方式对比"></a>RDB三种启动方式对比</h4><table>
<thead>
<tr>
<th><strong>方式</strong></th>
<th><strong>save指令</strong></th>
<th><strong>bgsave指令</strong></th>
</tr>
</thead>
<tbody><tr>
<td>读写</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>阻塞客户端指令</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>额外内存消耗</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>启动新进程</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="rdb特殊启动形式"><a href="#rdb特殊启动形式" class="headerlink" title="rdb特殊启动形式"></a>rdb特殊启动形式</h4><ul>
<li><p>全量复制 </p>
<ul>
<li>在主从复制中详细讲解</li>
</ul>
</li>
<li><p>服务器运行过程中重启</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug reload</span><br></pre></td></tr></table></figure></li>
<li><p>关闭服务器时指定保存数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown save</span><br></pre></td></tr></table></figure></li>
</ul>
<p>默认情况下执行shutdown命令时，自动执行bgsave(如果没有开启AOF持久化功能)</p>
<h4 id="RDB优点"><a href="#RDB优点" class="headerlink" title="RDB优点"></a>RDB优点</h4><ul>
<li>RDB是一个紧凑压缩的二进制文件，存储效率较高</li>
<li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景</li>
<li>RDB恢复数据的速度要比AOF快很多</li>
<li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</li>
</ul>
<h4 id="Rdb缺点"><a href="#Rdb缺点" class="headerlink" title="Rdb缺点"></a>Rdb缺点</h4><ul>
<li>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据</li>
<li>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能</li>
<li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>RDB存储的弊端</p>
<ul>
<li>存储数据量较大，效率较低 <ul>
<li>基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低</li>
</ul>
</li>
<li>大数据量下的IO性能较低</li>
<li>基于fork创建子进程，内存产生额外消耗</li>
<li>宕机带来的数据丢失风险</li>
</ul>
<p>解决思路</p>
<ul>
<li>不写全数据，仅记录部分数据</li>
<li>降低区分数据是否改变的难度，改记录数据为记录操作过程</li>
<li>对所有操作均进行记录，排除丢失数据的风险</li>
</ul>
<h4 id="AOF概念"><a href="#AOF概念" class="headerlink" title="AOF概念"></a>AOF概念</h4><ul>
<li>AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程</li>
<li>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</li>
</ul>
<h4 id="AOF写数据过程"><a href="#AOF写数据过程" class="headerlink" title="AOF写数据过程"></a>AOF写数据过程</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731234655307.png" alt="image-20210731234655307"></p>
<h4 id="AOF写数据三种策略-appendfsync"><a href="#AOF写数据三种策略-appendfsync" class="headerlink" title="AOF写数据三种策略(appendfsync)"></a>AOF写数据三种策略(appendfsync)</h4><ul>
<li>always(每次） <ul>
<li>每次写入操作均同步到AOF文件中，数据零误差，性能较低，不建议使用。</li>
</ul>
</li>
<li>everysec（每秒） <ul>
<li>每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，性能较高 ，建议使用，也是默认配置</li>
<li>在系统突然宕机的情况下丢失1秒内的数据</li>
</ul>
</li>
<li>no（系统控制） <ul>
<li>由操作系统控制每次同步到AOF文件的周期，整体过程不可控</li>
</ul>
</li>
</ul>
<h4 id="AOF功能开启"><a href="#AOF功能开启" class="headerlink" title="AOF功能开启"></a>AOF功能开启</h4><ul>
<li><p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes|no</span><br></pre></td></tr></table></figure></li>
<li><p>作用 </p>
<ul>
<li>是否开启AOF持久化功能，默认为不开启状态</li>
</ul>
</li>
<li><p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always|everysec|no</span><br></pre></td></tr></table></figure></li>
<li><p>作用 </p>
<ul>
<li>AOF写数据策略</li>
</ul>
</li>
</ul>
<h4 id="AOF相关配置"><a href="#AOF相关配置" class="headerlink" title="AOF相关配置"></a>AOF相关配置</h4><ul>
<li><p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfilename filename</span><br></pre></td></tr></table></figure></li>
<li><p>作用 </p>
<ul>
<li>AOF持久化文件名，默认文件名未appendonly.aof，建议配置为appendonly-端口号.aof</li>
</ul>
</li>
<li><p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure></li>
<li><p>作用</p>
<ul>
<li> AOF持久化文件保存路径，与RDB持久化文件保持一致即可</li>
</ul>
</li>
</ul>
<h4 id="AOF写数据遇到的问题"><a href="#AOF写数据遇到的问题" class="headerlink" title="AOF写数据遇到的问题"></a>AOF写数据遇到的问题</h4><p><strong>如果连续执行如下指令该如何处理</strong></p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731235011802.png" alt="image-20210731235011802"></p>
<h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令进行记录。</p>
<h4 id="AOF重写作用"><a href="#AOF重写作用" class="headerlink" title="AOF重写作用"></a>AOF重写作用</h4><ul>
<li>降低磁盘占用量，提高磁盘利用率</li>
<li>提高持久化效率，降低持久化写时间，提高IO性能</li>
<li>降低数据恢复用时，提高数据恢复效率</li>
</ul>
<h4 id="AOF重写规则"><a href="#AOF重写规则" class="headerlink" title="AOF重写规则"></a>AOF重写规则</h4><ul>
<li>进程内已超时的数据不再写入文件</li>
<li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令 <ul>
<li>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等</li>
</ul>
</li>
<li>对同一数据的多条写命令合并为一条命令 <ul>
<li>如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c。 </li>
<li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</li>
</ul>
</li>
</ul>
<h4 id="AOF重写方式"><a href="#AOF重写方式" class="headerlink" title="AOF重写方式"></a>AOF重写方式</h4><ul>
<li><p>手动重写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgrewriteaof</span><br></pre></td></tr></table></figure></li>
<li><p>自动重写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size size</span><br><span class="line">auto-aof-rewrite-percentage percentage</span><br></pre></td></tr></table></figure></li>
</ul>
<p>RDB启动方式 —— bgsave指令工作原理</p>
<p>AOF手动重写 —— bgrewriteaof指令工作原理</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731235246708.png" alt="image-20210731235246708"></p>
<h4 id="AOF自动重写方式"><a href="#AOF自动重写方式" class="headerlink" title="AOF自动重写方式"></a>AOF自动重写方式</h4><ul>
<li><p>自动重写触发条件设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size size </span><br><span class="line">auto-aof-rewrite-percentage percent</span><br></pre></td></tr></table></figure></li>
<li><p>自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aof_current_size </span><br><span class="line">aof_base_size</span><br></pre></td></tr></table></figure></li>
<li><p>自动重写触发条件</p>
<ul>
<li><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731235412031.png" alt="image-20210731235412031"></li>
</ul>
</li>
</ul>
<h4 id="AOF工作流程"><a href="#AOF工作流程" class="headerlink" title="AOF工作流程"></a>AOF工作流程</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731235435090.png" alt="image-20210731235435090"></p>
<h4 id="AOF重写流程"><a href="#AOF重写流程" class="headerlink" title="AOF重写流程"></a>AOF重写流程</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731235524842.png" alt="image-20210731235524842"></p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210731235634342.png" alt="image-20210731235634342"></p>
<p>AOF缓冲区同步文件策略，由参数appendfsync控制 </p>
<p>系统调用write和fsync说明：</p>
<ul>
<li>write操作会触发延迟写（delayed write）机制，Linux在内核提供页缓冲区用来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步硬盘操作依赖于系统调度机制，列如：缓冲区页空间写满或达到特定时间周期。同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。</li>
<li>fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞知道写入硬盘完成后返回，保证了数据持久化。 </li>
<li>除了write、fsync、Linx还提供了sync、fdatasync操作，具体API说明参见：</li>
</ul>
<h3 id="RDB与AOF区别"><a href="#RDB与AOF区别" class="headerlink" title="RDB与AOF区别"></a>RDB与AOF区别</h3><h4 id="RDB-VS-AOF"><a href="#RDB-VS-AOF" class="headerlink" title="RDB VS AOF"></a>RDB VS AOF</h4><table>
<thead>
<tr>
<th><strong>持久化方式</strong></th>
<th><strong>RDB</strong></th>
<th><strong>AOF</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>占用存储空间</strong></td>
<td>小（数据级：压缩）</td>
<td>大（指令级：重写）</td>
</tr>
<tr>
<td><strong>存储速度</strong></td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td><strong>恢复速度</strong></td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td><strong>数据安全性</strong></td>
<td>会丢失数据</td>
<td>依据策略决定</td>
</tr>
<tr>
<td><strong>资源消耗</strong></td>
<td>高/重量级</td>
<td>低/轻量级</td>
</tr>
<tr>
<td><strong>启动优先级</strong></td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h4 id="RDB与AOF的选择之惑"><a href="#RDB与AOF的选择之惑" class="headerlink" title="RDB与AOF的选择之惑"></a>RDB与AOF的选择之惑</h4><ul>
<li>对数据非常敏感，建议使用默认的AOF持久化方案<ul>
<li>AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。</li>
<li>注意：由于AOF文件存储体积较大，且恢复速度较慢</li>
</ul>
</li>
<li>数据呈现阶段有效性，建议使用RDB持久化方案<ul>
<li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段点数据恢复通常采用RDB方案</li>
<li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结：</li>
</ul>
</li>
<li>综合比对<ul>
<li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li>
<li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF</li>
<li>如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB</li>
<li>灾难恢复选用RDB</li>
<li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量</li>
</ul>
</li>
</ul>
<h3 id="持久化应用场景"><a href="#持久化应用场景" class="headerlink" title="持久化应用场景"></a>持久化应用场景</h3><ul>
<li>Tips 1：<del>redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性</del></li>
<li>Tips 3：<del>redis应用于各种结构型和非结构型高热度数据访问加速</del></li>
<li>Tips 4：<del>redis 应用于购物车数据存储设计</del></li>
<li>Tips 5：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计</li>
<li>Tips 6：redis 应用于具有操作先后顺序的数据控制</li>
<li>Tips 7：redis 应用于最新消息展示</li>
<li>Tips 9：<del>redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</del></li>
<li>Tips 12：redis 应用于基于黑名单与白名单设定的服务控制</li>
<li>Tips 13：redis 应用于计数器组合排序功能对应的排名</li>
<li>Tips 15：<del>redis 应用于即时任务/消息队列执行管理</del></li>
<li>Tips 16：<del>redis 应用于按次结算的服务控制</del></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/06_redis%E6%8C%81%E4%B9%85%E5%8C%96/" data-id="ckrxceg6200068cuy98owasr0" data-title="06_redis持久化" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/05_linux环境安装redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/05_linux%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85redis/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T10:04:49.000Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/05_linux%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85redis/">05_linux环境安装redis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h2><h3 id="基于Linux环境安装Redis"><a href="#基于Linux环境安装Redis" class="headerlink" title="基于Linux环境安装Redis"></a>基于Linux环境安装Redis</h3><h4 id="基于Center-OS7安装Redis"><a href="#基于Center-OS7安装Redis" class="headerlink" title="基于Center OS7安装Redis"></a>基于Center OS7安装Redis</h4><ul>
<li><p>下载安装包 </p>
<p>​    wget <a target="_blank" rel="noopener" href="http://download.redis.io/releases/redis-?.?.?.tar.gz">http://download.redis.io/releases/redis-?.?.?.tar.gz</a></p>
</li>
<li><p>解压 </p>
<p>​    tar –xvf 文件名.tar.gz</p>
</li>
<li><p>编译 </p>
<p>​    make</p>
</li>
<li><p>安装 (直接进入解压目录下运行 make install就行)</p>
<p>​    make install [destdir=/目录]</p>
</li>
</ul>
<h4 id="Redis基础环境设置"><a href="#Redis基础环境设置" class="headerlink" title="Redis基础环境设置"></a>Redis基础环境设置</h4><ul>
<li><p>创建软链接 </p>
<p>​    ln -s 原始目录名 快速访问目录名</p>
</li>
<li><p>创建配置文件管理目录 </p>
<p>​    mkdir conf </p>
<p>​    mkdir config</p>
</li>
<li><p>创建数据文件管理目录 </p>
<p>​    mkdir data</p>
</li>
</ul>
<h4 id="Redis服务启动"><a href="#Redis服务启动" class="headerlink" title="Redis服务启动"></a>Redis服务启动</h4><ul>
<li><p>默认配置启动 </p>
<p>​    redis-server </p>
<p>​    redis-server –-port 6379 </p>
<p>​    redis-server –-port 6380 ……</p>
</li>
<li><p>指定配置文件启动 </p>
<p>​    redis-server redis.conf </p>
<p>​    redis-server redis-6379.conf </p>
<p>​    redis-server redis-6380.conf …… </p>
<p>​    redis-server conf/redis-6379.conf </p>
<p>​    redis-server config/redis-6380.conf ……</p>
</li>
</ul>
<h4 id="Redis客户端连接"><a href="#Redis客户端连接" class="headerlink" title="Redis客户端连接"></a>Redis客户端连接</h4><ul>
<li><p>默认连接 </p>
<p>​    redis-cli</p>
</li>
<li><p>连接指定服务器 </p>
<p>​    redis-cli -h 127.0.0.1</p>
<p>​    redis-cli –port 6379 </p>
<p>​    redis-cli -p 6379</p>
<p>​    redis-cli -h 127.0.0.1 –port 6379</p>
</li>
</ul>
<h4 id="Redis服务端配置"><a href="#Redis服务端配置" class="headerlink" title="Redis服务端配置"></a>Redis服务端配置</h4><ul>
<li>基本配置 <ul>
<li><code>daemonize yes </code></li>
<li>以守护进程方式启动，使用本启动方式，redis将以服务的形式存在，日志将不再打印到命令窗口中 </li>
<li><code>port 6*** </code></li>
<li>设定当前服务启动端口号 </li>
<li><code>dir “/自定义目录/redis/data“ </code></li>
<li>设定当前服务文件保存位置，包含日志文件、持久化文件（后面详细讲解）等 </li>
<li><code>logfile &quot;6***.log“ </code></li>
<li>设定日志文件名，便于查阅</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/05_linux%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85redis/" data-id="ckrxceg6000058cuyhdxe8juw" data-title="05_linux环境安装redis" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/04_jedis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/04_jedis/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T10:04:30.000Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/04_jedis/">04_jedis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Jedis简介"><a href="#Jedis简介" class="headerlink" title="Jedis简介"></a>Jedis简介</h3><h4 id="编程语言与redis"><a href="#编程语言与redis" class="headerlink" title="编程语言与redis"></a>编程语言与redis</h4><ul>
<li><p>Java语言连接redis服务 </p>
<p>​    Jedis </p>
<p>​    SpringData Redis </p>
<p>​    Lettuce</p>
</li>
<li><p>C 、C++ 、C# 、Erlang、Lua 、Objective-C 、Perl 、PHP 、Python 、Ruby 、Scala</p>
</li>
<li><p>可视化连接redis客户端 </p>
<p>​    Redis Desktop Manager </p>
<p>​    Redis Client </p>
<p>​    Redis Studio</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/04_jedis/image-20210731140725093.png" alt="image-20210731140725093"></p>
</li>
</ul>
<h3 id="HelloWorld（Jedis版）"><a href="#HelloWorld（Jedis版）" class="headerlink" title="HelloWorld（Jedis版）"></a>HelloWorld（Jedis版）</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li><p>jar包导入 </p>
<p>​    下载地址：<a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/redis.clients/jedis">https://mvnrepository.com/artifact/redis.clients/jedis</a></p>
</li>
<li><p>基于maven</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="客户端连接redis"><a href="#客户端连接redis" class="headerlink" title="客户端连接redis"></a>客户端连接redis</h4><ul>
<li><p>连接redis</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>操作redis</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">jedis.lpush(<span class="string">&quot;list1&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">List&lt;String&gt; list1 = jedis.lrange(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;-1&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>关闭redis连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis.close();</span><br></pre></td></tr></table></figure></li>
<li><p>API文档 </p>
<p>​    <a target="_blank" rel="noopener" href="http://xetorthio.github.io/jedis/">http://xetorthio.github.io/jedis/</a></p>
</li>
</ul>
<h3 id="Jedis读写redis数据"><a href="#Jedis读写redis数据" class="headerlink" title="Jedis读写redis数据"></a>Jedis读写redis数据</h3><p><strong>案例：服务调用次数控制</strong></p>
<p>人工智能领域的语义识别与自动对话将是未来服务业机器人应答呼叫体系中的重要技术，百度自研用户评价语义识别服务，免费开放给企业试用，同时训练百度自己的模型。现对试用用户的使用行为进行限速，限制每个用户每分钟最多发起10次调用</p>
<ul>
<li>案例要求<ul>
<li>设定A、B、C三个用户</li>
<li>A用户限制10次/分调用，B用户限制30次/分调用，C用户不限制</li>
</ul>
</li>
</ul>
<p><strong>案例：需求分析</strong></p>
<ol>
<li>设定一个服务方法，用于模拟实际业务调用的服务，内部采用打印模拟调用</li>
<li>在业务调用前服务调用控制单元，内部使用redis进行控制，参照之前的方案</li>
<li>对调用超限使用异常进行控制，异常处理设定为打印提示信息</li>
<li>主程序启动3个线程，分别表示3种不同用户的调用</li>
</ol>
<p><strong>案例：实现步骤</strong></p>
<ol>
<li><p>设定业务方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">business</span><span class="params">(String id,<span class="keyword">long</span> num)</span></span>&#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;用户&quot;</span>+id+<span class="string">&quot;发起业务调用，当前第&quot;</span>+num+<span class="string">&quot;次&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设定多线类，模拟用户调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123; </span><br><span class="line">        jd.service(id); </span><br><span class="line">        <span class="comment">//模拟调用间隔，设定为1.x秒 </span></span><br><span class="line">        <span class="keyword">try</span>&#123; </span><br><span class="line">            Random r = <span class="keyword">new</span> Random(); </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>+ r.nextInt(<span class="number">200</span>)); </span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123; </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设计redis控制方案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(String id)</span></span>&#123; </span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>); </span><br><span class="line">    String value = jedis.get(<span class="string">&quot;compid:&quot;</span> + id); </span><br><span class="line">    <span class="comment">//判定是否具有调用计数控制，利用异常进行控制处理 </span></span><br><span class="line">    <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">//没有控制，创建控制计数器 </span></span><br><span class="line">        jedis.setex(<span class="string">&quot;compid:&quot;</span> + id, <span class="number">20</span>, <span class="string">&quot;&quot;</span>+(Long.MAX_VALUE-<span class="number">10</span>)); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">        <span class="comment">//有控制，自增，并调用业务 </span></span><br><span class="line">        <span class="keyword">try</span>&#123; </span><br><span class="line">            Long val = jedis.incr(<span class="string">&quot;compid:&quot;</span>+id); </span><br><span class="line">            business(id,<span class="number">10</span>+val-Long.MAX_VALUE); </span><br><span class="line">        &#125;<span class="keyword">catch</span> (JedisDataException e)&#123; </span><br><span class="line">            <span class="comment">//调用次数溢出，弹出提示 </span></span><br><span class="line">            System.out.println(<span class="string">&quot;用户：&quot;</span>+id+<span class="string">&quot;使用次数已达到上限，请稍后再试，或升级VIP会员&quot;</span>); </span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123; </span><br><span class="line">            jedis.close(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设计启动主程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">&quot;初级用户&quot;</span>); </span><br><span class="line">    t1.start(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续1：对业务控制方案进行改造，设定不同用户等级的判定 </p>
<p>后续2：将不同用户等级对应的信息、限制次数等设定到redis中，使用hash保存</p>
</li>
</ol>
<h3 id="Jedis简易工具类开发"><a href="#Jedis简易工具类开发" class="headerlink" title="Jedis简易工具类开发"></a>Jedis简易工具类开发</h3><h4 id="基于连接池获取连接"><a href="#基于连接池获取连接" class="headerlink" title="基于连接池获取连接"></a>基于连接池获取连接</h4><ul>
<li><p>JedisPool：Jedis提供的连接池技术 </p>
<p>​    poolConfig:连接池配置对象 </p>
<p>​    host:redis服务地址 </p>
<p>​    port:redis服务端口号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JedisPool</span><span class="params">(GenericObjectPoolConfig poolConfig, String host, <span class="keyword">int</span> port)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>(poolConfig, host, port, <span class="number">2000</span>, (String)<span class="keyword">null</span>, <span class="number">0</span>, (String)<span class="keyword">null</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="封装连接参数"><a href="#封装连接参数" class="headerlink" title="封装连接参数"></a>封装连接参数</h4><ul>
<li><p>jedis.properties</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jedis.host</span>=<span class="string">localhost </span></span><br><span class="line"><span class="meta">jedis.port</span>=<span class="string">6379 </span></span><br><span class="line"><span class="meta">jedis.maxTotal</span>=<span class="string">30 </span></span><br><span class="line"><span class="meta">jedis.maxIdle</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="加载配置信息"><a href="#加载配置信息" class="headerlink" title="加载配置信息"></a>加载配置信息</h4><ul>
<li><p>静态代码块初始化资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123; </span><br><span class="line">    <span class="comment">//读取配置文件 获得参数值 </span></span><br><span class="line">    ResourceBundle rb = ResourceBundle.getBundle(<span class="string">&quot;jedis&quot;</span>); </span><br><span class="line">    host = rb.getString(<span class="string">&quot;jedis.host&quot;</span>); </span><br><span class="line">    port = Integer.parseInt(rb.getString(<span class="string">&quot;jedis.port&quot;</span>)); </span><br><span class="line">    maxTotal = Integer.parseInt(rb.getString(<span class="string">&quot;jedis.maxTotal&quot;</span>)); </span><br><span class="line">    maxIdle = Integer.parseInt(rb.getString(<span class="string">&quot;jedis.maxIdle&quot;</span>)); </span><br><span class="line">    poolConfig = <span class="keyword">new</span> JedisPoolConfig(); </span><br><span class="line">    poolConfig.setMaxTotal(maxTotal); </span><br><span class="line">    poolConfig.setMaxIdle(maxIdle); </span><br><span class="line">    jedisPool = <span class="keyword">new</span> JedisPool(poolConfig,host,port); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="获取连接"><a href="#获取连接" class="headerlink" title="获取连接"></a>获取连接</h4><ul>
<li><p>对外访问接口，提供jedis连接对象，连接从连接池获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123; </span><br><span class="line">    Jedis jedis = jedisPool.getResource(); </span><br><span class="line">    <span class="keyword">return</span> jedis; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="可视化客户端"><a href="#可视化客户端" class="headerlink" title="可视化客户端"></a>可视化客户端</h3><h4 id="Redis-Desktop-Manager"><a href="#Redis-Desktop-Manager" class="headerlink" title="Redis Desktop Manager"></a>Redis Desktop Manager</h4><p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/04_jedis/image-20210731142546176.png" alt="image-20210731142546176"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/04_jedis/" data-id="ckrxceg5x00038cuy2pv871q6" data-title="04_jedis" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/03_redis通用指令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/03_redis%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T10:04:06.000Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/03_redis%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4/">03_redis通用指令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Redis-通用指令"><a href="#Redis-通用指令" class="headerlink" title="Redis 通用指令"></a>Redis 通用指令</h2><h3 id="key通用指令"><a href="#key通用指令" class="headerlink" title="key通用指令"></a>key通用指令</h3><h4 id="key-特征"><a href="#key-特征" class="headerlink" title="key 特征"></a>key 特征</h4><ul>
<li>key是一个字符串，通过key获取redis中保存的数据</li>
</ul>
<p><strong>key应该设计哪些操作？</strong></p>
<ul>
<li>对于key自身状态的相关操作，例如：删除，判定存在，获取类型等</li>
<li>对于key有效性控制相关操作，例如：有效期设定，判定是否有效，有效状态的切换等</li>
<li>对于key快速查询操作，例如：按指定策略查询key</li>
<li>……</li>
</ul>
<h4 id="key-基本操作"><a href="#key-基本操作" class="headerlink" title="key 基本操作"></a>key 基本操作</h4><ul>
<li><p>删除指定key</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure></li>
<li><p>获取key是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure></li>
<li><p>获取key的类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="key-扩展操作（时效性控制）"><a href="#key-扩展操作（时效性控制）" class="headerlink" title="key 扩展操作（时效性控制）"></a>key 扩展操作（时效性控制）</h4><ul>
<li><p>为指定key设置有效期</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expire key seconds</span><br><span class="line">pexpire key milliseconds</span><br><span class="line">expireat key timestamp		#设置时间戳，linux下通常使用时间戳来控制</span><br><span class="line">pexpireat key milliseconds-timestamp</span><br></pre></td></tr></table></figure></li>
<li><p>获取key的有效时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ttl key 	#key不存在返回-2 key存在返回-1 ，key设置了有效期，返回有效时常</span><br><span class="line">pttl key</span><br></pre></td></tr></table></figure></li>
<li><p>切换key从时效性转换为永久性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persist key</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="key-扩展操作（查询模式）"><a href="#key-扩展操作（查询模式）" class="headerlink" title="key 扩展操作（查询模式）"></a>key 扩展操作（查询模式）</h4><ul>
<li><p>查询key</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys pattern</span><br></pre></td></tr></table></figure></li>
<li><p>查询模式规则</p>
<p>* 匹配任意数量的任意符号         ?  配合一个任意符号         [] 匹配一个指定符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">keys * 查询所有 </span><br><span class="line">keys it* 查询所有以it开头 </span><br><span class="line">keys *heima 查询所有以heima结尾 </span><br><span class="line">keys ??heima 查询所有前面两个字符任意，后面以heima结尾 </span><br><span class="line">keys user:? 查询所有以user:开头，最后一个字符任意 </span><br><span class="line">keys u[st]er:1 查询所有以u开头，以er:1结尾，中间包含一个字母，s或t</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="key-其他操作"><a href="#key-其他操作" class="headerlink" title="key 其他操作"></a>key 其他操作</h4><ul>
<li><p>为key改名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rename key newkey #会覆盖newkey</span><br><span class="line">renamenx key newkey		#newkey已拥有会失败</span><br></pre></td></tr></table></figure></li>
<li><p>对所有key排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort	#用来对列表，集合排序，但并不改变列表集合的顺序</span><br></pre></td></tr></table></figure></li>
<li><p>其他key通用操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help @generic</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="数据库通用指令"><a href="#数据库通用指令" class="headerlink" title="数据库通用指令"></a>数据库通用指令</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>key 的重复问题</p>
<ul>
<li>key是由程序员定义的</li>
<li>redis在使用过程中，伴随着操作数据量的增加，会出现大量的数据以及对应的key</li>
<li>数据不区分种类、类别混杂在一起，极易出现重复或冲突</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li>redis为每个服务提供有16个数据库，编号从0到15</li>
<li>每个数据库之间的数据相互独立</li>
</ul>
<h4 id="db-基本操作"><a href="#db-基本操作" class="headerlink" title="db 基本操作"></a>db 基本操作</h4><ul>
<li><p>切换数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select index</span><br></pre></td></tr></table></figure></li>
<li><p>其他操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br><span class="line">ping	#测试链接是否联通</span><br><span class="line">echo message	#原样输出，可以输出日志</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="db-相关操作"><a href="#db-相关操作" class="headerlink" title="db 相关操作"></a>db 相关操作</h4><ul>
<li><p>数据移动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move key db</span><br></pre></td></tr></table></figure></li>
<li><p>数据清除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbsize		#查看库里有多少key</span><br><span class="line">flushdb		#刷掉现在的数据</span><br><span class="line">flushall	#刷掉所有数据</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/03_redis%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4/" data-id="ckrxceg5s00018cuy2fp1d4tw" data-title="03_redis通用指令" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑马程序员/redis/02_redis数据类型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T10:03:42.000Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">02_redis数据类型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="02-redis-数据类型"><a href="#02-redis-数据类型" class="headerlink" title="02_redis 数据类型"></a>02_redis 数据类型</h2><h3 id="数据存储类型介绍"><a href="#数据存储类型介绍" class="headerlink" title="数据存储类型介绍"></a>数据存储类型介绍</h3><h4 id="业务数据的特殊性"><a href="#业务数据的特殊性" class="headerlink" title="业务数据的特殊性"></a>业务数据的特殊性</h4><p><strong>作为缓存使用</strong></p>
<ol>
<li><p>原始业务功能设计</p>
<ul>
<li>秒杀</li>
<li>618活动</li>
<li>双11活动</li>
<li>排队购票</li>
</ul>
</li>
<li><p>运营平台监控到的突发高频访问数据</p>
<ul>
<li>突发时政要闻，被强势关注围观</li>
</ul>
</li>
<li><p>高频、复杂的统计数据</p>
<ul>
<li>在线人数</li>
<li>投票排行榜</li>
</ul>
</li>
</ol>
<p><strong>附加功能</strong></p>
<p>系统功能优化或升级</p>
<ul>
<li><p>单服务器升级集群</p>
</li>
<li><p>Session 管理</p>
</li>
<li><p>Token 管理</p>
</li>
</ul>
<h4 id="Redis-数据类型（5种常用）"><a href="#Redis-数据类型（5种常用）" class="headerlink" title="Redis 数据类型（5种常用）"></a>Redis 数据类型（5种常用）</h4><ul>
<li>string             String </li>
<li>hash              HashMap </li>
<li>list                  LinkedList </li>
<li>set                  HashSet </li>
<li>sorted_set     TreeSet</li>
</ul>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="redis-数据存储格式"><a href="#redis-数据存储格式" class="headerlink" title="redis 数据存储格式"></a>redis 数据存储格式</h4><ul>
<li>redis 自身是一个 Map，其中所有的数据都是采用 key : value 的形式存储</li>
<li>数据类型指的是存储的数据的类型，也就是 value 部分的类型，key 部分永远都是字符串</li>
</ul>
<img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210730232010224.png" alt="image-20210730232010224" style="zoom: 67%;">

<h4 id="string-类型"><a href="#string-类型" class="headerlink" title="string 类型"></a>string 类型</h4><ul>
<li>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</li>
<li>存储数据的格式：一个存储空间保存一个数据</li>
<li>存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用（但仍然是字符串）</li>
</ul>
<h4 id="string-类型数据的基本操作"><a href="#string-类型数据的基本操作" class="headerlink" title="string 类型数据的基本操作"></a>string 类型数据的基本操作</h4><ul>
<li><p>添加/修改数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br></pre></td></tr></table></figure></li>
<li><p>获取数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure></li>
<li><p>删除数据（返回 <code>(integer) 1</code> 代表成功， <code>(integer) 0</code> 代表失败）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure></li>
<li><p>添加/修改多个数据(m 指的是 Multiple[ˈmʌltɪpl])</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key1 value1 key2 value2 …</span><br></pre></td></tr></table></figure></li>
<li><p>获取多个数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key1 key2 …</span><br></pre></td></tr></table></figure></li>
<li><p>获取数据字符个数（字符串长度）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure></li>
<li><p>追加信息到原始信息后部（如果原始信息存在就追加，否则新建）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="string-类型数据的基础操作"><a href="#string-类型数据的基础操作" class="headerlink" title="string 类型数据的基础操作"></a>string 类型数据的基础操作</h4><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210730232628964.png" alt="image-20210730232628964" style="zoom: 67%;">

<h4 id="string-类型数据的扩展操作"><a href="#string-类型数据的扩展操作" class="headerlink" title="string 类型数据的扩展操作"></a>string 类型数据的扩展操作</h4><p><strong>业务场景</strong></p>
<p>大型企业级应用中，分表操作是基本操作，使用多张表存储同类型数据，但是对应的主键 id 必须保证统一性，不能重复。Oracle 数据库具有 sequence 设定，可以解决该问题，但是 MySQL数据库并不具有类似的机制，那么如何解决？</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210730232728589.png" alt="image-20210730232728589"></p>
<p><strong>解决方案</strong></p>
<ul>
<li><p>设置数值数据增加指定范围的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incr key </span><br><span class="line">incrby key increment </span><br><span class="line">incrbyfloat key increment</span><br></pre></td></tr></table></figure></li>
<li><p>设置数值数据减少指定范围的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decr key </span><br><span class="line">decrby key increment</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>string 作为数值操作</strong></p>
<ul>
<li>string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算。</li>
<li>redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</li>
<li>注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</li>
</ul>
<p>Tips 1：</p>
<ul>
<li>redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性</li>
<li>此方案适用于所有数据库，且支持数据库集群</li>
</ul>
<p><strong>业务场景</strong><br>“最强女生”启动海选投票，只能通过微信投票，每个微信号每 4 小时只能投1票。</p>
<p>电商商家开启热门商品推荐，热门商品不能一直处于热门期，每种商品热门期维持3天，3天后自动取消热门。</p>
<p>新闻网站会出现热点新闻，热点新闻最大的特征是时效性，如何自动控制热点新闻的时效性。</p>
<p>news_id:HB314790725    00：30</p>
<p><strong>解决方案</strong></p>
<ul>
<li><p>设置数据具有指定的生命周期</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setex key seconds value </span><br><span class="line">setex tel 10 1</span><br><span class="line"># 如果期间在设置一个tel的值 如 setex tel 2 上面的设定会失效</span><br><span class="line"></span><br><span class="line">psetex key milliseconds value</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Tips 2：</p>
<ul>
<li>redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作</li>
</ul>
<h4 id="string-类型数据操作的注意事项"><a href="#string-类型数据操作的注意事项" class="headerlink" title="string 类型数据操作的注意事项"></a>string 类型数据操作的注意事项</h4><ul>
<li><p>数据操作不成功的反馈与数据正常操作之间的差异（通过使用的指令区分）</p>
<ol>
<li><p>表示运行结果是否成功</p>
<ul>
<li>(integer) 0 → false 失败</li>
<li>(integer) 1 → true 成功 </li>
</ul>
</li>
<li><p>表示运行结果值     </p>
<ul>
<li>(integer) 3 → 3 3个</li>
<li>(integer) 1 → 1 1个</li>
</ul>
</li>
</ol>
</li>
<li><p>数据未获取到 </p>
<ul>
<li>（nil）等同于null</li>
</ul>
</li>
<li><p>数据最大存储量 </p>
<ul>
<li>512MB</li>
</ul>
</li>
<li><p>数值计算最大范围（java中的long的最大值） </p>
<ul>
<li>9223372036854775807</li>
</ul>
</li>
</ul>
<h4 id="string-类型应用场景"><a href="#string-类型应用场景" class="headerlink" title="string 类型应用场景"></a>string 类型应用场景</h4><p><strong>业务场景</strong></p>
<p>主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量</p>
<p><strong>解决方案</strong></p>
<ul>
<li>在redis中为大V用户设定用户信息，以表名，用户主键和属性值作为key，后台设定定时刷新策略即可 <ul>
<li>eg: <code>user:id:3506728370:fans → 12210947</code></li>
<li>eg:<code>user:id:3506728370:blogs → 6164</code></li>
<li>eg: <code>user:id:3506728370:focuss → 83</code></li>
</ul>
</li>
<li>在redis中以json格式存储大V用户信息，定时刷新（也可以使用hash类型） <ul>
<li>eg: <code>user:id:3506728370 → &#123;&quot;id&quot;:3506728370,&quot;name&quot;:&quot;春晚&quot;,&quot;fans&quot;:12210862,&quot;blogs&quot;:6164,&quot;focus&quot;:83&#125;</code></li>
</ul>
</li>
</ul>
<p>Tips 3：</p>
<ul>
<li>redis应用于各种结构型和非结构型高热度数据访问加速</li>
</ul>
<h4 id="key-的设置约定"><a href="#key-的设置约定" class="headerlink" title="key 的设置约定"></a>key 的设置约定</h4><ul>
<li><p>数据库中的热点数据key命名惯例 </p>
<table>
<thead>
<tr>
<th></th>
<th>表名:</th>
<th>主键名:</th>
<th>主键值:</th>
<th>字段名</th>
</tr>
</thead>
<tbody><tr>
<td>eg1：</td>
<td>order:</td>
<td>id:</td>
<td>29437595:</td>
<td>name</td>
</tr>
<tr>
<td>eg2：</td>
<td>equip:</td>
<td>id:</td>
<td>390472345:</td>
<td>type</td>
</tr>
<tr>
<td>eg3：</td>
<td>news:</td>
<td>id:</td>
<td>202004150:</td>
<td>title</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><h4 id="hash-类型"><a href="#hash-类型" class="headerlink" title="hash 类型"></a>hash 类型</h4><p><strong>存储的困惑</strong></p>
<p>对象类数据的存储如果具有较频繁的更新需求操作会显得笨重</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210730234203003.png" alt="image-20210730234203003"></p>
<ul>
<li><p>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</p>
</li>
<li><p>需要的存储结构：一个存储空间保存多个键值对数据</p>
</li>
<li><p>hash类型：底层使用哈希表结构实现数据存储</p>
</li>
</ul>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210730234302978.png" alt="image-20210730234302978"></p>
<h4 id="hash-类型数据的基本操作"><a href="#hash-类型数据的基本操作" class="headerlink" title="hash 类型数据的基本操作"></a>hash 类型数据的基本操作</h4><ul>
<li><p>添加/修改数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br></pre></td></tr></table></figure></li>
<li><p>获取数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hget key field </span><br><span class="line">hgetall key  #会把file value都显示出来</span><br></pre></td></tr></table></figure></li>
<li><p>删除数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel key field1 [field2]</span><br></pre></td></tr></table></figure></li>
<li><p>添加/修改多个数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset key field1 value1 field2 value2 …</span><br></pre></td></tr></table></figure></li>
<li><p>获取多个数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmget key field1 field2 …</span><br></pre></td></tr></table></figure></li>
<li><p>获取哈希表中字段的数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure></li>
<li><p>获取哈希表中是否存在指定的字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="hash-类型数据扩展操作"><a href="#hash-类型数据扩展操作" class="headerlink" title="hash 类型数据扩展操作"></a>hash 类型数据扩展操作</h4><ul>
<li><p>获取哈希表中所有的字段名或字段值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hkeys key </span><br><span class="line">hvals key</span><br></pre></td></tr></table></figure></li>
<li><p>设置指定字段的数值数据增加指定范围的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hincrby key field increment 	#可以是复数</span><br><span class="line">hincrbyfloat key field increment</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="hash-类型数据操作的注意事项"><a href="#hash-类型数据操作的注意事项" class="headerlink" title="hash 类型数据操作的注意事项"></a>hash 类型数据操作的注意事项</h4><ul>
<li>hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil）</li>
<li>每个 hash 可以存储 2 ^ 23 - 1 个键值对</li>
<li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，更不可以将hash作为对象列表使用</li>
<li>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈</li>
</ul>
<h4 id="hash-类型应用场景"><a href="#hash-类型应用场景" class="headerlink" title="hash 类型应用场景"></a>hash 类型应用场景</h4><p><strong>业务场景</strong></p>
<p>电商网站购物车设计与实现</p>
<p><strong>业务分析</strong></p>
<ul>
<li><p>仅分析购物车的redis存储模型 添加、浏览、更改数量、删除、清空</p>
</li>
<li><p>购物车于数据库间持久化同步（不讨论）</p>
</li>
<li><p>购物车于订单间关系（不讨论） </p>
<p>​    提交购物车：读取数据生成订单 </p>
<p>​    商家临时价格调整：隶属于订单级别</p>
</li>
<li><p>未登录用户购物车信息存储（不讨论） cookie存储</p>
</li>
</ul>
<img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210730234831817.png" alt="image-20210730234831817" style="zoom:50%;">

<p><strong>解决方案</strong></p>
<ul>
<li><p>以客户id作为key，每位客户创建一个hash存储结构存储对应的购物车信息</p>
</li>
<li><p>将商品编号作为field，购买数量作为value进行存储</p>
</li>
<li><p>添加商品：追加全新的field与value</p>
</li>
<li><p>浏览：遍历hash</p>
</li>
<li><p>更改数量：自增/自减，设置value值</p>
</li>
<li><p>删除商品：删除field</p>
</li>
<li><p>清空：删除key</p>
</li>
<li><p>此处仅讨论购物车中的模型设计</p>
</li>
<li><p>购物车与数据库间持久化同步、购物车与订单间关系、未登录用户购物车信息存储不进行讨论</p>
</li>
</ul>
<p><strong>当前设计是否加速了购物车的呈现</strong></p>
<p>当前仅仅是将数据存储到了redis中，并没有起到加速的作用，商品信息还需要二次查询数据库</p>
<ul>
<li><p>每条购物车中的商品记录保存成两条field</p>
</li>
<li><p>field1专用于保存购买数量 </p>
<p>​    命名格式：商品id:nums </p>
<p>​    保存数据：数值</p>
</li>
<li><p>field2专用于保存购物车中显示的信息，包含文字描述，图片地址，所属商家信息等           (提升：独立hash，不同用户购买的商品信息可能相同。)</p>
<p>​    命名格式：商品id:info </p>
<p>​    保存数据：json</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hsetnx key field value</span><br><span class="line">#如果当前key中对象field有值就什么都不做，如果没有则加载。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Tips 4：</p>
<ul>
<li>redis 应用于购物车数据存储设计</li>
</ul>
<p><strong>业务场景</strong></p>
<p>双11活动日，销售手机充值卡的商家对移动、联通、电信的30元、50元、100元商品推出抢购活动，每种商品抢购上限1000张</p>
<img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210730235312731.png" alt="image-20210730235312731" style="zoom:50%;">



<p><strong>解决方案</strong></p>
<ul>
<li><p>以商家id作为key</p>
</li>
<li><p>将参与抢购的商品id作为field</p>
</li>
<li><p>将参与抢购的商品数量作为对应的value</p>
</li>
<li><p>抢购时使用降值的方式控制产品数量</p>
</li>
<li><p>实际业务中还有超卖等实际问题，这里不做讨论</p>
</li>
</ul>
<p>Tips 5：</p>
<ul>
<li>redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计</li>
</ul>
<p><strong>业务场景</strong></p>
<p>string存储对象（json）与hash存储对象区别：string讲究整体性，读操作为主，hash操作更新更灵活一些。</p>
<blockquote>
<p>原则上：redis只做数据提供和保存，尽量不要使用业务压到redis上， 如判断是否存在。</p>
</blockquote>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h4 id="list-类型"><a href="#list-类型" class="headerlink" title="list 类型"></a>list 类型</h4><ul>
<li>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</li>
<li>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</li>
<li>list类型：保存多个数据，底层使用双向链表存储结构实现</li>
</ul>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210731100032895.png" alt="image-20210731100032895"></p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210731100054514.png" alt="image-20210731100054514"></p>
<h4 id="list-类型数据基本操作"><a href="#list-类型数据基本操作" class="headerlink" title="list 类型数据基本操作"></a>list 类型数据基本操作</h4><ul>
<li><p>添加/修改数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpush key value1 [value2] ……</span><br><span class="line">rpush key value1 [value2] ……</span><br></pre></td></tr></table></figure></li>
<li><p>获取数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lrange key start stop	#start stop为索引 </span><br><span class="line"># 倒数第一个为-1 如 lrange 0 -1</span><br><span class="line">lindex key index</span><br><span class="line">llen key</span><br></pre></td></tr></table></figure></li>
<li><p>获取并移除数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpop key</span><br><span class="line">rpop key</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="list-类型数据扩展操作"><a href="#list-类型数据扩展操作" class="headerlink" title="list 类型数据扩展操作"></a>list 类型数据扩展操作</h4><ul>
<li><p>规定时间内获取并移除数据（可以等待，可以从若干个列表中取）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blpop key1 [key2] timeout</span><br><span class="line">brpop key1 [key2] timeout</span><br><span class="line">brpoplpush source destination timeout</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>业务场景</strong></p>
<p>微信朋友圈点赞，要求按照点赞顺序显示点赞好友信息 如果取消点赞，移除对应好友信息</p>
<p>解决方案</p>
<ul>
<li><p>移除指定数据（count为移除的数目）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrem key count value</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Tips 6：</p>
<ul>
<li>redis 应用于具有操作先后顺序的数据控制</li>
</ul>
<h4 id="list-类型数据操作注意事项"><a href="#list-类型数据操作注意事项" class="headerlink" title="list 类型数据操作注意事项"></a>list 类型数据操作注意事项</h4><ul>
<li>list中保存的数据都是string类型的，数据总容量是有限的，最多2 ^ 23 - 1 个元素 (4294967295)。</li>
<li>list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作</li>
<li>获取全部数据操作结束索引设置为-1</li>
<li>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载</li>
</ul>
<h4 id="list-类型应用场景"><a href="#list-类型应用场景" class="headerlink" title="list 类型应用场景"></a>list 类型应用场景</h4><p><strong>业务场景</strong></p>
<p>twitter、新浪微博、腾讯微博中个人用户的关注列表需要按照用户的关注顺序进行展示，粉丝列表需要将最近关注的粉丝列在前面</p>
<p>新闻、资讯类网站如何将最新的新闻或资讯按照发生的时间顺序展示？ 企业运营过程中，系统将产生出大量的运营数据，如何保障多台服务器操作日志的统一顺序输出？</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210731100521829.png" alt="image-20210731100521829"></p>
<p><strong>解决方案</strong></p>
<ul>
<li>依赖list的数据具有顺序的特征对信息进行管理</li>
<li>使用队列模型解决多路信息汇总合并的问题</li>
<li>使用栈模型解决最新消息的问题</li>
</ul>
<p>Tips 7：</p>
<ul>
<li>redis 应用于最新消息展示</li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h4 id="set-类型"><a href="#set-类型" class="headerlink" title="set 类型"></a>set 类型</h4><ul>
<li>新的存储需求：存储大量的数据，在查询方面提供更高的效率</li>
<li>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</li>
<li>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的</li>
</ul>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210731100628209.png" alt="image-20210731100628209"></p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210731100646315.png" alt="image-20210731100646315"></p>
<h4 id="set-类型数据的基本操作"><a href="#set-类型数据的基本操作" class="headerlink" title="set 类型数据的基本操作"></a>set 类型数据的基本操作</h4><ul>
<li><p>添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key member1 [member2]</span><br></pre></td></tr></table></figure></li>
<li><p>获取全部数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure></li>
<li><p>删除数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem key member1 [member2]</span><br></pre></td></tr></table></figure></li>
<li><p>获取集合数据总量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure></li>
<li><p>判断集合中是否包含指定数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sismember key member</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="set-类型数据的扩展操作"><a href="#set-类型数据的扩展操作" class="headerlink" title="set 类型数据的扩展操作"></a>set 类型数据的扩展操作</h4><p><strong>业务场景</strong></p>
<p>每位用户首次使用今日头条时会设置3项爱好的内容，但是后期为了增加用户的活跃度、兴趣点，必须让用户对其他信息类别逐渐产生兴趣，增加客户留存度，如何实现？</p>
<p><strong>业务分析</strong></p>
<ul>
<li>系统分析出各个分类的最新或最热点信息条目并组织成set集合</li>
<li>随机挑选其中部分信息</li>
<li>配合用户关注信息分类中的热点信息组织成展示的全信息集合</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li><p>随机获取集合中指定数量的数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srandmember key [count]</span><br></pre></td></tr></table></figure></li>
<li><p>随机获取集合中的某个数据并将该数据移出集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spop key [count]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Tips 8：</p>
<ul>
<li>redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等</li>
</ul>
<p><strong>业务场景</strong></p>
<p>脉脉为了促进用户间的交流，保障业务成单率的提升，需要让每位用户拥有大量的好友，事实上职场新人不具有更多的职场好友，如何快速为用户积累更多的好友？</p>
<p>新浪微博为了增加用户热度，提高用户留存性，需要微博用户在关注更多的人，以此获得更多的信息或热门话题，如何提高用户关注他人的总量？</p>
<p>QQ新用户入网年龄越来越低，这些用户的朋友圈交际圈非常小，往往集中在一所学校甚至一个班级中，如何帮助用户快速积累好友用户带来更多的活跃度？</p>
<p>微信公众号是微信信息流通的渠道之一，增加用户关注的公众号成为提高用户活跃度的一种方式，如何帮助用户积累更多关注的公众号？</p>
<p>美团外卖为了提升成单量，必须帮助用户挖掘美食需求，如何推荐给用户最适合自己的美食？</p>
<p><strong>解决方案</strong></p>
<ul>
<li><p>求两个集合的交、并、差集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinter key1 [key2] </span><br><span class="line">sunion key1 [key2] </span><br><span class="line">sdiff key1 [key2]</span><br></pre></td></tr></table></figure></li>
<li><p>求两个集合的交、并、差集并存储到指定集合中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination key1 [key2] </span><br><span class="line">sunionstore destination key1 [key2] </span><br><span class="line">sdiffstore destination key1 [key2]</span><br></pre></td></tr></table></figure></li>
<li><p>将指定数据从原始集合中移动到目标集合中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smove source destination member</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210731101714762.png" alt="image-20210731101714762"></p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210731101744393.png" alt="image-20210731101744393"></p>
</li>
</ul>
<p>Tips 9：</p>
<ul>
<li>redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</li>
<li>显示共同关注（一度）</li>
<li>显示共同好友（一度）</li>
<li>由用户A出发，获取到好友用户B的好友信息列表（一度）</li>
<li>由用户A出发，获取到好友用户B的购物清单列表（二度）</li>
<li>由用户A出发，获取到好友用户B的游戏充值列表（二度）</li>
</ul>
<h4 id="set-类型数据操作的注意事项"><a href="#set-类型数据操作的注意事项" class="headerlink" title="set 类型数据操作的注意事项"></a>set 类型数据操作的注意事项</h4><ul>
<li>set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份</li>
<li>set 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间</li>
</ul>
<h4 id="set-类型应用场景"><a href="#set-类型应用场景" class="headerlink" title="set 类型应用场景"></a>set 类型应用场景</h4><p><strong>业务场景</strong></p>
<p>集团公司共具有12000名员工，内部OA系统中具有700多个角色，3000多个业务操作，23000多种数据，每位员工具有一个或多个角色，如何快速进行业务操作的权限校验？</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210731101946658.png" alt="image-20210731101946658"></p>
<p><strong>业务场景</strong></p>
<p>公司对旗下新的网站做推广，统计网站的PV（访问量）,UV（独立访客）,IP（独立IP）。 </p>
<p>PV：网站被访问次数，可通过刷新页面提高访问量 </p>
<p>UV：网站被不同用户访问的次数，可通过cookie统计访问量，相同用户切换IP地址，UV不变 </p>
<p>IP：网站被不同IP地址访问的总次数，可通过IP地址统计访问量，相同IP不同用户访问，IP不变</p>
<p><strong>解决方案</strong></p>
<ul>
<li>利用set集合的数据去重特征，记录各种访问数据</li>
<li>建立string类型数据，利用incr统计日访问量（PV）</li>
<li>建立set模型，记录不同cookie数量（UV）</li>
<li>建立set模型，记录不同IP数量（IP）</li>
</ul>
<p>Tips 11：</p>
<ul>
<li>redis 应用于同类型数据的快速去重</li>
</ul>
<p><strong>业务场景</strong></p>
<p>黑名单 </p>
<p>​    资讯类信息类网站追求高访问量，但是由于其信息的价值，往往容易被不法分子利用，通过爬虫技术，快速获取信息，个别特种行业网站信息通过爬虫获取分析后，可以转换成商业机密进行出售。例如第三方火车票、机票、酒店刷票代购软件，电商刷评论、刷好评。 </p>
<p>​    同时爬虫带来的伪流量也会给经营者带来错觉，产生错误的决策，有效避免网站被爬虫反复爬取成为每个网站都要考虑的基本问题。在基于技术层面区分出爬虫用户后，需要将此类用户进行有效的屏蔽，这就是黑名单的典型应用。 </p>
<p>​    ps:不是说爬虫一定做摧毁性的工作，有些小型网站需要爬虫为其带来一些流量。 </p>
<p>白名单 </p>
<p>​    对于安全性更高的应用访问，仅仅靠黑名单是不能解决安全问题的，此时需要设定可访问的用户群体，依赖白名单做更为苛刻的访问验证。</p>
<p><strong>解决方案</strong></p>
<ul>
<li>基于经营战略设定问题用户发现、鉴别规则</li>
<li>周期性更新满足规则的用户黑名单，加入set集合</li>
<li>用户行为信息达到后与黑名单进行比对，确认行为去向</li>
<li>黑名单过滤IP地址：应用于开放游客访问权限的信息源</li>
<li>黑名单过滤设备信息：应用于限定访问设备的信息源</li>
<li>黑名单过滤用户：应用于基于访问权限的信息源</li>
</ul>
<p>Tips 12：</p>
<ul>
<li>redis 应用于基于黑名单与白名单设定的服务控制</li>
</ul>
<h3 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted_set"></a>sorted_set</h3><h4 id="sorted-set-类型"><a href="#sorted-set-类型" class="headerlink" title="sorted_set 类型"></a>sorted_set 类型</h4><ul>
<li><p>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</p>
</li>
<li><p>需要的存储结构：新的存储模型，可以保存可排序的数据</p>
</li>
<li><p>sorted_set类型：在set的存储结构基础上添加可排序字段</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210731102628181.png" alt="image-20210731102628181"></p>
</li>
</ul>
<h4 id="sorted-set-类型数据的基本操作"><a href="#sorted-set-类型数据的基本操作" class="headerlink" title="sorted_set 类型数据的基本操作"></a>sorted_set 类型数据的基本操作</h4><ul>
<li><p>添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zadd key score1 member1 [score2 member2]</span><br><span class="line">#注意score在前</span><br><span class="line">zadd scores 100 zs</span><br><span class="line">zadd scores 34 gf</span><br></pre></td></tr></table></figure></li>
<li><p>获取全部数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrange key start stop [WITHSCORES]</span><br><span class="line">zrevrange key start stop [WITHSCORES] #反转</span><br></pre></td></tr></table></figure></li>
<li><p>删除数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member [member ...]</span><br></pre></td></tr></table></figure></li>
<li><p>按条件获取数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore key min max [WITHSCORES] [LIMIT]</span><br><span class="line">zrangebyscore scores 50 99 withscores linmit 0 3 #查询结果的0 1 2数据</span><br><span class="line"></span><br><span class="line">zrevrangebyscore key max min [WITHSCORES]</span><br></pre></td></tr></table></figure></li>
<li><p>条件删除数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank key start stop </span><br><span class="line">zremrangebyscore key min max</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li>min与max用于限定搜索查询的条件</li>
<li>start与stop用于限定查询范围，作用于索引，表示开始和结束索引</li>
<li>offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量</li>
</ul>
</blockquote>
<ul>
<li><p>获取集合数据总量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zcard key</span><br><span class="line">zcount key min max</span><br></pre></td></tr></table></figure></li>
<li><p>集合交、并操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zinterstore destination numkeys key [key ...]	</span><br><span class="line">#numkeys为集合个数，求交集时score会求和，也可以改为求最小最大</span><br><span class="line">zunionstore destination numkeys key [key ...]</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="sorted-set-类型数据的扩展操作"><a href="#sorted-set-类型数据的扩展操作" class="headerlink" title="sorted_set 类型数据的扩展操作"></a>sorted_set 类型数据的扩展操作</h4><p><strong>业务场景</strong></p>
<p>票选广东十大杰出青年，各类综艺选秀海选投票 </p>
<p>各类资源网站TOP10（电影，歌曲，文档，电商，游戏等）</p>
<p>聊天室活跃度统计 </p>
<p>游戏好友亲密度</p>
<p><strong>业务分析</strong></p>
<ul>
<li>为所有参与排名的资源建立排序依据</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li><p>score值获取与修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrank key member </span><br><span class="line">zrevrank key member</span><br></pre></td></tr></table></figure></li>
<li><p>获取数据对应的索引（排名）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zscore key member </span><br><span class="line">zincrby key increment member</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Tips 13：</p>
<ul>
<li>redis 应用于计数器组合排序功能对应的排名</li>
</ul>
<h4 id="sorted-set-类型数据操作的注意事项"><a href="#sorted-set-类型数据操作的注意事项" class="headerlink" title="sorted_set 类型数据操作的注意事项"></a>sorted_set 类型数据操作的注意事项</h4><ul>
<li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li>
<li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时候要慎重</li>
<li>sorted_set 底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据，score值将被反复覆盖，保留最后一次修改的结果</li>
</ul>
<h4 id="sorted-set-类型应用场景"><a href="#sorted-set-类型应用场景" class="headerlink" title="sorted_set 类型应用场景"></a>sorted_set 类型应用场景</h4><p><strong>业务场景</strong></p>
<p>​    基础服务+增值服务类网站会设定各位会员的试用，让用户充分体验会员优势。例如观影试用VIP、游戏VIP体验、云盘下载体验VIP、数据查看体验VIP。当VIP体验到期后，如果有效管理此类信息。即便对于正式VIP用户也存在对应的管理方式。 </p>
<p>​    网站会定期开启投票、讨论，限时进行，逾期作废。如何有效管理此类过期信息。</p>
<p><strong>解决方案</strong></p>
<ul>
<li><p>对于基于时间线限定的任务处理，将处理时间记录为score值，利用排序功能区分处理的先后顺序</p>
</li>
<li><p>记录下一个要处理的时间，当到期后处理对应任务，移除redis中的记录，并记录下一个要处理的时间</p>
</li>
<li><p>当新任务加入时，判定并更新当前下一个要处理的任务时间</p>
</li>
<li><p>为提升sorted_set的性能，通常将任务根据特征存储成若干个sorted_set。例如1小时内，1天内，周内，月内，季内，年度等，操作时逐级提升，将即将操作的若干个任务纳入到1小时内处理的队列中</p>
</li>
<li><p>获取当前系统时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Tips 14：</p>
<ul>
<li>redis 应用于定时任务执行顺序管理或任务过期管理</li>
</ul>
<p><strong>业务场景</strong></p>
<p>任务/消息权重设定应用 当任务或者消息待处理，形成了任务队列或消息队列时，对于高优先级的任务要保障对其优先处理，如何实现任务权重管理。</p>
<p><strong>解决方案</strong></p>
<ul>
<li>对于带有权重的任务，优先处理权重高的任务，采用score记录权重即可 </li>
</ul>
<p>多条件任务权重设定</p>
<p>​    如果权重条件过多时，需要对排序score值进行处理，保障score值能够兼容2条件或者多条件，例如外贸订单优先于国内订单，总裁订单优先于员工订单，经理订单优先于员工订单</p>
<ul>
<li>因score长度受限，需要对数据进行截断处理，尤其是时间设置为小时或分钟级即可（折算后）</li>
<li>先设定订单类别，后设定订单发起角色类别，整体score长度必须是统一的，不足位补0。第一排序规则首位不得是0<ul>
<li>例如外贸101，国内102，经理004，员工008。</li>
<li>员工下的外贸单score值为101008（优先）</li>
<li>经理下的国内单score值为102004</li>
</ul>
</li>
</ul>
<p>Tips 15：</p>
<ul>
<li>redis 应用于即时任务/消息队列执行管理</li>
</ul>
<h3 id="数据类型实践案例"><a href="#数据类型实践案例" class="headerlink" title="数据类型实践案例"></a>数据类型实践案例</h3><h4 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h4><p>人工智能领域的语义识别与自动对话将是未来服务业机器人应答呼叫体系中的重要技术，百度自研用户评价语义识别服务，免费开放给企业试用，同时训练百度自己的模型。现对试用用户的使用行为进行限速，限制每个用户每分钟最多发起10次调用</p>
<p><strong>解决方案</strong></p>
<ul>
<li><p>设计计数器，记录调用次数，用于控制业务执行次数。以用户id作为key，使用次数作为valu</p>
</li>
<li><p>在调用前获取次数，判断是否超过限定次数 </p>
<p>​    不超过次数的情况下，每次调用计数+1 </p>
<p>​    业务调用失败，计数-1</p>
</li>
<li><p>为计数器设置生命周期为指定周期，例如1秒/分钟，自动清空周期内使用次数</p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210731103753736.png" alt="image-20210731103753736"></p>
</li>
</ul>
<p><strong>解决方案改良</strong></p>
<ul>
<li><p>取消最大值的判定，利用incr操作超过最大值抛出异常的形式替代每次判断是否大于最大值</p>
</li>
<li><p>判断是否为nil， </p>
<p>​    如果是，设置为Max-次数 </p>
<p>​    如果不是，计数+1 </p>
<p>​    业务调用失败，计数-1</p>
</li>
<li><p>遇到异常即+操作超过上限，视为使用达到上限</p>
</li>
</ul>
<p>Tips 16：</p>
<ul>
<li>edis 应用于限时按次结算的服务控制</li>
</ul>
<h4 id="业务场景-1"><a href="#业务场景-1" class="headerlink" title="业务场景"></a>业务场景</h4><p>使用微信的过程中，当微信接收消息后，会默认将最近接收的消息置顶，当多个好友及关注的订阅号同时发送消息时，该排序会不停的进行交替。同时还可以将重要的会话设置为置顶。一旦用户离线后，再次打开微信时，消息该按照什么样的顺序显示？</p>
<p><strong>业务分析</strong></p>
<p><img src="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210731104531736.png" alt="image-20210731104531736"></p>
<p><strong>解决方案</strong></p>
<ul>
<li>依赖list的数据具有顺序的特征对消息进行管理，将list结构作为栈使用</li>
<li>对置顶与普通会话分别创建独立的list分别管理</li>
<li>当某个list中接收到用户消息后，将消息发送方的id从list的一侧加入list（此处设定左侧）</li>
<li>多个相同id发出的消息反复入栈会出现问题，在入栈之前无论是否具有当前id对应的消息，先删除对应id</li>
<li>推送消息时先推送置顶会话list，再推送普通会话list，推送完成的list清除所有数据</li>
<li>消息的数量，也就是微信用户对话数量采用计数器的思想另行记录，伴随list操作同步更新</li>
</ul>
<p>Tips 17：</p>
<ul>
<li>redis 应用于基于时间顺序的数据操作，而不关注具体时间</li>
</ul>
<h3 id="解决方案列表"><a href="#解决方案列表" class="headerlink" title="解决方案列表"></a>解决方案列表</h3><ul>
<li>Tips 1：redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性</li>
<li>Tips 2：redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作</li>
<li>Tips 3：redis应用于各种结构型和非结构型高热度数据访问加速</li>
<li>Tips 4：redis 应用于购物车数据存储设计</li>
<li>Tips 5：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计</li>
<li>Tips 6：redis 应用于具有操作先后顺序的数据控制</li>
<li>Tips 7：redis 应用于最新消息展示</li>
<li>Tips 8：redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等</li>
<li>Tips 9：redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</li>
<li>Tips 10：redis 应用于同类型不重复数据的合并、取交集操作</li>
<li>Tips 11：redis 应用于同类型数据的快速去重</li>
<li>Tips 12：redis 应用于基于黑名单与白名单设定的服务控制</li>
<li>Tips 13：redis 应用于计数器组合排序功能对应的排名</li>
<li>Tips 14：redis 应用于定时任务执行顺序管理或任务过期管理</li>
<li>Tips 15：redis 应用于及时任务/消息队列执行管理</li>
<li>Tips 16：redis 应用于按次结算的服务控制</li>
<li>Tips 17：redis 应用于基于时间顺序的数据操作，而不关注具体时间</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/02_redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" data-id="ckrxceg5v00028cuy10q76blg" data-title="02_redis数据类型" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">黑马程序员</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/" rel="tag">黑马程序员 SSM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot/" rel="tag">黑马程序员 springboot</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/" style="font-size: 15px;">黑马程序员</a> <a href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SSM/" style="font-size: 20px;">黑马程序员 SSM</a> <a href="/tags/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot/" style="font-size: 10px;">黑马程序员 springboot</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/11_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">11_主从复制</a>
          </li>
        
          <li>
            <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/10_%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">10_高级数据类型</a>
          </li>
        
          <li>
            <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/09_redis%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/">09_redis服务器配置</a>
          </li>
        
          <li>
            <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/08_%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/">08_删除策略</a>
          </li>
        
          <li>
            <a href="/2021/08/04/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/redis/07_redis%E4%BA%8B%E5%8A%A1/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>